<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>houdini_voxyde_fracture_setups</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="Houdini.html">Houdini</a>
</p>

<div id="Voxyde - Fracture Setups"><h1 id="Voxyde - Fracture Setups" class="header"><a href="#Voxyde - Fracture Setups">Voxyde - Fracture Setups</a></h1></div>
<div id="Voxyde - Fracture Setups-[[https://www.youtube.com/watch?v=0vqRqKpI-LY|YouTube - Voxyde - Fracture Setups]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY|YouTube - Voxyde - Fracture Setups]]" class="header"><a href="#Voxyde - Fracture Setups-[[https://www.youtube.com/watch?v=0vqRqKpI-LY|YouTube - Voxyde - Fracture Setups]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY">YouTube - Voxyde - Fracture Setups</a></a></h4></div>

<ul>
<li>
<a href="houdini_voxyde_fracture_setups.html#Intro">00:00:00 - 00:02:16 : Intro</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Simple Voronoi">00:02:16 - 00:04:20 : Simple Voronoi</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Voronoi and Noise">00:04:20 - 00:12:10 : Voronoi and Noise</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Simple Boolean">00:12:10 - 00:31:51 : Simple Boolean</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Boolean and Voroonoi">00:31:51 - 00:43:15 : Boolean and Voronoi</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Art Direct Voronoi">00:43:15 - 00:47:17 : Art Direct Voronoi</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#UVs setup">00:47:17 - 00:51:51 : UVs setup</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Recursive Fracturing">00:51:51 - 01:07:28 : Recursive Fracturing</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Chipping">01:07:28 - 01:15:49 : Chipping</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Glass Boolean Fracture">01:15:49 - 01:30:21 : Glass Boolean Fracture</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Compiled Block">01:30:21 - 01:38:29 : Compiled Block</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#Glass Voronoi Fracture">01:38:29 - 01:49:39 : Glass Voronoi Fracture</a>

<li>
<a href="houdini_voxyde_fracture_setups.html#RBD Connected Faces">01:49:39 - 01:51:38 : RBD Connected Faces</a>

</ul>
<div id="Voxyde - Fracture Setups-Intro"><h2 id="Intro" class="header"><a href="#Voxyde - Fracture Setups-Intro">Intro</a></h2></div>
<div id="Voxyde - Fracture Setups-Intro-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=0s|YouTube - Intro]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=0s|YouTube - Intro]]" class="header"><a href="#Voxyde - Fracture Setups-Intro-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=0s|YouTube - Intro]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=0s">YouTube - Intro</a></a></h4></div>
<p>
The course features the preferred techniques of the author (Voxyde) for fracturing geometry in Houdini.
</p>

<p>
The materials covered in the course are:
</p>
<ul>
<li>
Concrete

<li>
Glass

<li>
...But for wood, RBD tools would be sufficient.

</ul>
<p>
Apparently, RBD based solutions tend to be slow with complex setups, and less 'art directable'. And changes however small need to be re-baked. Hopefully the foundation in the course will give more flexibility.
</p>

<div id="Voxyde - Fracture Setups-Simple Voronoi"><h2 id="Simple Voronoi" class="header"><a href="#Voxyde - Fracture Setups-Simple Voronoi">Simple Voronoi</a></h2></div>
<div id="Voxyde - Fracture Setups-Simple Voronoi-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=136s|YouTube - Simple Voronoi]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=136s|YouTube - Simple Voronoi]]" class="header"><a href="#Voxyde - Fracture Setups-Simple Voronoi-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=136s|YouTube - Simple Voronoi]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=136s">YouTube - Simple Voronoi</a></a></h4></div>

<div id="Voxyde - Fracture Setups-Simple Voronoi-Initial Geometry"><h3 id="Initial Geometry" class="header"><a href="#Voxyde - Fracture Setups-Simple Voronoi-Initial Geometry">Initial Geometry</a></h3></div>

<p>
Building the starting geometry:
</p>

<ul>
<li>
Create a <code>Grid</code> at the SOP level (inside a <code>Geometry</code> container):

<ul>
<li>
<code>Primitive Type</code> is <code>Polygon</code>

<li>
<code>Orientation</code> to <code>ZX Plane</code>

<li>
<code>Size</code> 25 x 25

<li>
<code>Row</code> &amp; <code>Columns</code> to 100 x 100

</ul>
<li>
Chain a <code>Mountain</code> node:

<ul>
<li>
<code>Attribute Names</code> to <code>Vector</code> and <code>P</code>

<li>
<code>Attribute Class</code> to <code>point</code>

<li>
Check <code>Noise Along Vector</code>

<li>
<code>Vector Attribute</code> to <code>N</code>

<li>
<code>Range Values</code> to <code>Zero Centered</code> 

<li>
<code>Amplitude</code> 1.4

<li>
<code>Noise Type</code> to <code>Simplex</code>

<li>
<code>Element Size</code> to 6

</ul>
<li>
Add and <code>Extrude Volume</code>:

<ul>
<li>
<code>Depth</code> to <code>-1.3</code>

<li>
<code>Base Normal</code> to 0,1,0

<li>
Check <code>Flatten Base</code>

<li>
<code>Base Padding</code> of 0.1

<li>
<code>Base Lift</code> of 1

</ul>
<li>
Finish up with a <code>Null</code>, renamed to <code>terrain</code>

</ul>
<p>
Keep this network as a detached base, and <code>Object Merge</code> into the various setup exercises.
</p>
<div id="Voxyde - Fracture Setups-Simple Voronoi-Initial Geometry-Diagram - Terrain base"><h4 id="Diagram - Terrain base" class="header"><a href="#Voxyde - Fracture Setups-Simple Voronoi-Initial Geometry-Diagram - Terrain base">Diagram - Terrain base</a></h4></div>
<pre>
    ┌──────┐
    │ grid │
    └──┬───┘
       │
   ┌───┴────┐
   │mountain│
   └───┬────┘
       │
 ┌─────┴───────┐
 │extrudevolume│
 └─────┬───────┘
       │
       │
   ┌───┴─────┐
   │uvtexture│
   └───┬─────┘
       │
    ┌──┴───┐
    │ null │
    └──────┘


  ┌────────────┐
  │objectmerge │
  └────────────┘
</pre>

<div id="Voxyde - Fracture Setups-Simple Voronoi-First Demo - Simple Voronoi"><h3 id="First Demo - Simple Voronoi" class="header"><a href="#Voxyde - Fracture Setups-Simple Voronoi-First Demo - Simple Voronoi">First Demo - Simple Voronoi</a></h3></div>

<ul>
<li>
At the SOP level, create a free-standing <code>Object Merge</code>:

<ul>
<li>
Check <code>Enable Merge 1</code>

<li>
Enter the path to the initial setup (from above) in the <code>Object 1</code> field:

<ul>
<li>
You can copy the <code>Null</code> node, and pasting into the <code>Object 1</code> field will convert to a path.

</ul>
</ul>
</ul>
<p>
The first most basic example is going to create points to work with.
</p>

<ul>
<li>
Add a <code>VDB from Polygons</code> to the <code>Object Merge</code> node:

<ul>
<li>
Switch from the default 'Distance VDB' to a <code>Fog VDB</code> set to <code>density</code>

</ul>
<li>
Add a <code>Scatter</code> node:

<ul>
<li>
Un-check <code>Relax Iterations</code>

<li>
Reduce the <code>Force Total Count</code> to something like <code>112</code> 

</ul>
<li>
Forking from the <code>Object Merge</code> node, drop a <code>Voronoi Fracture</code> node:

<ul>
<li>
Plug the <code>Scatter</code> into the <code>Voronoi Fractre</code> node's input 2

</ul>
</ul>
<p>
The Viewport should be showing the multi-colored cells across the geometry.
</p>

<p>
<span id="Voxyde - Fracture Setups-Simple Voronoi-First Demo - Simple Voronoi-NOTE"></span><strong id="NOTE">NOTE</strong>: To see the colored cells, you may need to switch on the visualizer on the <code>Voronoi Fracture</code> node's <code>Piece Prefix</code> field (the location style icon), and make sure the Viewport Visualizer icon is set to show it.
</p>

<ul>
<li>
If you add an <code>Exploded View</code> node after the <code>Voronoi Fracture</code> you will see all the parts separated:

<ul>
<li>
Adjust the <code>Uniform Scale</code> to move the parts in and out.

</ul>
</ul>
<p>
The feature of this fracture approach is that the inside edges are very simple and flat.
</p>

<div id="Voxyde - Fracture Setups-Simple Voronoi-First Demo - Simple Voronoi-Diagram - Simple Voronoi"><h4 id="Diagram - Simple Voronoi" class="header"><a href="#Voxyde - Fracture Setups-Simple Voronoi-First Demo - Simple Voronoi-Diagram - Simple Voronoi">Diagram - Simple Voronoi</a></h4></div>
<pre>
 ┌──────────────┐
 │ object_merge │
 └──────┬───────┘
        ├────────────────┐
        │                │
        │         ┌──────┴────────┐
        │         │ vbdfrompolygon│
        │         │    FogVDB     │
        │         └──────┬────────┘
        │                │
        │          ┌─────┴────┐
        │          │  scatter │
        │          └─────┬────┘
        │     ┌──────────┘
        │     │
   ┌────┴─────┴──────┐
   │ voronoifracture │
   └───────┬─────────┘
           │
   ┌───────┴──────┐
   │ explodedview │
   └──────────────┘
</pre>

<div id="Voxyde - Fracture Setups-Voronoi and Noise"><h2 id="Voronoi and Noise" class="header"><a href="#Voxyde - Fracture Setups-Voronoi and Noise">Voronoi and Noise</a></h2></div>
<div id="Voxyde - Fracture Setups-Voronoi and Noise-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=260s|YouTube - Voronoi and Noise]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=260s|YouTube - Voronoi and Noise]]" class="header"><a href="#Voxyde - Fracture Setups-Voronoi and Noise-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=260s|YouTube - Voronoi and Noise]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=260s">YouTube - Voronoi and Noise</a></a></h4></div>

<p>
We'll duplicate the setup from above, and add noise to try to fix this 'clean cut' feature.
</p>

<ul>
<li>
Drop a <code>Null</code> after the <code>Object Merge</code> so we can work above this node.

<li>
Before the <code>Null</code>, record the position of the geometry:

<ul>
<li>
Drop a <code>Rest Position</code> node:

<ul>
<li>
Set <code>Rest Normals</code> to <code>Add Normals</code>

</ul>
<li>
Then a <code>Mountian</code> node:

<ul>
<li>
Turn OFF the <code>Noise Along Vector</code> Checkbox.

<li>
Increase the <code>Element Size</code> to 2.5

<li>
<code>Amplitude</code> to 0.8

</ul>
</ul>
<li>
After the <code>Voronoi Fracture</code> and before the <code>Explode View</code>:

<ul>
<li>
Add another <code>Rest Position</code> node from the output:

<ul>
<li>
Set <code>Mode</code> to <code>Swap Rest</code>.

<li>
Set <code>Rest Normals</code> to <code>Add Normals</code> (to restore the normals)

<li>
This will force the geometry back to the original and initial <code>Rest Position</code>

</ul>
</ul>
</ul>
<p>
This noise technique tends to produce some nasty edge artifacts, where slivers of surface break apart along the edges of the surface and fracture sides.
</p>

<div id="Voxyde - Fracture Setups-Voronoi and Noise-Substituting a Box in place of the Terrain"><h3 id="Substituting a Box in place of the Terrain" class="header"><a href="#Voxyde - Fracture Setups-Voronoi and Noise-Substituting a Box in place of the Terrain">Substituting a Box in place of the Terrain</a></h3></div>

<p>
The tutorial shows some mitigation by using a box instead of the original terrain style geometry, but this is clearly un-satisfactory in many cases.
</p>

<ul>
<li>
Add a <code>Box</code> node (free-floating for now):

<ul>
<li>
<code>Primitive Type</code> to <code>Polygon Mesh</code>

<li>
Resize in the Viewport (handle tool - <code>&lt;enter&gt;</code>) to match the original Terrain geometry.

</ul>
<li>
Add a <code>Remesh</code> node and keep defaults.

<li>
Now plug these down into the <code>Rest Postion</code> node (substituting the input from the <code>Object Merge</code> and terrain.

<li>
Add a <code>Mountain</code> node after the existing <code>Rest Postion</code> node and before the <code>Null</code> we made:

<ul>
<li>
<code>Amplitude</code> to 0.5

<li>
<code>Noise Type</code> to <code>Simplex</code>

<li>
<code>Element Size</code> to 2.5

</ul>
</ul>
<p>
<span id="Voxyde - Fracture Setups-Voronoi and Noise-Substituting a Box in place of the Terrain-NOTE"></span><strong id="NOTE">NOTE</strong>: _The use of a <code>Remesh</code> node to add geometry divisions to the box (rather than 'upping' the rows and columns was an interesting concept._
</p>

<div id="Voxyde - Fracture Setups-Voronoi and Noise-Continuing to try to mitigate shortcomings"><h3 id="Continuing to try to mitigate shortcomings" class="header"><a href="#Voxyde - Fracture Setups-Voronoi and Noise-Continuing to try to mitigate shortcomings">Continuing to try to mitigate shortcomings</a></h3></div>

<ul>
<li>
Now, try limiting the <code>Amplitude</code> on the <code>Mountain</code> node:

<li>
There is an <code>XYZ</code> icon to the right of the parameter.

<li>
Clicking it splits the fields into x, y and z:

<ul>
<li>
Set to zero amplitude in the 'y' (middle field) direction.

</ul>
<li>
This helps keep the top surface peeling away to some extent.

</ul>
<div id="Voxyde - Fracture Setups-Voronoi and Noise-Fixing the lack of divisions on the inside surface (fracture) surfaces"><h3 id="Fixing the lack of divisions on the inside surface (fracture) surfaces" class="header"><a href="#Voxyde - Fracture Setups-Voronoi and Noise-Fixing the lack of divisions on the inside surface (fracture) surfaces">Fixing the lack of divisions on the inside surface (fracture) surfaces</a></h3></div>

<p>
After the second <code>Rest Position</code> node (near <code>Exploded View</code> in the demo):
</p>
<ul>
<li>
another <code>Remesh</code> is added, but only to the surfaces in the <code>Group</code> called <code>inside</code> (which is added by the <code>Voronoi Fracture</code> in its parameters - <code>Inside Group</code> and <code>Exterior</code> group fields).

<li>
The <code>Remesh</code> took a while to update on the demo (same on 'follow along').

</ul>
<p>
After the <code>Remesh</code> at the end, an <code>RDB Interior Detail</code> node was added:
</p>
<ul>
<li>
Turn off the <code>Detail Size</code> checkbox to disable the slider.

<li>
The <code>Interior Cusp Angle</code> was adjusted to restore the surface to fracture angle sharpness - <code>140</code>

<li>
The <code>Noise Amplitude</code> was adjusted to get a good result on the fracture surfaces - to 0.4 

<li>
The <code>Frequency</code> was bumped up to 2.5 on all axis. 

<li>
There is an interesting checkbox called <code>Visualize Noise Scale</code> which turns on color feedback on the displacement scaling. (Turn off the Viewport Visualizer icon to let this parameter show.)

</ul>
<p>
Next, to add another layer of refinement:
</p>
<ul>
<li>
A <code>Normal</code> node is added:

<ul>
<li>
The effect is applied only to the original surface by adding <code>outside</code> to the <code>Group</code> field.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Voronoi and Noise-Testing the process with the original Terrain."><h3 id="Testing the process with the original Terrain." class="header"><a href="#Voxyde - Fracture Setups-Voronoi and Noise-Testing the process with the original Terrain.">Testing the process with the original Terrain.</a></h3></div>

<p>
To assess the effectiveness of the network so far, instead of the box and its <code>Remesh</code>:
</p>
<ul>
<li>
The original <code>Object Merge</code> is plugged back at the start of the network.

<li>
Drag the Uniform Scale on the <code>Exploded View</code> node to zero, to take a look at the geometry in situation, to see if the cracks hold up 'at rest'.

</ul>
<p>
I found that I had to head back to the <code>Mountain</code> node (before the null) and tweak the <code>Amplitude</code> down to <code>0.3</code> to reduce the join artifacts.
</p>

<p>
In conclusion, in this case, it holds up quite well, but there's no guarantee that there won't be many artifacts with such organic input geometry.
</p>


<div id="Voxyde - Fracture Setups-Simple Boolean"><h2 id="Simple Boolean" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean">Simple Boolean</a></h2></div>
<div id="Voxyde - Fracture Setups-Simple Boolean-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=730s|YouTube - Simple Boolean]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=730s|YouTube - Simple Boolean]]" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=730s|YouTube - Simple Boolean]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=730s">YouTube - Simple Boolean</a></a></h4></div>

<div id="Voxyde - Fracture Setups-Simple Boolean-Two Ways to Fracture"><h3 id="Two Ways to Fracture" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-Two Ways to Fracture">Two Ways to Fracture</a></h3></div>
<p>
There are only two ways to create fractures:
</p>
<ul>
<li>
Scatter points and use a Voronoi Fracture

<li>
Use 'cutter' object to be used as booleans

</ul>
<div id="Voxyde - Fracture Setups-Simple Boolean-Simple Boolean"><h3 id="Simple Boolean" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-Simple Boolean">Simple Boolean</a></h3></div>

<p>
This next section is all about the Boolean approach.
</p>

<p>
For the next demo, duplicate the <code>Object Merge</code> for a new network.
</p>
<ul>
<li>
Add a <code>Null</code> after the <code>Object Merge</code>

<li>
Add a <code>VDB from Polygons</code>:

<ul>
<li>
Set to <code>Fog VDB</code> with <code>density</code>

</ul>
<li>
Drop a <code>Scatter</code> node:

<ul>
<li>
Disable <code>Relax Iterations</code>

<li>
<code>Force Total Count</code> to 10

</ul>
</ul>
<p>
Here, we want to copy geometry onto these points.
</p>

<p>
We'll use a <code>Grid</code>:
</p>
<ul>
<li>
Create a free-floating grid:

<ul>
<li>
This has to be <em>bigger</em> than the terrain in our case to the tune of two or three times bigger.

<li>
The tutorial made the grid <code>Size</code>, 77 x 77

</ul>
</ul>
<p>
Continuing from the <code>Scatter</code>:
</p>
<ul>
<li>
Add an <code>Attribute Randomize</code> node:

<ul>
<li>
Set <code>Attribute Name</code> to <code>N</code>

<li>
<code>Distribution</code> to <code>Inside Sphere</code>:

<ul>
<li>
If you turn on <code>Normal</code> visibility in the Viewport (on the right-most icon panel), you should see them randomized.

<li>
If they aren't visible, they may be too small - <code>D</code> in the Viewport, and in the Guides tab, dial up the Normal length.

</ul>
</ul>
<li>
Next add a <code>Copy to Points</code> node:

<ul>
<li>
Connect the <code>Grid</code> to the first input

<li>
Connect the <code>Attribute Randomize</code> node into the second input.

</ul>
</ul>
<p>
Now the copies of the grid are duplicated to each point, and juxtaposed in orientation by the randomized normals on the points.
</p>

<ul>
<li>
Fork a <code>Boolean Fracture</code> from the <code>Null</code>:

<ul>
<li>
<code>Treat Geometry As</code> set to <code>Solid</code> (default)

<li>
<code>Treat Cutting Geometry</code> as <code>Surface</code> (default)

<li>
Then connect the <code>Copy to Points</code> node to input 2

</ul>
<li>
Add an <code>Exploded View</code> node to see the effect:

<ul>
<li>
Remember that you can activate the color in the Viewport

</ul>
</ul>
<p>
Now explore various settings to change the outcome:
</p>
<ul>
<li>
Try the <code>Global Seed</code> on the <code>Scatter</code> node

</ul>
<div id="Voxyde - Fracture Setups-Simple Boolean-The straight edge nature of the cuts"><h3 id="The straight edge nature of the cuts" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-The straight edge nature of the cuts">The straight edge nature of the cuts</a></h3></div>

<p>
The inside edges are flat again (as they were in the Voronoi Fracture example). This time we can affect the 'cutter'.
</p>

<ul>
<li>
Edit the <code>Grid</code>:

<ul>
<li>
<code>Rows</code> and <code>Columns</code> to 100 x 100

</ul>
<li>
After the <code>Grid</code> drop a <code>Mountain</code> node:

<ul>
<li>
Turn off the <code>Noise Along Vector</code> checkbox

<li>
<code>Element Size</code> to <code>5.5</code>

<li>
<code>Amplitude</code> to <code>1.45</code>

<li>
Open the <code>Fractal</code> section:

<ul>
<li>
<code>Roughness</code> to 0.5

</ul>
</ul>
</ul>
<p>
The inside edges will be more organic and varied now. The geometry resolution is directly inherited from the resolution of the 'cutter' object - in this case, our grids.
</p>
<ul>
<li>
Try 'upping' the resolution of the grid to 200 x 200.

</ul>
<p>
Let's fix things a bit more:
</p>
<ul>
<li>
Add a <code>Normal</code> node after the <code>Boolean Fracture</code> node:

<ul>
<li>
Set it to be only on the <code>inside</code> Group.

</ul>
</ul>
<p>
Try tweaking parameters again:
</p>
<ul>
<li>
<code>Scatter</code> node - try a <code>Fourced Total Count</code> to 20

<li>
Perhaps drop the distortion on the <code>Mountain</code> node for the <code>Grid</code>

</ul>
<div id="Voxyde - Fracture Setups-Simple Boolean-Reigning-in the rotation variety on the random Grids"><h3 id="Reigning-in the rotation variety on the random Grids" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-Reigning-in the rotation variety on the random Grids">Reigning-in the rotation variety on the random Grids</a></h3></div>

<ul>
<li>
Disable the <code>Mountain</code> node after the <code>Grid</code> temporarily (to better see what's going on with the grid placement after <code>Copy to Points</code>.

<li>
Disable the <code>Attribute Randomize</code> node too, for the same purpose.

</ul>
<p>
Let's do some <code>Normal</code> manipulation for the <code>Scatter</code> points with a VOP approach:
</p>
<ul>
<li>
After the <code>Scatter</code>, add an <code>Attribute VOP</code>:

<ul>
<li>
Inside:

<ul>
<li>
Create a <code>Parameter</code> node:

<ul>
<li>
<code>Label</code> to <code>dir</code> (for direction):

<ul>
<li>
This parameter will now appear on the VOP up at the SOP level.

</ul>
<li>
<code>Type</code> to <code>3 Float (vector)</code>

<li>
Plug the <code>parm</code> output to the <code>N</code> input on the OUTPUT (geometryvopoutout1) node.

</ul>
</ul>
<li>
On the new <code>dir</code> parameter on the VOP node, make the direction, <code>0, 1, 0</code>

<li>
Turn on the Viewport 'normals' icon to see them all stand up vertically.

</ul>
</ul>
<p>
Now all the grids or planes will be stacked vertically along the vector.
</p>

<p>
Let's create a random value for the <code>Up</code> vector:
</p>
<ul>
<li>
Back inside the <code>Attribute VOP</code>:

<ul>
<li>
From the <code>ptnum</code> output in the INPUT (geometryvopglobal1) node:

<ul>
<li>
Add a <code>Random</code> node:

<li>
<code>Signature</code> to <code>1D Integer Input, 3D Vector</code>

</ul>
<li>
Add a <code>Fit Range</code> node (to restrict the angle variety):

<ul>
<li>
<code>Signature</code> to <code>3D Vector</code>

<li>
<code>Source Min</code> to 0, 0, 0

<li>
<code>Source Max</code> to 1, 1, 1

<li>
<code>Destination Min</code> to -1, -1, -1

<li>
<code>Destination Max</code> to 1, 1, 1

</ul>
<li>
From the <code>shift</code> output:

<ul>
<li>
Add a <code>Bind Export</code> node:

<ul>
<li>
<code>Name</code> to <code>up</code>

<li>
<code>Type</code> to <code>3D Float (vector)</code>

</ul>
</ul>
</ul>
<li>
In the Viewport <code>Visualizer</code> icon (<code>RMB</code>) choose to show the <code>up</code> attribute.

<li>
Now, to tame the rotations:

<ul>
<li>
Before the <code>Bind Export</code>:

<ul>
<li>
add a <code>Multiply</code>:

<ul>
<li>
<code>Constant Type</code> to <code>3 Floats (vector)</code>

<li>
<code>3 Float Default</code> to <code>1, 0, 1</code>

</ul>
<li>
add a <code>Normalize</code> node.

</ul>
</ul>
</ul>
<p>
Previewing the grid layout should show them randomly rotated, but with the same 'up' direction.
</p>

<p>
Now to bring back some customization, turn the <code>Attribute Randomize</code> node again:
</p>
<ul>
<li>
Switch the <code>Operation</code> to <code>Add Value</code>

<li>
Set the <code>Global Scale</code> to zero to have no influence, and adjust to bring back more random rotations from the vertical:

<ul>
<li>
The tutorial settles on <code>0.2</code>

</ul>
</ul>
<p>
More tweaks:
</p>
<ul>
<li>
Put the <code>Force Total Count</code> back to <code>10</code> for the <code>Scatter</code> node.

<li>
Turn the <code>Mountain</code> node back on for the grids.

</ul>
<div id="Voxyde - Fracture Setups-Simple Boolean-Things to Consider with Boolean Fractures"><h3 id="Things to Consider with Boolean Fractures" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-Things to Consider with Boolean Fractures">Things to Consider with Boolean Fractures</a></h3></div>

<ul>
<li>
If the 'cutter' geometry doesn't dissect the subject geometry, the cutter fails to divide the subject, and leaves a problematic surface artifact.

<li>
Another issue is that cutter geometry that's way beyond the useful area (of the cut) is also considered, so is a waste of effort:

</ul>
<div id="Voxyde - Fracture Setups-Simple Boolean-Limiting the extent of the cutter geometry beyond what's useful"><h3 id="Limiting the extent of the cutter geometry beyond what's useful" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-Limiting the extent of the cutter geometry beyond what's useful">Limiting the extent of the cutter geometry beyond what's useful</a></h3></div>

<ul>
<li>
In our last example:

<ul>
<li>
Fork from the <code>Null</code> and add a <code>Bound</code> node:

<ul>
<li>
Set the <code>Lower Paddin</code> to 1, 1, 1

<li>
Set the <code>Upper Paddin</code> to 1, 1, 1

</ul>
</ul>
<li>
After the <code>Copy to Points</code>:

<ul>
<li>
add a <code>Group</code> node:

<ul>
<li>
<code>Group Name</code> to <code>toDelete</code>

<li>
<code>Group Type</code> to <code>Points</code>

<li>
Disable the <code>Base Group</code> checkbox.

<li>
<code>Keep in Bounding Regions</code> section:

<ul>
<li>
<code>Enable</code> on

<li>
Set the <code>Bounding Type</code> to <code>Bounding Object (points or vertices only)</code>

</ul>
<li>
plug the <code>Copy to Points</code> into input 1

<li>
plug the <code>Bound</code> into input 2

</ul>
<li>
Next add a <code>Blast</code> node:

<ul>
<li>
<code>Group</code> field to <code>toDelete</code>

<li>
<code>Group Type</code> to <code>Points</code>

<li>
Activate <code>Delete Non Selected</code>

</ul>
</ul>
</ul>
<p>
Streamlining the calculations by culling extra cutter geometry has a noticeable effect on the speed of the Boolean Fracture. 
</p>


<div id="Voxyde - Fracture Setups-Simple Boolean-Creating Grout pieces"><h3 id="Creating Grout pieces" class="header"><a href="#Voxyde - Fracture Setups-Simple Boolean-Creating Grout pieces">Creating Grout pieces</a></h3></div>

<p>
To create similar fracture behavior as seen in concrete:
</p>
<ul>
<li>
Duplicate the cutter object (the <code>Grid</code> in our case) by using a <code>Copy and Transform</code> node:

<ul>
<li>
So, drop the <code>Copy and Transform</code> node after the <code>Grid</code>

<li>
Add a <code>Connectivity</code> node to add a class:

<ul>
<li>
If you look in the <code>Geometry Spreadsheet</code>, you'll see two possible values in the new <code>class</code> attribute, that of <code>0</code> or <code>1</code>.

</ul>
<li>
On the <code>Mountain</code> node:

<ul>
<li>
Go to the <code>Noise Pattern</code> section:

<ul>
<li>
Turn on <code>Use VEXpression</code>, and in the script window:

<ul>
<li>
<code>offset = @class;</code>

<li>
Now the first plane has an <code>Offset</code> of <code>0</code>, the second an <code>Offset</code> of <code>1</code>.

<li>
You can add a multiplier to the expression if you need, something like <code>offset = @class * 4</code>.

</ul>
</ul>
</ul>
<li>
This results in some very close slices, that give chunks and slivers between the fracture lines.

<li>
To enhance this effect, you can up the value in the <code>Total [[Number]]</code> field of the <code>Copy and Transform</code> node.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Boolean and Voronoi"><h2 id="Boolean and Voronoi" class="header"><a href="#Voxyde - Fracture Setups-Boolean and Voronoi">Boolean and Voronoi</a></h2></div>
<div id="Voxyde - Fracture Setups-Boolean and Voronoi-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=1911s|YouTube - Boolean and Voronoi]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=1911s|YouTube - Boolean and Voronoi]]" class="header"><a href="#Voxyde - Fracture Setups-Boolean and Voronoi-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=1911s|YouTube - Boolean and Voronoi]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=1911s">YouTube - Boolean and Voronoi</a></a></h4></div>

<p>
The problem with the Boolean fracture result is the inconsistent range of chunk sizes and the lack of predictability. Combining Boolean and Voronoi is a mitigating technique.
</p>

<div id="Voxyde - Fracture Setups-Boolean and Voronoi-New Demo"><h3 id="New Demo" class="header"><a href="#Voxyde - Fracture Setups-Boolean and Voronoi-New Demo">New Demo</a></h3></div>

<p>
Start by duplicating the <code>Object Merge</code> node.
</p>
<ul>
<li>
To keep organized, drop a <code>Null</code> node after the <code>Object Merge</code> node.

<li>
Add a <code>VDB from Polygons</code> node:

<ul>
<li>
Switch to <code>Fog VDB</code> with <code>denisity</code> as the attribute.

</ul>
<li>
Add a <code>Scatter</code> to scatter points:

<ul>
<li>
<code>Relax Iterations</code> off

<li>
<code>Force Total Count</code> to 60

</ul>
<li>
Fork a <code>Voronoi Fracture</code> from the <code>Null</code>:

<ul>
<li>
Plug the <code>Scatter</code> into input 2

</ul>
<li>
Now drop a <code>Blast</code> node after everything from the <code>Voronoi Fracture</code> node:

<ul>
<li>
Set the <code>Group</code> field to <code>inside</code> (and you can get this from the dropdown menu at the end of the field).

<li>
Set to <code>Delete Non Selected</code>

</ul>
</ul>
<p>
This produces a series of geometry elements that define the inside edges, and we can manipulate these to 'cut' through the original geometry using the Boolean method.
</p>

<p>
The issue we have, is that the cutter geometry has to be <em>BIGGER</em> than the subject geometry. (Recall that if the cutter doesn't completely dissect the geo, it'll just leave artifacts.)
</p>

<p>
To extend the inside edge geo:
</p>
<ul>
<li>
Between the <code>Object Merge</code> and the <code>Null</code> add a <code>Bound</code> node:

<ul>
<li>
The scale and size will depend on the project, but for this demo:

<ul>
<li>
Up the <code>Lower Padding</code> to 1 in all fields

<li>
Up the <code>Upper Padding</code> to 1 in all fields.

</ul>
</ul>
<li>
At this stage, we have a lot of doubled polygons (edge face polygons):

<ul>
<li>
We need to fuse all of these points:

<ul>
<li>
Drop a <code>Fuse</code> node after the <code>Blast</code>:

<ul>
<li>
Default settings should be fine.o

</ul>
<li>
Drop a <code>Clean</code> node after the <code>Fuse</code>:

<ul>
<li>
Check 'On' the <code>Fix Overlaps</code> checkbox.

<li>
Un-check the <code>Delete Overlap Pairs</code> option.

</ul>
</ul>
</ul>
<li>
Now the Viewport should be flicker free.

</ul>
<p>
The next task is to add noise to the cutter geometry:
</p>
<ul>
<li>
Add a <code>Remesh</code> node:

<ul>
<li>
Try to match the sort of polygon size of the geometry that will be cut (the <code>Object Merge</code> in our case).

<li>
Template the <code>Object Merge</code> to compare the cutter geo.

<li>
<code>Target Size</code> of 0.4

</ul>
<li>
Add a <code>Mountain</code> node to distort the cutter geo:

<ul>
<li>
Disable the <code>Noise Along Vector</code>

<li>
Increase the <code>Element Size</code> to around 2

<li>
<code>Amplitude</code> to about 0.48

<li>
For <code>Amplitude Scale</code>, click on the <code>xyz</code> icon, to make three fields: Set to <code>1, 0, 1</code> so that the 'y' direction doesn't get distorted.

</ul>
</ul>
<p>
At this stage, we have to visually inspect the situation, and ensure that the cutter geo is encompassing the target geometry (the <code>Object Merge</code> in our case). This is where templating the <code>Object Merge</code> will be useful.
</p>

<p>
You can adjust settings to improve if there are any coverage issues:
</p>
<ul>
<li>
<code>Amplitude</code> on the <code>Mountian</code> node

<li>
and <code>Lower Padding</code> and <code>Upper Padding</code> on the <code>Bound</code> node.

</ul>
<p>
Now we are in good shape to actually apply the Boolean procedure:
</p>
<ul>
<li>
Fork a <code>Boolean Fracture</code> from the <code>Object Merge</code>:

<ul>
<li>
Plug the <code>Mountain</code> at the end of our cutter geo into <code>input 2</code>

<li>
Remember that switching off the Viewport visualizer, and clicking the location style icon after the <code>Piece Prefix</code> field on the <code>Boolean Fracture</code> node, should give us color feed back for the fracture pieces.

<li>
You could switch off the <code>Object Merge</code> template flag too.

<li>
<code>&lt;shift&gt; w</code> if you still see wireframe when you are in smooth shade mode.

</ul>
</ul>
<p>
The result is a nice combination of the <code>Voronoi Fracture</code> and the <code>Boolean Fracture</code> examples. We have consistent yet random blocks, and relatively clean geometry after the fracturing.
</p>

<p>
The Demo increases the <code>Force Total Count</code> parameter to 80 to make push the affect a little more.
</p>

<p>
We can also add the 'grout' or edge breakage trick here.
</p>
<ul>
<li>
Add a <code>Copy and Transform</code> node after the <code>Remesh</code>:

<ul>
<li>
Set the <code>Total Number</code> to 3

</ul>
<li>
Add a <code>Connectivity</code> node:

<ul>
<li>
This will provide us with a <code>class</code> attribute

</ul>
<li>
Now, on the existing <code>Mountain</code> node:

<ul>
<li>
In the <code>Noise Pattern</code> secion:

<ul>
<li>
Check on the <code>Use VEXpression</code> option.

<li>
Add the expression <code>offset = @class * 3:</code>

</ul>
</ul>
<li>
Add an <code>Exploded View</code> node, and take a look at the results.

</ul>
<p>
The demo tweaks the <code>Amplitude</code> of the cutter's <code>Mountain</code> node again, to 0.8, to get even more complexity.
</p>

<div id="Voxyde - Fracture Setups-Boolean and Voronoi-Combining fractures"><h3 id="Combining fractures" class="header"><a href="#Voxyde - Fracture Setups-Boolean and Voronoi-Combining fractures">Combining fractures</a></h3></div>

<p>
For even more fractures, the demo grabs the cutter forming nodes from the previous (Boolean Fracture) demo, and with a <code>Merge</code> node at the end of the cutter setup to combine, (but disabling the <code>Copy and Transform</code> on the reused <code>Boolean Fracture</code> cutter example).
</p>

<p>
The result is a really busy random fracture result, but with some consistency even with randomness.
</p>

<div id="Voxyde - Fracture Setups-Boolean and Voronoi-Try on Different Geometry"><h3 id="Try on Different Geometry" class="header"><a href="#Voxyde - Fracture Setups-Boolean and Voronoi-Try on Different Geometry">Try on Different Geometry</a></h3></div>

<p>
The demo takes the basic <code>Voronoi Fracture</code> and <code>Boolean</code> setup (removing our extra combo stuff at the tail end of the demo) and swaps our terrain (from the <code>Object Merge</code>) and substitutes for a <code>Sphere</code> (Polygon) that's re-sized with the <code>Uniform Scale</code> parameter.
</p>

<table>
<tr>
<td>
I made an error at this point, and used the sphere to generate the scatter points and shattered the Terrain. I noticed that the fractured were somewhat focused from where the sphere was located withing the Terrain geometry. Nice!
</td>
</tr>
</table>


<div id="Voxyde - Fracture Setups-Art Directed Voronoi"><h2 id="Art Directed Voronoi" class="header"><a href="#Voxyde - Fracture Setups-Art Directed Voronoi">Art Directed Voronoi</a></h2></div>
<div id="Voxyde - Fracture Setups-Art Directed Voronoi-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2595s|YouTube - Art Direct Voronoi]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2595s|YouTube - Art Direct Voronoi]]" class="header"><a href="#Voxyde - Fracture Setups-Art Directed Voronoi-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2595s|YouTube - Art Direct Voronoi]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2595s">YouTube - Art Direct Voronoi</a></a></h4></div>

<p>
For this variation on the previous combo demo (where we art-direct the fracture locations), we use the main part of the <code>Voronoi Fracture</code> and <code>Boolean Fracture</code> example (with out the additional cutter network).
</p>

<div id="Voxyde - Fracture Setups-Art Directed Voronoi-Demo"><h3 id="Demo" class="header"><a href="#Voxyde - Fracture Setups-Art Directed Voronoi-Demo">Demo</a></h3></div>

<p>
The basis for this combo method, builds on the use of points to generate Voronoi cells (by allowing us to augment the scatter points and add our own points).
</p>

<p>
We can use a line to set the position of new points, then, the Voronoi technique will fragment using these points in addition to the more random points we already have.
</p>

<div id="Voxyde - Fracture Setups-Art Directed Voronoi-In Practice"><h3 id="In Practice" class="header"><a href="#Voxyde - Fracture Setups-Art Directed Voronoi-In Practice">In Practice</a></h3></div>

<ul>
<li>
Duplicate the previous network (without extras, and delete the redundant <code>Merge</code>).

<li>
Add a free-standing line from the chosen center point of a fracture:

<ul>
<li>
The line needs to extend beyond the edge of the terrain as defined by the <code>Object Merge</code>.

<li>
<code>Direction</code> to 0,0,1 (to point in the <code>z</code> direction)

<li>
<code>Length</code> to around 20 to extend beyond the Terrain.

</ul>
<li>
To make the radial nature of the fracture:

<ul>
<li>
Add a <code>Copy and Transform</code> node:

<ul>
<li>
In the <code>Rotate</code> 'y' parameter, add an expression:

<ul>
<li>
<code>RMB</code> click on the label of the <code>Total Number</code> parameter and choose <code>Copy Parameter</code>

<li>
Insert the cursor in the <code>Rotate</code> <code>y</code> cell, and type <code>360/</code> and then <code>RMB</code> and choose <code>Paste Relative References</code>

<li>
Now when you increase the <code>Total Number</code> slider, the diverging lines should be evenly spaced around the center point.

</ul>
<li>
Set the <code>Total Number</code> to 5

<li>
Check that all the lines extend beyond the bounds of the <code>Object Merge</code> geometry:

<ul>
<li>
If not, adjust the <code>Length</code> parameter on the <code>Line</code> node.

</ul>
</ul>
<li>
Add a <code>Scatter</code> to make radial points:

<ul>
<li>
<code>Relax Iterations</code> off

<li>
<code>Force Total Count</code> to 200

</ul>
<li>
Add a <code>Point Jitter</code> to randomize the points:

<ul>
<li>
We only want to jitter on the X &amp; Z axis, so <code>Axis Scale</code> to <code>1, 0, 1</code>

<li>
Increase the <code>Scale</code> to 2.3

</ul>
</ul>
</ul>
<p>
These new 'art-directed' fracture seeds can now be combined with our original random scatter points.
</p>

<ul>
<li>
Add a <code>Merge</code> after our original <code>Scatter</code> node (from the last demo) and add the 'line' based points.

</ul>
<p>
The result will be more finely cracked radial fractures following our radial dispersing points. (Disable the grout <code>Copy and Transform</code> node to see it more cleanly.)
</p>

<p>
Setting the <code>Force Total Count</code> on the radial points (<code>Scatter</code>) will result in a more defined radial crack.
</p>

<p>
To have the cracks only near the surface, you could add a <code>Transform</code> node after the <code>Point Jitter</code> to move them up in 'y'.
</p>


<div id="Voxyde - Fracture Setups-UVs setup"><h2 id="UVs setup" class="header"><a href="#Voxyde - Fracture Setups-UVs setup">UVs setup</a></h2></div>
<div id="Voxyde - Fracture Setups-UVs setup-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2837s|YouTube - UVs setup]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2837s|YouTube - UVs setup]]" class="header"><a href="#Voxyde - Fracture Setups-UVs setup-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2837s|YouTube - UVs setup]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=2837s">YouTube - UVs setup</a></a></h4></div>

<p>
To be able to texture the fractured geometry, we need a strategy apply UVs to the geometry.
</p>

<div id="Voxyde - Fracture Setups-UVs setup-Terrain UVs"><h3 id="Terrain UVs" class="header"><a href="#Voxyde - Fracture Setups-UVs setup-Terrain UVs">Terrain UVs</a></h3></div>

<p>
Let's head back to the Terrain setup from the beginning of this tutorial.
</p>

<ul>
<li>
Directly after the original <code>Grid</code>:

<ul>
<li>
Drop a <code>UV Texture</code> node:

<ul>
<li>
In our case:

<ul>
<li>
<code>Texture Type</code> to <code>Orthographic</code>

<li>
<code>Projection Axis</code> to <code>Y Axis</code>

<li>
<code>Attribute Class</code> to <code>Vertex</code>

</ul>
</ul>
</ul>
<li>
To check the UV status, drop a <code>UV Quickshade</code> node after the <code>terrain</code> null:

<ul>
<li>
Make sure the <code>texture</code> icon on the Viewport's right side is switched on.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-UVs setup-Fracture Surfaces UVs"><h3 id="Fracture Surfaces UVs" class="header"><a href="#Voxyde - Fracture Setups-UVs setup-Fracture Surfaces UVs">Fracture Surfaces UVs</a></h3></div>

<p>
In our last example demo, we combined two different 'cutter' setups. The following would have to be performed on each cutter. Either work on the 'art-directed' version (which had one cutter), or disable the <code>Merge</code> in the two-cutter setup.
</p>

<ul>
<li>
After the <code>Clean</code> node (after the cutter surfaces have been established):

<ul>
<li>
Add a <code>UV Flatten</code> node:

<ul>
<li>
To see the result, you can fork a <code>UV Quickshade</code> from the <code>UV Flatten</code> or after the <code>Remesh</code> and observe the UVs with the test texture map.

</ul>
</ul>
<li>
We need to ensure the UVs get passed on through the <code>Boolean Fracture</code> in our case:

<ul>
<li>
The <code>Boolean Fracture</code> node has a <code>Output Attribute</code> &gt; <code>Copy Cutting Surface Attributes</code> checkbox - switch it 'On':

<ul>
<li>
Fields will appear below the checkbox on activating:

<ul>
<li>
<code>Point Attributes</code>

<li>
<code>Vertex Attributes</code> (This is the one we need to populate for our setup).

<li>
<code>Primitive Attributes</code>

</ul>
<li>
Put <code>uv</code> in the <code>Vertex Attributes</code> field. (We could add <code>N</code> too, but we can reapply those later.)

</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-UVs setup-View the result"><h3 id="View the result" class="header"><a href="#Voxyde - Fracture Setups-UVs setup-View the result">View the result</a></h3></div>

<ul>
<li>
Just before the <code>Exploded View</code> node at the end, add a <code>UV Quickshade</code> node.

<li>
While we are in the location, drop a <code>Normal</code> node above the <code>UV Quickshade</code>:

<ul>
<li>
Set the <code>Group</code> field to <code>inside</code>

<li>
Set the <code>Cusp Angle</code> to <code>180</code>

<li>
<span id="Voxyde - Fracture Setups-UVs setup-View the result-NOTE"></span><strong id="NOTE">NOTE</strong>: <em>The Normal node made my geometry worse. The geo seemed Ok before including it.</em>

</ul>
<li>
Look at the <code>Exploded View</code> node result in the Viewport (make sure the <code>texture</code> icon is 'On' on the Viewport icon panel).

<li>
In the tutorial, it becomes apparent that the fracture surface UVs are much larger than the regular surface:

<ul>
<li>
To fix this we need to scale <em>up</em> the fracture UVs:

<ul>
<li>
<em>BEFORE</em> the <code>UV Quickshade</code>, add a <code>UV Transform</code>:

<ul>
<li>
Set the <code>Group</code> to <code>inside</code> (since we only want to scale the fracture surfaces)

<li>
Set the <code>Scale</code> (in our case) to something like <code>3</code> to match the regular surface size:

<ul>
<li>
Preview in the Viewport with the <code>UV Quickshade</code> visible.

</ul>
</ul>
</ul>
</ul>
<li>
Repeat this process for any other 'cutter' setups:

<ul>
<li>
Get all the independent fracture surface cutters in the same scale <em>BEFORE</em> the <code>Merge</code> node.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Recursive Fracturing"><h2 id="Recursive Fracturing" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing">Recursive Fracturing</a></h2></div>
<div id="Voxyde - Fracture Setups-Recursive Fracturing-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=3111s|YouTube - Recursive Fracturing]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=3111s|YouTube - Recursive Fracturing]]" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=3111s|YouTube - Recursive Fracturing]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=3111s">YouTube - Recursive Fracturing</a></a></h4></div>

<p>
Recursive Fracturing involves taking the fracture pieces, and further fracturing them in turn.
</p>

<table>
<tr>
<td>
The main topic in this chapter is more about selections and groups, with the fracturing actually being 'more of the same.'
</td>
</tr>
</table>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Starting Point"><h3 id="Starting Point" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Starting Point">Starting Point</a></h3></div>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Starting Point-Diagram - Starting point for Recursive Fracturing"><h4 id="Diagram - Starting point for Recursive Fracturing" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Starting Point-Diagram - Starting point for Recursive Fracturing">Diagram - Starting point for Recursive Fracturing</a></h4></div>

<p>
In the tutorial, the starting point was a cleaned up Boolean &amp; Voronoi mix:
</p>
<pre>
   ┌──────────────┐
   │ object_merge │
   └──────┬───────┘
        ┌─┴─────────────────┐
        │               ┌───┴───┐
        │               │ bound │
        │               └───┬───┘
        │                ┌──┴───┐
        │                │ null │
        │                └──┬───┴───────────────┐
        │                   │          ┌────────┴────────┐
        │                   │          │ vdbfrompolygons │
        │                   │          └────────┬────────┘
        │                   │                   │
        │                   │             ┌─────┴──┐
        │                   │             │scatter │
        │                   │             └─────┬──┘
        │                   │                   │
        │                   │    ┌──────────────┘
        |                   │    │
        │           ┌───────┴────┴────┐
        │           │ volonoifracture │
        │           └───────┬─────────┘
        │                ┌──┴────┐
        │                │ blast │
        │                └──┬────┘
        │                ┌──┴───┐
        │                │ fuse │
        │                └──┬───┘
        │                ┌──┴────┐
        │                │ clean │
        │                └──┬────┘
        │                   │
        │                ┌──┴─────┐
        │                │ remesh │
        │                └──┬─────┘
        │                   │
        │               ┌───┴──────┐
        │               │ mountain │
        │               └───┬──────┘
        │       ┌───────────┘
        │       │
   ┌────┴───────┴───┐
   │ booleanfracture│
   └──────┬─────────┘
          │   (You could put a `Normal` node here; inbetween the Boolean Fracture and the Exploded View.)
   ┌──────┴───────┐
   │ explodedview │
   └──────────────┘
</pre>


<div id="Voxyde - Fracture Setups-Recursive Fracturing-Selecting chunks"><h3 id="Selecting chunks" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Selecting chunks">Selecting chunks</a></h3></div>

<p>
The tutorial suggests using a technique of 'packing' the geometry. This will mean that each chunk will be represented as a point (with the geo referenced internally).
</p>

<ul>
<li>
Drop an <code>Assemble</code> node just before the ending <code>Exploded View</code> node:

<ul>
<li>
Deactivate the <code>Connect Name Attribute</code>, we don't need it because we already have a name attribute.

<li>
Activate the <code>Create Packed Primitives</code> checkbox:

<ul>
<li>
Now the feedback in the Viewport (if visible) will indicate the number of points.

</ul>
</ul>
<li>
From the <code>Assemble</code> node, you can now pick select individual chunks in the Viewport:

<ul>
<li>
Point mode - and you can select any chunk.

<li>
(You have to select the representative point, not the chunk itself.)

</ul>
<li>
Press <code>&lt;delete&gt;</code>, and you'll create a <code>Blast</code> node which deletes the selected item:

<ul>
<li>
Invert the selection by checking the <code>Delete Non Selected</code> checkbox on the new <code>Blast</code> node.

<li>
The affect will be reversed; now the chunk is that only thing remaining.

</ul>
<li>
To work on the chunk, we have to 'unpack' the geometry:

<ul>
<li>
Drop an <code>Unpack</code> node:

<ul>
<li>
This converts back to full geometry

<li>
The name attribute will be restored also.

</ul>
</ul>
<li>
Fork and add a <code>Scatter</code> node:

<ul>
<li>
Un-check the <code>Relax Iterations</code>

<li>
<code>Force Total Count</code> to <code>5</code>

</ul>
<li>
From the <code>Unpack</code> node, drop a <code>Voronoi Fracture</code>:

<ul>
<li>
Plug in the <code>Scatter</code> as input 2

</ul>
<li>
Look through an <code>Exploded View</code> node. 

</ul>
<div id="Voxyde - Fracture Setups-Recursive Fracturing-Merging the Recursive Fractured chunk back into the geometry"><h3 id="Merging the Recursive Fractured chunk back into the geometry" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Merging the Recursive Fractured chunk back into the geometry">Merging the Recursive Fractured chunk back into the geometry</a></h3></div>

<ul>
<li>
Back at the <code>Assemble</code> node, fork add another <code>Blast</code> (duplicate the existing one to retain the settings):

<ul>
<li>
If duplicated, just un-check the <code>Delete Non Selected</code> to invert the deletion

</ul>
<li>
Add an <code>Unpack</code> to this <code>Blast</code>.

<li>
<code>Merge</code> everything back together after the most recent <code>Voronoi Frature</code> node.

</ul>
<div id="Voxyde - Fracture Setups-Recursive Fracturing-Managing the 'Name' Attributes"><h3 id="Managing the 'Name' Attributes" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Managing the 'Name' Attributes">Managing the 'Name' Attributes</a></h3></div>

<p>
The issue with the recursively fractured pieces, is the 'name' attribute. Ideally we want to control the name attribute for the new sub-chunks.
</p>

<ul>
<li>
Head back to the <code>Voronoi Fracture</code> node, and look at the parameters:

<ul>
<li>
Set the <code>Name Attribute</code> to <code>Append</code> (from <code>Overwrite</code>).

<li>
In the <code>Piece Prefix</code> you can add something logical:

<ul>
<li>
<code>_small</code>

<li>
or

<li>
as the tutorial suggests, <code>-</code> (just a dash):

<ul>
<li>
Look in the <code>Geometry Spreadsheet</code> (switch to 'primitives' list):

<ul>
<li>
Now the original chunk will have the original name, then a dash (<code>-</code>), then part number:

<ul>
<li>
[original name] [prefix] [new item number]

<li>
<code>piece99-0</code>

<li>
So for 5 chunks there'll be 5 names; piece99-0 to piece99-4 inclusive.

</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
<p>
This renames the sub-chunks as they are made, but alternatively, you could just rename everything again at the end.
</p>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Renaming all Chunks option"><h3 id="Renaming all Chunks option" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Renaming all Chunks option">Renaming all Chunks option</a></h3></div>

<p>
If you are happy with just renaming all the 'connected' items at the end:
</p>

<ul>
<li>
Add an additional <code>Assemble</code> node at the end of all the recursive fracturing and merging to have everything renamed in one hit.

</ul>
<div id="Voxyde - Fracture Setups-Recursive Fracturing-Renaming all Chunks option-Diagram - Manual Selection Based Recursive Fracture"><h4 id="Diagram - Manual Selection Based Recursive Fracture" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Renaming all Chunks option-Diagram - Manual Selection Based Recursive Fracture">Diagram - Manual Selection Based Recursive Fracture</a></h4></div>

<p>
Here's where we end up with the <code>Based on manual selection</code> setup as described above:
</p>
<pre>
    ┌──────────────┐                                                 
    │ object_merge │                                                 
    └──────┬───────┘                                                 
         ┌─┴─────────────────┐                                       
         │               ┌───┴───┐                                   
         │               │ bound │                                   
         │               └───┬───┘                                   
         │                ┌──┴───┐                                   
         │                │ null │                                   
         │                └──┬───┴───────────────┐                   
         │                   │          ┌────────┴────────┐          
         │                   │          │ vdbfrompolygons │          
         │                   │          └────────┬────────┘          
         │                   │                   │                   
         │                   │             ┌─────┴──┐                
         │                   │             │scatter │                
         │                   │             └─────┬──┘                
         │                   │                   │                   
         │                   │    ┌──────────────┘                   
         │                   │    │                                  
         │           ┌───────┴────┴────┐                             
         │           │ volonoifracture │                             
         │           └───────┬─────────┘                             
         │                   │                                       
         │                ┌──┴────┐                                  
         │                │ blast │                                  
         │                └──┬────┘                                  
         │                ┌──┴───┐                                   
         │                │ fuse │                                   
         │                └──┬───┘                                   
         │                ┌──┴────┐                                  
         │                │ clean │                                  
         │                └──┬────┘                                  
         │                   │                                       
         │                ┌──┴─────┐                                 
         │                │ remesh │                                 
         │                └──┬─────┘                                 
         │                   │                                       
         │               ┌───┴──────┐                                
         │               │ mountain │                                
         │               └───┬──────┘                                
         │       ┌───────────┘                                       
         │       │                                                   
    ┌────┴───────┴───┐                                               
    │ booleanfracture│                                               
    └──────┬─────────┘                                               
       ┌───┴───┐                                                     
       │normal │   &lt;-- Start next demo section from here.                                                  
       └───┬───┘                                                     
           │                                                         
           └───────────┐                                             
                       │                                             
                 ┌─────┴────┐                                        
                 │ assemble │                                        
                 └─────┬────┘                                        
         ┌─────────────┴────────┐                                    
     ┌───┴───┐              ┌───┴───┐                                
     │ blast │              │ blast │                                
     └───┬───┘              └───┬───┘                                
         │                      │                                    
      ┌──┴───┐               ┌──┴───┐                                
      │unpack│               │unpack│                                
      └──┬───┘               └───┬──┘                                
         │                    ┌──┴──────────────┐                    
         │                    │            ┌────┼────┐               
         │                    │            │ scatter │               
         │                    │            └────┬────┘               
         │                    │     ┌───────────┘                    
         │                    │     │                                
         │              ┌─────┴─────┴────┐                           
         │              │ voronoifracture│                           
         │              └───────┬────────┘                           
         │  ┌───────────────────┘                                    
       ┌─┴──┴───┐                                                    
       │  merge │                                                    
       └────┬───┘                                                    
            │                                                        
            │                                                        
       ┌────┴─────┐                                                  
       │ assemble │     &lt;-- optional - to rename in one hit          
       └────┬─────┘                                                  
            │                                                        
            │                                                        
            │                                                        
     ┌──────┴───────┐                                                
     │ explodedview │                                                
     └──────────────┘                                                
</pre>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Procedural Chunk Selection"><h3 id="Procedural Chunk Selection" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Procedural Chunk Selection">Procedural Chunk Selection</a></h3></div>

<p>
It's more usual for chunks to be selected for recursive fracturing with a more procedural approach. There is often a condition or threshold to pick candidates.
</p>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Next Demo - Size Based Selection"><h3 id="Next Demo - Size Based Selection" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Next Demo - Size Based Selection">Next Demo - Size Based Selection</a></h3></div>

<p>
To continue with the tutorial demo, we can re-use the network from the <code>Boolean Fracture</code> (or the <code>Normal</code> after it if you have one) upwards. (See the graphic above.) We can either duplicate and start a new one, or fork from here. 
</p>

<ul>
<li>
From the <code>Boolean Fracture</code> (or the <code>Normal</code> node in our case):

<ul>
<li>
Add a <code>Measure</code> node:

<ul>
<li>
<code>Measure</code> to <code>Area</code>

<li>
<code>Accumulate</code> to <code>Per Piece</code>

<li>
<code>Piece Attribute</code> to <code>name</code>

</ul>
</ul>
<li>
If you look in the <code>Geometry Spreadsheet</code> (with 'Primitives' selected along the top icons):

<ul>
<li>
You'll see the <code>area</code> attribute, and all the pieces listed with area size.

</ul>
<li>
Add a <code>Split</code> node:

<ul>
<li>
We have to edit this node:

<ul>
<li>
Cog wheel icon (top right) of the parameter panel:

<ul>
<li>
<code>Edit Parameter Interface</code>:

<ul>
<li>
Add a <code>Float</code> parameter (drag from left to middle panel):

<ul>
<li>
<code>Label</code> to <code>Threshold</code>

<li>
<code>Interface Options</code> &gt; <code>Range</code>:

<ul>
<li>
Set to <code>0</code> to <code>200</code>

</ul>
<li>
Click on the <code>Accept</code> button.

</ul>
</ul>
</ul>
<li>
<code>RMB</code> on the <code>Threshold</code> parameter label:

<ul>
<li>
<code>Copy Parameter</code>

</ul>
<li>
Enter some VEX into the <code>Group</code> field:

<ul>
<li>
<code>@area&gt;</code> then paste <code>Paste Relative References</code>

<li>
The finished expression should be something like: <code>@area&gt;'chs("newparameter")'</code>

<li>
It's 'newparameter' because that was the default name in the 'cog wheel' edit we did.

</ul>
</ul>
<li>
If you adjust the <code>Threshold</code> slider, you should see more chunks being selected.

</ul>
<li>
From the left output:

<ul>
<li>
Drop a <code>Null</code>:

<ul>
<li>
Rename <code>big_pieces</code>

</ul>
</ul>
<li>
From the right output:

<ul>
<li>
Drop (or duplicate) a <code>Null</code>:

<ul>
<li>
Rename <code>small_pieces</code>

</ul>
</ul>
<li>
Adjust the <code>Threshold</code> slider on the <code>Split</code> node to split the two groups evenly.

</ul>
<div id="Voxyde - Fracture Setups-Recursive Fracturing-Using a 'For Each' to work on the chunks"><h3 id="Using a 'For Each' to work on the chunks" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Using a 'For Each' to work on the chunks">Using a 'For Each' to work on the chunks</a></h3></div>

<p>
After the <code>big_pieces</code> null node:
</p>
<ul>
<li>
Drop a <code>For-Each Named Primitive</code> node group:

<ul>
<li>
Plug the output from <code>big_pieces</code> null into the for-each top node.

<li>
On the <code>foreach_end</code> node:

<ul>
<li>
Switch on <code>Single Pass</code> for now:

<ul>
<li>
Now you can look through the list of items with the integer slider.

</ul>
</ul>
<li>
Copy and paste the section from the last demo, starting below the <code>Unpack</code>:

<ul>
<li>
You should have three nodes to copy:

<ul>
<li>
<code>Scatter</code>

<li>
<code>Voronoi Fracture</code>:

<ul>
<li>
<span id="Voxyde - Fracture Setups-Recursive Fracturing-Using a 'For Each' to work on the chunks-NOTE"></span><strong id="NOTE">NOTE</strong>: Remember that the <code>Name Attribute</code> needs to be <code>Append</code> and <code>Piece Prefix</code> to something (like <code>-</code> as discussed earlier).

</ul>
</ul>
<li>
Paste into the <code>For-Each</code> (between the 'in' and 'out' nodes) in the original 'forked' layout.

</ul>
<li>
Switch OFF the <code>Single Pass</code> option, so that all the chunks in the split get fractured.

</ul>
<li>
<code>Merge</code> the split groups back together after the <code>For-each</code>:

<ul>
<li>
<code>For-each</code> input 1

<li>
<code>small_pieces</code> input 2

</ul>
</ul>
<p>
You can use any fracturing technique inside the <code>For-each</code> loop of course.
</p>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Using a 'For Each' to work on the chunks-Diagram - Size-Based Recursive Fracture network"><h4 id="Diagram - Size-Based Recursive Fracture network" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Using a 'For Each' to work on the chunks-Diagram - Size-Based Recursive Fracture network">Diagram - Size-Based Recursive Fracture network</a></h4></div>

<p>
Here's how the current <code>Based on Size</code> demo ends up:
</p>
<pre>
    ┌──────────────┐
    │ object_merge │
    └──────┬───────┘
         ┌─┴─────────────────┐
         │               ┌───┴───┐
         │               │ bound │
         │               └───┬───┘
         │                ┌──┴───┐
         │                │ null │
         │                └──┬───┴───────────────┐
         │                   │          ┌────────┴────────┐
         │                   │          │ vdbfrompolygons │
         │                   │          └────────┬────────┘
         │                   │                   │
         │                   │             ┌─────┴──┐
         │                   │             │scatter │
         │                   │             └─────┬──┘
         │                   │                   │
         │                   │    ┌──────────────┘
         │                   │    │
         │           ┌───────┴────┴────┐
         │           │ volonoifracture │
         │           └───────┬─────────┘
         │                   │
         │                ┌──┴────┐
         │                │ blast │
         │                └──┬────┘
         │                ┌──┴───┐
         │                │ fuse │
         │                └──┬───┘
         │                ┌──┴────┐
         │                │ clean │
         │                └──┬────┘
         │                   │
         │                ┌──┴─────┐
         │                │ remesh │
         │                └──┬─────┘
         │                   │
         │               ┌───┴──────┐
         │               │ mountain │
         │               └───┬──────┘
         │       ┌───────────┘
         │       │
    ┌────┴───────┴───┐
    │ booleanfracture│
    └──────┬─────────┘
       ┌───┴───┐
       │normal │   &lt;-- Start next demo section from here.
       └───┬───┘
           │
           └──────────┐
                      │
                 ┌────┴────┐
                 │ measure │
                 └────┬────┘
                      └────────────────┐
                                       │
                                   ┌───┴───┐
                                   │ split │
                                   └───┬───┘
                                       │
                        ┌──────────────┴─────────────┐
                        │                            │
                 ┌──────┴─────┐               ┌──────┴───────┐
                 │ big_pieces │               │ small_pieces │
                 └──────┬─────┘               └──────────────┘
                        │
                        │
                 ┌──────┴────────┐
                 │ foreach_begin │
                 └─────┬───────┬─┘
                       │       │
                       │       │
                       │      ┌┴────────┐
                       │      │ scatter │
                       │      └┬────────┘
                       │    ┌──┘
                       │    │
                 ┌─────┴────┴──┐
                 │ foreach_end │
                 └─────┬───────┘
                       │
                       │
                   ┌───┴─────┐
                   │  merge  │
                   └───┬─────┘
                       │
               ┌───────┴──────┐
               │ explodedview │
               └──────────────┘
</pre>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Recursive Fracturing based on Random Selection"><h3 id="Recursive Fracturing based on Random Selection" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Recursive Fracturing based on Random Selection">Recursive Fracturing based on Random Selection</a></h3></div>

<p>
Start again from the original <code>Boolean Frature</code> (or <code>Normal</code> node if used):
</p>
<ul>
<li>
Drop an <code>Assemble</code> node (since we are going to use packed geometry again):

<ul>
<li>
Turn OFF <code>Create Name Attribute</code>

<li>
Turn ON <code>Create Packed Primitives</code>

<li>
Now the fractured Terrain is points (with referenced geo)

</ul>
<li>
Drop an <code>Attribute Wrangle</code> (for VEX scriping):

<ul>
<li>
Rename to <code>create_selection</code>

<li>
line 1: <code>float val = rand(@ptnum + chi("random_seed"));</code>:

<ul>
<li>
This applies a random number to the variable 'val'

</ul>
<li>
line 2: <code>if(val&gt; ch("threshold")) i@group_selection = 1;</code>:

<ul>
<li>
This compares the random number for each point, and if larger than the 'thresh' parameter (a slider), add the point to a group called 'selection'.

</ul>
<li>
Click on the little slider icon to the upper-right of the VEXpression field:

<ul>
<li>
A parameter labeled <code>Random Seed</code> will be created on the node's parameter panel

<li>
A parameter labeled <code>Threshold</code> will be created on the node's parameter panel

</ul>
</ul>
<li>
Add a <code>Split</code> node:

<ul>
<li>
In the <code>Group</code> field, add <code>selection</code> (to match all points that were added to our 'selection' group by the VEXpression).

<li>
Set the <code>Invert Selection</code> to 'On'

</ul>
<li>
Add two nulls (just like the last demo):

<ul>
<li>
Left - <code>Null</code> (rename to <code>selected</code>)

<li>
Right - <code>Null</code> (rename to <code>not_selected</code>)

</ul>
<li>
To unpack the packed geometry (from the <code>Assemble</code> node):

<ul>
<li>
Add two <code>Unpack</code> nodes, one after each of the <code>Null</code> nodes (<code>selected</code> and <code>not_selected</code>

</ul>
<li>
At this point, the <code>Threshold</code> slider should affect the selection (as will the <code>Random Seed</code> slider):

<ul>
<li>
<code>25</code> on the <code>Threshold</code> will select 25% of the pieces.

<li>
<code>Random Seed</code> will randomize which are selected.

</ul>
</ul>
<p>
The main take-away is the selection process, but you can copy and paste the <code>For-each</code> setup from the last section's network, and plug it all in accordingly (from the <code>selected</code> null, then <code>Merge</code> to the <code>not_selected</code> group). This will recursively fracture all the chunks on the 'selected' group.
</p>

<p>
Remember, because we used an <code>Assemble</code> node to pack the geometry in this example, we now have to include an <code>Unpack</code> node after each null (<code>selected</code> and <code>not_selected</code>).
</p>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Recursive Fracturing based on Random Selection-Diagram - Random Selection Recursive Fracture network"><h4 id="Diagram - Random Selection Recursive Fracture network" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Recursive Fracturing based on Random Selection-Diagram - Random Selection Recursive Fracture network">Diagram - Random Selection Recursive Fracture network</a></h4></div>

<p>
This is what the setup looks like for random selection based Recursive Fractures:
</p>
<pre>
                   ┌──────────────┐
                   │ object_merge │
                   └──────┬───────┘
                        ┌─┴─────────────────┐
                        │               ┌───┴───┐
                        │               │ bound │
                        │               └───┬───┘
                        │                ┌──┴───┐
                        │                │ null │
                        │                └──┬───┴───────────────┐
                        │                   │          ┌────────┴────────┐
                        │                   │          │ vdbfrompolygons │
                        │                   │          └────────┬────────┘
                        │                   │                   │
                        │                   │             ┌─────┴──┐
                        │                   │             │scatter │
                        │                   │             └─────┬──┘
                        │                   │                   │
                        │                   │    ┌──────────────┘
                        │                   │    │
                        │           ┌───────┴────┴────┐
                        │           │ volonoifracture │
                        │           └───────┬─────────┘
                        │                   │
                        │                ┌──┴────┐
                        │                │ blast │
                        │                └──┬────┘
                        │                ┌──┴───┐
                        │                │ fuse │
                        │                └──┬───┘
                        │                ┌──┴────┐
                        │                │ clean │
                        │                └──┬────┘
                        │                   │
                        │                ┌──┴─────┐
                        │                │ remesh │
                        │                └──┬─────┘
                        │                   │
                        │               ┌───┴──────┐
                        │               │ mountain │
                        │               └───┬──────┘
                        │       ┌───────────┘
                        │       │
                   ┌────┴───────┴───┐
                   │ booleanfracture│
                   └──────┬─────────┘
                      ┌───┴───┐
                      │normal │   &lt;-- Start next demo section from here.
                      └───┬───┘
                          │
                    ┌─────┴───────┐
                    │  assemble   │
                    └─────┬───────┘
                          │
                 ┌────────┴─────────┐
                 │ attributewrangle │                float val = rand(@ptnum + chi("random_seed"));
                 └─┬───────────────┬┘                if(val&gt; ch("threshold")) i@group_selection = 1;
                   │               │
           ┌───────┴──┐          ┌─┴──────────┐
           │ selected │          │not_selected│
           └───────┬──┘          └──────┬─────┘
                   │                    │
            ┌──────┴─┐              ┌───┴────┐
            │ unpack │              │ unpack │
            └──────┬─┘              └────┬───┘
                   │                     │
    ┌──────────────┼─────────────────┐   │
    │  ┌───────────┴─┐               │   │
    │  │foreach_begin├───────┐       │   │
    │  └────┬────────┘       │       │   │
    │       │                │       │   │
    │       │           ┌────┴────┐  │   │
    │       │           │ scatter │  │   │
    │       │           └────┬────┘  │   │
    │       │                │       │   │
    │  ┌────┴──────────┐     │       │   │
    │  │voronoifracture├─────┘       │   │
    │  └───────┬───────┘             │   │
    │          │                     │   │
    │          │                     │   │
    │    ┌─────┴─────┐               │   │
    │    │foreach_end│               │   │
    │    └───────┬───┘               │   │
    └────────────┼───────────────────┘   │
                 │   ┌───────────────────┘
                 │   │
               ┌─┴───┴─┐
               │ Merge │
               └───────┘
</pre>


<div id="Voxyde - Fracture Setups-Recursive Fracturing-Selecting based on Proximity"><h3 id="Selecting based on Proximity" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Selecting based on Proximity">Selecting based on Proximity</a></h3></div>

<p>
For this demo, we can start from the same stage as the late few demos (at the original <code>Boolean Fracture</code> or the <code>Normal</code> node that follows if present).
</p>

<ul>
<li>
Copy and paste the <code>Line</code> node and the <code>Copy and Transform</code> that we setup for the art-directed fractures earlier (where we used a star formation of 5 lines radiating from the center of the Terrain). These can be free-floating for now.

</ul>
<p>
Now lets continue with building the rest of the network:
</p>

<ul>
<li>
Add a <code>Assemble</code> node after the <code>Boolean Fracture</code> or <code>Normal</code> if present:

<ul>
<li>
Don't forget to turn off <code>Create Name Attribute</code>

<li>
Turn on <code>Create Packed Primitives</code>

</ul>
<li>
Drop an <code>Attribute Wrangle</code> after the <code>Assemble</code>:

<ul>
<li>
Connect the <code>Copy and Tranform</code> that we copied an pasted earlier into input 2

<li>
We want to create an attribute the records the distance from the lines to the closest points representing the chunks.

<li>
In the <code>VEXpression</code> field:

<ul>
<li>
line 1 <code>float dist = xyzdist(1, @P);</code>:

<ul>
<li>
Measures and stored the distance ('dist' is an arbitrary name) from input 2 from each point's current position <code>P</code>

</ul>
<li>
line 2 <code>if(dist&gt;ch("threshold")) i@group_selection = 1;</code>:

<ul>
<li>
Create a "Threshold" slider by clicking the <code>Spare Parameter</code> icon (top-right above the VEXpression field), and if the value of the distance is greater than the "Threshold", the point gets included in a group called <code>selection</code>.

<li>
On creating my "Threshold" slide, I found I had to edit the <code>Range</code> in the <code>Edit Parameter Interface...</code> (cog-wheel), and set the fields to <code>0</code> to <code>10</code>.

</ul>
</ul>
</ul>
</ul>
<p>
To complete this setup, we can just duplicate the ending from the last demo example (from the two <code>Null</code> nodes down). We need to unpack and put through the <code>For-each</code> network, just as before. (The main take-away is the selection process.)
</p>

<p>
Don't forget that the <code>Split</code> node needs to be set to <code>Invert Selection</code> in our case again.
</p>

<div id="Voxyde - Fracture Setups-Recursive Fracturing-Selecting based on Proximity-Diagram - Network for Proximity Selection for Recursive Fracture"><h4 id="Diagram - Network for Proximity Selection for Recursive Fracture" class="header"><a href="#Voxyde - Fracture Setups-Recursive Fracturing-Selecting based on Proximity-Diagram - Network for Proximity Selection for Recursive Fracture">Diagram - Network for Proximity Selection for Recursive Fracture</a></h4></div>

<p>
This is the status of the network with the facility to make chunk selections based on proximity to 'lines' in this case:
</p>
<pre>

                   ┌──────────────┐
                   │ object_merge │
                   └──────┬───────┘
                        ┌─┴─────────────────┐
                        │               ┌───┴───┐
                        │               │ bound │
                        │               └───┬───┘
                        │                ┌──┴───┐
                        │                │ null │
                        │                └──┬───┴───────────────┐
                        │                   │          ┌────────┴────────┐
                        │                   │          │ vdbfrompolygons │
                        │                   │          └────────┬────────┘
                        │                   │                   │
                        │                   │             ┌─────┴──┐
                        │                   │             │scatter │
                        │                   │             └─────┬──┘
                        │                   │                   │
                        │                   │    ┌──────────────┘
                        │                   │    │
                        │           ┌───────┴────┴────┐
                        │           │ volonoifracture │
                        │           └───────┬─────────┘
                        │                   │
                        │                ┌──┴────┐
                        │                │ blast │
                        │                └──┬────┘
                        │                ┌──┴───┐
                        │                │ fuse │
                        │                └──┬───┘
                        │                ┌──┴────┐
                        │                │ clean │
                        │                └──┬────┘
                        │                   │
                        │                ┌──┴─────┐
                        │                │ remesh │
                        │                └──┬─────┘
                        │                   │
                        │               ┌───┴──────┐
                        │               │ mountain │
                        │               └───┬──────┘
                        │       ┌───────────┘
                        │       │
                   ┌────┴───────┴───┐
                   │ booleanfracture│
                   └──────┬─────────┘
                      ┌───┴───┐
                      │normal │   &lt;-- Start next demo section from here.
                      └───┬───┘
                          │                    ┌─────────┐
                          │                    │  line   │ 
                    ┌─────┴───────┐            └───┬─────┘ 
                    │  assemble   │        ┌───────┴───────────┐  
                    └─────┬───────┘        │ copyandtransform  │ 
                 ┌────────┴─────────┐      └───────┬───────────┘ 
                 │ attributewrangle │──────────────┘              float dist = xyzdist(1, @P);
                 └─┬───────────────┬┘                             if(dist&gt;ch("threshold")) i@group_selection = 1
                   │               │      
           ┌───────┴──┐          ┌─┴──────────┐
           │ selected │          │not_selected│
           └───────┬──┘          └──────┬─────┘
                   │                    │
            ┌──────┴─┐              ┌───┴────┐
            │ unpack │              │ unpack │
            └──────┬─┘              └────┬───┘
                   │                     │
    ┌──────────────┼─────────────────┐   │
    │  ┌───────────┴─┐               │   │
    │  │foreach_begin├───────┐       │   │
    │  └────┬────────┘       │       │   │
    │       │                │       │   │
    │       │           ┌────┴────┐  │   │
    │       │           │ scatter │  │   │
    │       │           └────┬────┘  │   │
    │       │                │       │   │
    │  ┌────┴──────────┐     │       │   │
    │  │voronoifracture├─────┘       │   │
    │  └───────┬───────┘             │   │
    │          │                     │   │
    │          │                     │   │
    │    ┌─────┴─────┐               │   │
    │    │foreach_end│               │   │
    │    └───────┬───┘               │   │
    └────────────┼───────────────────┘   │
                 │   ┌───────────────────┘
                 │   │
               ┌─┴───┴─┐
               │ Merge │
               └───────┘
</pre>


<div id="Voxyde - Fracture Setups-Chipping"><h2 id="Chipping" class="header"><a href="#Voxyde - Fracture Setups-Chipping">Chipping</a></h2></div>
<div id="Voxyde - Fracture Setups-Chipping-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4048s|YouTube - Chipping]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4048s|YouTube - Chipping]]" class="header"><a href="#Voxyde - Fracture Setups-Chipping-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4048s|YouTube - Chipping]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4048s">YouTube - Chipping</a></a></h4></div>

<p>
In this demo, we'll create edges from edgeloops that have a certain angle, we'll find points along these edges with more than one edge attached, color the edges, and use the color to drive the creation of points. Spheres will be placed at these scatter points, 'booleaned' together (union) and boolean fractured from the chunks.
</p>

<div id="Voxyde - Fracture Setups-Chipping-Corner Chipping - Demo"><h3 id="Corner Chipping - Demo" class="header"><a href="#Voxyde - Fracture Setups-Chipping-Corner Chipping - Demo">Corner Chipping - Demo</a></h3></div>

<p>
Again, let's start with the base network (and we'll continue from the <code>Boolean Fracture</code> or the <code>Normal</code> if there is one. (In this part of the demo, the tutorial chooses to use an <code>Object Merge</code> rather than an extended noodle. You just paste or type the path to the end of the network into the <code>Object 1</code> field.
</p>

<ul>
<li>
Start with a <code>For-each Named Primitive</code>:

<ul>
<li>
On the <code>foreach_end</code> node:

<ul>
<li>
Set a <code>Single Pass</code> selection to preview our work for now. (A single chunk.)

</ul>
</ul>
<li>
We want to look through all the edges of the chunk next:

<ul>
<li>
Within the 'Foreach' block, add a forked <code>Group</code> node:

<ul>
<li>
Set the <code>Group Name</code> to <code>edges</code>

<li>
<code>Group Type</code> to <code>Edges</code> in the dropdown menu.

<li>
Disable <code>Base Group</code>

<li>
Activate the <code>Include by Edges</code> checkbox:

<ul>
<li>
Turn on <code>Min Edge Angle</code>:

<ul>
<li>
Increase the angle slider until we see just the harshest angled edges are selected in the Viewport.

<li>
Something around 50º was used in the tutorial demo.

</ul>
</ul>
</ul>
<li>
Convert these selected edges to curves:

<ul>
<li>
Drop a <code>Labs Edge Group to Curve</code> node (only available if installed along with Houdini):

<ul>
<li>
Select our <code>edges</code> group in the <code>Group</code> field.

</ul>
</ul>
<li>
Let's select only the 'corner' points by looking for points with multiple primitives attached to them (more than two edges connected to them):

<ul>
<li>
Add a <code>Resample</code> node:

<ul>
<li>
Reduce the <code>Edge Length</code> to something like 0.03

</ul>
<li>
Add a <code>Fuse</code> to make sure all the vertex/points are connected (the <code>Resample</code> breaks the edges apart).

<li>
To actually isolate these candidates, we can use an <code>Attribute Wrangle</code>:

<ul>
<li>
There is a VEX function to find points with multiple primitives:

<ul>
<li>
<code>pointprims(&lt;input_slot_numb&gt;, &lt;point_number_ptnum&gt;)</code> 

<li>
This returns an array, but we only want the number of items in a return array for each point:

<ul>
<li>
line 1 <code>int primcount = len(pointprims(0, @ptnum));</code>

<li>
line 2 (DOES WORK) <code>@Cd = primcount&gt;1;</code>

<li>
Alternative line 1 <code>if (primcount&gt;1){@Cd = 1;} else {@Cd = 0;}</code>

</ul>
</ul>
</ul>
<li>
The points with multiple edges should be highlighted subtly in the Viewport.

<li>
Add an <code>Attribute Blur</code> node:

<ul>
<li>
Set <code>Attribute</code> to be <code>Cd</code>

<li>
Increase the <code>Blurring Iterations</code> to 13

<li>
Adjust the <code>Step Size</code> (to 0.7)

<li>
Un-check the <code>Pin Border Points</code> ("since this is a curve")

</ul>
</ul>
<li>
Drop a <code>Scatter</code> node:

<ul>
<li>
Switch on the <code>Density Attribute</code>, and change to reference the <code>Cd</code> attribute.

<li>
Disable <code>Relax Iterations</code>

<li>
Set the <code>Force Total Count</code> to 28

</ul>
</ul>
<li>
Next we want to scatter some geometry (as cutters) along these points:

<ul>
<li>
Drop a free-floating <code>Sphere</code>:

<ul>
<li>
Set to <code>Polygon</code>

</ul>
<li>
Feed this into a new <code>Copy to Points</code> node (input 1):

<ul>
<li>
Plugin in the <code>Scatter</code> to input 2

</ul>
<li>
Between the <code>Copy to Points</code> and the <code>Boolean Fracture</code>:

<ul>
<li>
Add a <code>Boolean Union</code> node to fuse all the close spheres together into single geometry entities:

<ul>
<li>
The default settings should be good for this purpose.

<li>
Plug the <code>Copy to Point</code> output to BOTH inputs on the <code>Boolean Union</code>

</ul>
</ul>
<li>
Template the chunk (on the <code>foreach_end</code> node)

<li>
Add a <code>Boolean Fracture</code> node after the <code>Copy to Points</code> node:

<ul>
<li>
Input 1 from the <code>foreach_begin</code> node

<li>
Input 2 from the <code>Copy to Points</code> node.

<li>
Remember to account for the <code>Name Attribute</code>:

<ul>
<li>
<code>Name Attribute</code> to <code>Append</code> (not overwrite)

<li>
<code>Piece Prefix</code> to something logical - in our case we used <code>-</code>

</ul>
<li>
Set the <code>Boolean Settings</code> &gt; <code>Treat Cutting Geometry As</code>:

<ul>
<li>
to <code>Solid</code> (since the original item is a solid enclosed geometry.

</ul>
<li>
And plug this <code>Boolean Fracture</code> node into the <code>foreach_end</code> node (input 1).

</ul>
<li>
In the <code>foreach_end</code> node, disable the <code>Single Pass</code> checkbox to affect all the chunks:

<ul>
<li>
(This was really slow for my machine to catch up!!)

</ul>
</ul>
</ul>
<p>
Improving the chips with organic cutter shapes:
</p>

<ul>
<li>
Increase the <code>Frequency</code> on the <code>Sphere</code> to 4

<li>
Add a <code>Mountain</code> node after the <code>Sphere</code> to make the geometry more organic:

<ul>
<li>
Play with <code>Amplitude</code> and <code>Element Size</code> to get a nice shape.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Chipping-Corner Chipping - Demo-Diagram - Chipping"><h4 id="Diagram - Chipping" class="header"><a href="#Voxyde - Fracture Setups-Chipping-Corner Chipping - Demo-Diagram - Chipping">Diagram - Chipping</a></h4></div>
<pre>
   ┌──────────────┐
   │ object_merge │
   └──────┬───────┘
        ┌─┴─────────────────┐
        │               ┌───┴───┐
        │               │ bound │
        │               └───┬───┘
        │                ┌──┴───┐
        │                │ null │
        │                └──┬───┴───────────────┐
        │                   │          ┌────────┴────────┐
        │                   │          │ vdbfrompolygons │
        │                   │          └────────┬────────┘
        │                   │                   │
        │                   │             ┌─────┴──┐
        │                   │             │scatter │
        │                   │             └─────┬──┘
        │                   │                   │
        │                   │    ┌──────────────┘
        │                   │    │
        │           ┌───────┴────┴────┐
        │           │ volonoifracture │
        │           └───────┬─────────┘
        │                   │
        │                ┌──┴────┐
        │                │ blast │
        │                └──┬────┘
        │                ┌──┴───┐
        │                │ fuse │
        │                └──┬───┘
        │                ┌──┴────┐
        │                │ clean │
        │                └──┬────┘
        │                   │
        │                ┌──┴─────┐
        │                │ remesh │
        │                └──┬─────┘
        │                   │
        │               ┌───┴──────┐
        │               │ mountain │
        │               └───┬──────┘
        │       ┌───────────┘
        │       │
   ┌────┴───────┴───┐
   │ booleanfracture│
   └──────┬─────────┘
      ┌───┴───┐
      │normal │   &lt;-- Start next demo section from here.
      └───┬───┘
          │
          │
          │
   ┌──────┼──────────────────────────────────────────────────┐
   │   ┌──┴──────────┐                                       │
   │   │foreach_begin│                                       │
   │   └──┬──────┬───┘                                       │
   │      │      └────────────────────────────┐              │
   │      │                                   │              │
   │      │                            ┌──────┴───┐          │
   │      │                            │  group   │          │
   │      │                            └──────┬───┘          │
   │      │                                   │              │
   │      │                     ┌─────────────┴───────────┐  │
   │      │                     │ labs_edgegroup_to_curve │  │
   │      │                     └─────────────┬───────────┘  │
   │      │                                   │              │
   │      │                                   │              │
   │      │                             ┌─────┴────┐         │
   │      │                             │ resample │         │
   │      │                             └─────┬────┘         │
   │      │                                   │              │
   │      │                                   │              │
   │      │                             ┌─────┴───┐          │
   │      │                             │  fuse   │          │
   │      │                             └─────┬───┘          │
   │      │                                   │              │
   │      │        ┌────────┐       ┌─────────┴─────────┐    │
   │      │        │ sphere │       │  attributewrangle │    │ int primcount = len(pointprims(0, @ptnum));
   │      │        └───┬────┘       └─────────┬─────────┘    │ if (primcount&gt;1){@Cd = 1;} else {@Cd = 0;}
   │      │            │                      │              │
   │      │            │                      │              │
   │      │      ┌─────┴─────┐       ┌────────┴───────┐      │
   │      │      │  mountain │       │  attributeblur │      │
   │      │      └─────┬─────┘       └────────┬───────┘      │
   │      │            │                      │              │
   │      │            │                      │              │
   │      │            │                  ┌───┴───┐          │
   │      │            │                  │scatter│          │
   │      │            │                  └───┬───┘          │
   │      │            └────┐       ┌─────────┘              │
   │      │                 │       │                        │
   │      │               ┌─┴───────┴──┐                     │
   │      │               │copytopoints│                     │
   │      │               └────┬───────┘                     │
   │      │                    │                             │
   │      │               ┌────┴────┐                        │
   │      │               │ boolean │                        │
   │      │               └────┬────┘                        │
   │      │    ┌───────────────┘                             │
   │  ┌───┴────┴──────┐                                      │
   │  │booleanfracture│                                      │
   │  └───┬───────────┘                                      │
   │      │                                                  │
   │      │                                                  │
   │      │                                                  │
   │   ┌──┴────────┐                                         │
   │   │foreach_end│                                         │
   │   └──┬────────┘                                         │
   └─────────────────────────────────────────────────────────┘
          │
          │
      ┌───┴─────────┐
      │ explodeview │
      └─────────────┘
</pre>

<div id="Voxyde - Fracture Setups-Glass Boolean Fracture"><h2 id="Glass Boolean Fracture" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture">Glass Boolean Fracture</a></h2></div>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4549s|YouTube - Glass Boolean Fracture]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4549s|YouTube - Glass Boolean Fracture]]" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4549s|YouTube - Glass Boolean Fracture]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=4549s">YouTube - Glass Boolean Fracture</a></a></h4></div>

<p>
This next part starts with a fresh setup and network. We will be 'smashing' or breaking glass. This will be based on a grid.
</p>

<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Demo - Breaking Glass"><h3 id="Demo - Breaking Glass" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Demo - Breaking Glass">Demo - Breaking Glass</a></h3></div>

<p>
At the SOP level (in a <code>Geometry</code> node):
</p>
<ul>
<li>
Create a <code>Grid</code>:

<ul>
<li>
<code>Primitive Type</code> to <code>Polygon</code>

<li>
<code>Orientation</code> to <code>ZX Plane</code>

<li>
<code>Size</code> 10 x 10

<li>
<code>Rotate</code> to 90, 0, 0

<li>
<code>Rows</code> and <code>Columns</code> to 10 x 10

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Creating Initial Fracture Lines"><h3 id="Creating Initial Fracture Lines" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Creating Initial Fracture Lines">Creating Initial Fracture Lines</a></h3></div>

<p>
We need to create some lines focused on a central fracture point. We'll do this with 'lines':
</p>
<ul>
<li>
Drop a free-standing <code>Add</code> node:

<ul>
<li>
Set the <code>Number of Points</code> to <code>1</code>

<li>
Activate the checkbox to get the point fields (and this will give us <code>one</code> point - which is what we need).

</ul>
<li>
Add an <code>Attribute Wrangle</code> node:

<ul>
<li>
<code>Run Over</code> set to <code>Points</code>

<li>
VEXpression:

<ul>
<li>
<code>@N = set(0,1,0);</code>

<li>
This will set the normal for each point.

</ul>
</ul>
<li>
Add a <code>Copy and Transform</code> node:

<ul>
<li>
(FYI - Its name might be truncated to just 'copy' in the Network Editor)

<li>
Now to radiate, we need to rotate around the <code>z</code> axis:

<ul>
<li>
In the <code>Z</code> field of the <code>Rotate</code> parameter:

<ul>
<li>
<code>360/ch("ncy")</code>

<li>
You can construct this by <code>RMB</code> on the <code>Total Number</code> parameter label and choose <code>Copy Parameter</code>.

<li>
Enter <code>360/</code> in the <code>Z</code> field, the <code>RMB</code> and <code>Paste Relative References</code>

</ul>
</ul>
<li>
Increase the <code>Total Number</code> slider, and each new copy will be rotated to evenly fill 360 degrees of rotation:

<ul>
<li>
Set to <code>29</code>

</ul>
</ul>
<li>
Create a free-floating <code>Line</code> node:

<ul>
<li>
Set the <code>Direction</code> to 0, 0, 1

<li>
Adjust the <code>Length</code> to something like <code>8</code>

</ul>
<li>
Create a <code>Copy to Points</code> node:

<ul>
<li>
<code>Line</code> node to input 1

<li>
<code>Copy and Transform</code> to input 2

</ul>
</ul>
<p>
Now we want to randomize the rotation of the lines a bit:
</p>
<ul>
<li>
Create an <code>Attribute Randomize</code> node after the <code>Copy and Transform</code> node (not after the <code>Copy to Points</code> - they look similar at this stage):

<ul>
<li>
Set <code>Attribute Name</code> to <code>N</code> for normals

<li>
<code>Operation</code> to <code>Add Value</code>

<li>
Set the <code>Min Value</code> fields to -1, -1, 0, -1 (to ignore the <code>Z</code> axis)

<li>
Set the <code>Max Value</code> fields to 1, 1, 0, 1

<li>
Adjust the <code>Global Scale</code> to taste (0.12 should do it).

</ul>
</ul>
<p>
To prepare the <code>Line</code> output:
</p>
<ul>
<li>
Add a <code>Resample</code> node after the <code>Line</code> node:

<ul>
<li>
Activate the <code>Curve U Attribute</code> to add the 'length' attribute (zero to one) via the <code>curveu</code> attribute.

</ul>
</ul>
<p>
From here we can add noise to the lines (curves) by manipulating their points.
</p>
<ul>
<li>
Drop and <code>Attribute VOP</code> node after the <code>Copy to Points</code> node:

<ul>
<li>
Rename to <code>add_noise</code>:

<ul>
<li>
Inside:

<ul>
<li>
Create a <code>Turbulent Noise</code> from the INPUT's <code>P</code> output:

<ul>
<li>
Set to <code>3D Noise</code>

<li>
Promote all the inputs:

<ul>
<li>
Select the node, <code>RMB</code> &gt; <code>VEX/VOP Options</code> &gt; <code>Create Input Parameters</code>

</ul>
</ul>
<li>
Fork an <code>Add</code> node again from the INPUT's <code>P</code> output:

<ul>
<li>
Now connect the <code>noise</code> output from the <code>Turbulent Noise</code> node to the <code>Add</code> node's input 2

<li>
Connect the <code>sum</code> output from the <code>Add</code> to the OUTPUT node's <code>P</code> input.

</ul>
</ul>
<li>
To remove the noise from the <code>Z</code> direction of the curves:

<ul>
<li>
Drop a <code>Multiply</code> node between the <code>Turbulent Noise</code> and the <code>Add</code>:

<ul>
<li>
Promote the input to a <code>Constant</code>:

<ul>
<li>
Switch to <code>3 Floats (vector)</code>

<li>
Set the <code>3 Float Default</code> to <code>1, 1, 0</code>

</ul>
</ul>
</ul>
</ul>
</ul>
<li>
Return to the SOP level, and adjust the parameters on the <code>Attribute VOP</code> (<code>add_noise</code>):

<ul>
<li>
Switch to <code>Sparse Convolution Noise</code>

<li>
<code>Frequency</code> to 1.2

<li>
<code>Amplitude</code> to 0.6

<li>
<code>Roughness</code> to 0.34

</ul>
</ul>
<p>
The noise is distorting the central point where all the fractures join too much. To control this we'll use the <code>curveu</code> attribute.
</p>
<ul>
<li>
Jump back into the <code>add_noise</code> node and create a <code>Bind</code> node:

<ul>
<li>
<code>Name</code> to <code>curveu</code> attribute

</ul>
<li>
Double click the <code>amp</code> input on the <code>Turbulent Noise</code> node (and you should have an <code>amp</code> node appear):

<li>
After this amp node, add a <code>Multiply</code> node between the <code>amp</code> node and the <code>Turbulent Noise</code> node:

<ul>
<li>
Plug the <code>curveu</code> output from the <code>Bind</code> to the <code>Multilpy</code> node's input 2

</ul>
<li>
To give more control, drop a <code>Ramp Parameter</code> node after the <code>Bind</code>:

<ul>
<li>
Set <code>Ramp Type</code> to <code>Spline Ramp (float)</code>

<li>
Set <code>Name</code> to <code>ramp_curveu</code>

<li>
Set <code>Label</code> to <code>ramp_curveu</code>

<li>
Move up to the SOP level and adjust the <code>Ramp</code>

<ul>
<li>
make the ramp curved like a right-wards arc (so more distortion with noise as the curve moves out) 

</ul>
</ul>
</ul>
<p>
The next requirement is to adjust the noise per line.
</p>
<ul>
<li>
We can assign attributes to the points:

<ul>
<li>
Add an <code>Attribute Wrangle</code> node AFTER the <code>Attribute Randomize</code> (after the <code>Copy and Transform</code>) node:

<ul>
<li>
Rename to <code>add_id</code>

<li>
Set the VEXpression as follows:

<ul>
<li>
<code>@id = @ptnum;</code>

</ul>
</ul>
</ul>
<li>
While viewing the <code>add_noise</code>, we can activate the <code>id</code> attribute in the <code>i</code> panel:

<ul>
<li>
The lines should preview with different colors (mess with the visualizer icon if not).

</ul>
<li>
Back inside the <code>add_noise</code> VOP, double-click on the <code>offset</code> input of the <code>Turbulent Noise</code> node:

<ul>
<li>
This will add an <code>offset</code> node.

<li>
Between this new <code>offset</code> node and the <code>Turbulent Noise</code> node, add an <code>Add</code> node.

</ul>
<li>
Then create a <code>Float to Vector</code> node from the <code>id</code> output of the INPUT node:

<ul>
<li>
This should be connected via the <code>fval1</code> input

<li>
Connect the <code>vec</code> output to the input 2 slot on the <code>Add</code> after the <code>offset</code>

</ul>
<li>
To accentuate the difference between the lines and the <code>id</code>:

<ul>
<li>
Drop a <code>Multiply Constant</code> between the INPUT (where the Id is taken from) and the <code>Float to Vector</code> nodes:

<ul>
<li>
Adjust the <code>Multiplier</code> to about 3

</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Extrude"><h3 id="Extrude" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Extrude">Extrude</a></h3></div>

<p>
Next we make the lines template into an extruded 'cutter' element.
</p>
<ul>
<li>
Add a <code>PolyExtrude</code> node after the <code>add_noise</code> node:

<ul>
<li>
On the <code>Extrusion</code> tab:

<ul>
<li>
Check on the <code>Transfrom Extruded Front</code> option

<li>
<code>Transform Space</code> to <code>Global</code>

<li>
Set the <code>Translate</code> fields to <code>0, 0, -0.9</code>

</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-The Boolean"><h3 id="The Boolean" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-The Boolean">The Boolean</a></h3></div>

<ul>
<li>
Drop a <code>Boolean Fracture</code> (with the original <code>Grid</code> as input 1):

<ul>
<li>
Set the <code>Treat Geometry As</code> option to <code>Surface</code> (<em>IMPORTANT</em>: it will not work without this for the flat grid)

<li>
Plug the <code>PolyExtrude</code> into input 2

<li>
Add an <code>Exploded View</code> node to see the progress thus far.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Give Glass Thickness"><h3 id="Give Glass Thickness" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Give Glass Thickness">Give Glass Thickness</a></h3></div>

<p>
Add a <code>PolyExtrude</code> after the <code>Boolean Fracture</code> to give some thickness to the glass shards.
</p>
<ul>
<li>
Check on the <code>Transfrom Extruded Front</code> option

<li>
<code>Transform Space</code> to <code>Global</code>

<li>
Set the <code>Translate</code> fields to <code>0, 0, 0.1</code>

<li>
Check 'On' the <code>Output Back</code> option.

</ul>
<p>
At this stage, the <code>name</code> attribute should come through, and if you check it on in the Visualizer icon in the Viewport, the shards should be colored to indicate the different names.
</p>

<p>
If you get some really small slivers at the center, you can adjust the ramp in the <code>add_noise</code> (to be zero on the left of the curve).
</p>

<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Recursive Fractures on the Shards"><h3 id="Recursive Fractures on the Shards" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Recursive Fractures on the Shards">Recursive Fractures on the Shards</a></h3></div>

<p>
We'll work on a shard-by-shard approach next.
</p>

<ul>
<li>
Drop a <code>For-each Named Primitive</code>:

<ul>
<li>
To set up the fracture, we can turn on <code>Single Pass</code> to see only one chunk as we work. 

</ul>
</ul>
<p>
To make the 'cutter' surfaces, we'll spawn concentric circles from a point.
</p>
<ul>
<li>
Create a free-floating <code>Add</code> node:

<ul>
<li>
Check 'On' to activate a single point at <code>0, 0, 0</code>

</ul>
<li>
Add a <code>Point Replicate</code>:

<ul>
<li>
<code>Points per Point</code> to 3

<li>
On the <code>Shape</code> tab:

<ul>
<li>
<code>Uniform Scale</code> to zero (so they all share the central location)

</ul>
</ul>
<li>
Add an <code>Attribute Wrangle</code> to add a <code>pscale</code> attribute to each point (to drive the size of the derived geometry):

<ul>
<li>
Rename to <code>set_pscale</code>

<li>
VEXpression:

<ul>
<li>
<code>@pscale = @ptnum + 1;</code>

<li>
Now each point has a pscale attribute, each ascends from the last:

<ul>
<li>
point 0 + 1, point 1 + 1 and point 2 + 1

<li>
1, 2, 3

</ul>
</ul>
</ul>
<li>
Drop a free-floating <code>Tube (Polygons)</code> node:

<ul>
<li>
<code>Orientation</code> to <code>Z Axis</code>

<li>
<code>Radius</code> to 1.4 x 1.4

<li>
<code>Height</code> to 0.55

<li>
<code>Columns</code> to 50

</ul>
<li>
Add a <code>Copy to Points</code> with the <code>Tube</code> as input 1:

<ul>
<li>
Plug the <code>Attribute Wrangle</code> into input 2

</ul>
</ul>
<p>
The <code>pscale</code> of the origin points is passed onto the tubes, and they appear as concentric rings.
</p>

<p>
Let's distort these 'cutter' rings:
</p>
<ul>
<li>
Add a <code>Remesh</code> node after the <code>Copy to Points</code> node (default settings)

<li>
Add a <code>Mountian</code> node after the <code>Remesh</code> node:

<ul>
<li>
Turn off <code>Noise Along Vector</code>

<li>
<code>Range Values</code> to <code>Zero Centered</code>

<li>
<code>Noise Pattern</code> &gt; <code>Noise Type</code> to <code>Simplex</code>

<li>
Split the <code>Amplitude</code> field (by clicking the <code>XYZ</code> icon):

<ul>
<li>
Set the <code>Amplitude</code> slider to 0.5

<li>
Set the <code>Amplitude Scale</code> fields to 1, 1, 0 (now distortion on the <code>Z</code> axis)

</ul>
<li>
<code>Element Size</code> to <code>1.34</code>

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-To Randomize the noise between the three concentric rings"><h3 id="To Randomize the noise between the three concentric rings" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-To Randomize the noise between the three concentric rings">To Randomize the noise between the three concentric rings</a></h3></div>

<ul>
<li>
Copy the <code>add_id</code> wrangler node from earlier (after the point creation):

<ul>
<li>
Paste the <code>add_id</code> just before the points get plugged into the <code>Copy to Points</code> node (after the <code>set_pscale</code> node):

<ul>
<li>
(It will be auto-renamed to <code>add_id1</code>)

</ul>
</ul>
<li>
On the <code>Mountain</code> node:

<ul>
<li>
In the <code>Noise Pattern</code> section check 'On' the <code>VEXpression</code> checkbox:

<ul>
<li>
In the <code>VEXpression</code> window:

<ul>
<li>
<code>offset = @id * 3:</code>

</ul>
</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Randomize the sizes of the 'Cutter' rings"><h3 id="Randomize the sizes of the 'Cutter' rings" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Randomize the sizes of the 'Cutter' rings">Randomize the sizes of the 'Cutter' rings</a></h3></div>

<ul>
<li>
After the <code>set_pscale</code> (attribute wrangle) add an <code>Attribute Randomize</code> node:

<ul>
<li>
<code>Attribute Scale</code> to <code>pscale</code>

<li>
<code>Operation</code> to <code>Add Value</code>

<li>
<code>Global Scale</code> to 0.3

<li>
On the <code>Distribution</code> tab:

<ul>
<li>
<code>Dimensions</code> to 1 

</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Boolean Fracture-Add cutters to For-each loop"><h3 id="Add cutters to For-each loop" class="header"><a href="#Voxyde - Fracture Setups-Glass Boolean Fracture-Add cutters to For-each loop">Add cutters to For-each loop</a></h3></div>

<ul>
<li>
Inside the For-each loop:

<ul>
<li>
Add a <code>Boolean Fracture</code> node:

<ul>
<li>
<code>Name Attribute</code> to <code>Append</code> on the dropdown:

<ul>
<li>
<code>Piece Prefix</code> to <code>-</code>

<li>
If this stage is skipped the surfaces look messed up.

</ul>
<li>
<code>foreach_begin</code> into input 1

<li>
Our <code>Mountain</code> node from our cutter setup into input 2

<li>
<code>Treat Geometry As</code> to <code>Surface</code>

</ul>
</ul>
<li>
Connect an <code>Exploded View</code> to the <code>Boolean Fracture</code> to see the result.

</ul>
<p>
On the <code>Boolean Fracture</code> un-check the <code>Single Pass</code> to see all shards with the treatment.
</p>

<p>
<span id="Voxyde - Fracture Setups-Glass Boolean Fracture-Add cutters to For-each loop-NOTE"></span><strong id="NOTE">NOTE</strong>: <em>If the 'Name Attribute'on the 'Boolean Fracture' is set to 'Overwrite' the surfaces will seem broken. To fix, either set the correct 'name' treatement, or just add an 'Assemble' node with 'Create Name Attribute' checked to create a brand-new 'name' attribute across all pieces.</em>
</p>


<p>
At this stage, we have centrally fractured lines radiating out of a point, and we have concentric rings of fracturing. However, it doesn't look natural - we need more randomized characteristics. The next section builds on this...
</p>


<div id="Voxyde - Fracture Setups-Compiled Block"><h2 id="Compiled Block" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block">Compiled Block</a></h2></div>
<div id="Voxyde - Fracture Setups-Compiled Block-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5421s|YouTube - Compiled Block]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5421s|YouTube - Compiled Block]]" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5421s|YouTube - Compiled Block]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5421s">YouTube - Compiled Block</a></a></h4></div>

<p>
Speeding up the process and adding more variation with a <span id="Voxyde - Fracture Setups-Compiled Block-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5421s|YouTube - Compiled Block]]-Compiled Block"></span><strong id="Compiled Block">Compiled Block</strong>.
</p>

<table>
<tr>
<td>
Remove the extrude on the Grid for now. (It's probably just before the 'for' loop.)
</td>
</tr>
</table>

<div id="Voxyde - Fracture Setups-Compiled Block-Block Begin"><h3 id="Block Begin" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-Block Begin">Block Begin</a></h3></div>

<p>
We need the cutter logic to be run for each run of the <code>for each</code> loop to be able to randomize the generation of cutter features to get truly organic shatter patterns.
</p>

<p>
The <code>Add</code> node that generated the 3 points doesn't need to be iterated over, so that can stay outside of the foreach loop, but all the other nodes should be part of the iteration.
</p>

<ul>
<li>
Create a <code>Block Begin</code> node as the second node (after the point-generating <code>Add</code> node):

<ul>
<li>
<code>Method</code> to <code>Fetch Input</code> (to always start from the <code>Add</code> node)

<li>
The <code>Block Path</code> needs to point to the <code>foreach_end</code> node:

<ul>
<li>
You can drag the node from the <code>Network Editor</code> into the field to harvest the path:

<ul>
<li>
<code>../foreach_end7</code> or whatever it is in your scene.

</ul>
</ul>
<li>
Now all the nodes between the <code>Block Begin</code> node (inclusive) and the <code>foreach_end</code> node will be included and encompassed within the visual group or area of the For Loop. It's all encapsulated with the foreach loop.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Compiled Block-Block Begin Compile"><h3 id="Block Begin Compile" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-Block Begin Compile">Block Begin Compile</a></h3></div>

<ul>
<li>
<em>Before</em> the <code>foreach_begin</code> node, drop a <code>Block Begin Compile</code> node.

<li>
<em>After</em> the <code>foreach_end</code> node, drop a <code>Block End Compile</code> node.

</ul>
<p>
There will be another graphic representation of the whole 'foreach' loop and the Block Compile nodes being grouped.
</p>

<ul>
<li>
To make this all work:

<ul>
<li>
In the <code>Block Begin Compile</code> node:

<ul>
<li>
<code>Block Path</code> field should 'point' to the corresponding <code>Block End Compile</code> node:

<ul>
<li>
Drag the end node onto this field:

<ul>
<li>
<code>../compile_end2</code> or whatever it is in your scene.

</ul>
</ul>
</ul>
</ul>
<li>
On the <code>foreach_end</code> node:

<ul>
<li>
Check 'On' the <code>Multithread when Compiled</code> checkbox

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Compiled Block-Capturing the current iteration to use as a random seed"><h3 id="Capturing the current iteration to use as a random seed" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-Capturing the current iteration to use as a random seed">Capturing the current iteration to use as a random seed</a></h3></div>

<p>
To access the iteration number through the loop, select the <code>foreach_begin</code> node:
</p>
<ul>
<li>
Click on the <code>Create Meta Import Node</code> on the parameter panel:

<ul>
<li>
This will create a <code>foreach_begin_metadata</code> node ('metadata'):

<ul>
<li>
This node keeps track of the iteration number.

<li>
We can reference this node within our parameters throughout the network.

<li>
If you look at the base of this 'metadata' node's parameter panel, you'll see 3 variables or attributes:

<ul>
<li>
<code>iteration</code>

<li>
<code>numiterations</code>

<li>
<code>value</code>

<li>
<code>ivalue</code>

</ul>
<li>
We'll be accessing the <code>iteration</code> attribute.

</ul>
</ul>
</ul>
<p>
In principle, to reference the <code>metadata</code> node on another node, we have to add it to the parameter interface.
</p>
<ul>
<li>
For a node to use this metadata, it has to be included via the 'parameter interface':

<ul>
<li>
Click on the 'cog wheel' icon on a parameter panel:

<ul>
<li>
Select the <code>Add Spare Input</code> option.

<li>
This will add a field at the base of the parameters.

<li>
In the field we need to add the path to the 'metadata' node:

<ul>
<li>
Drag the node into the field to get the path:

<li>
or

<li>
<code>../foreach_begin7_metadata1</code> or whatever the correct path is for your node.

<li>
You'll see a dotted connection line from the metadata node to the node it was added to.

</ul>
</ul>
</ul>
</ul>
<p>
I had to disable and enable a node to get this to work sometimes. (Oh, <em>and make sure you've added a 'Add Spare Input' too!)</em>
</p>

<p>
Let's implement this on our <code>Point Replicate</code> node:
</p>
<ul>
<li>
Cog-wheel and select <code>Add Spare Input</code>:

<ul>
<li>
Enter the path to our <code>foreach_begin_metadata</code> node

</ul>
<li>
In the <code>Points per Point</code> field:

<ul>
<li>
<code>detail(-1, "iteration", 0)</code>

<li>
<em>THE NEXT LINE DOES NOT WORK ON MY MAC SETUP - THIS WAS ALSO TRIED WITH THE TUTOR'S EXAMPLE HIP FILE - DOESN'T UPDATE TO REFECT THE ITERATION</em>

<li>
NOT TRUE ON MY MAC SESSION: This will now evaluate to the piece or loop number (and you can go through the <code>Single Pass</code> slider on the <code>foreach_end</code> node to see this in action).

</ul>
</ul>
<p>
Let's edit that to not just have the iteration number, but to use that number as a random seed:
</p>
<ul>
<li>
Back in the <code>Point Replicate</code> node's <code>Points per Point</code> field, edit our expression to:

<ul>
<li>
<code>rand(detail(-1, "iteration", 0))</code>

</ul>
<li>
This would generate random numbers, but let's confine between 2 and 5. Edit again to:

<ul>
<li>
<code>fit01(rand(detail(-1, "iteration", 0)),1, 5)</code>

</ul>
<li>
And to ensure we get an integer (as this is the point generation amount number):

<ul>
<li>
<code>round(fit01(rand(detail(-1, "iteration", 0)),1, 5))</code>

</ul>
<li>
<em>EXTRA PARAMETER</em>: Add this to give more options to look through if you want to choose a good layout:

<ul>
<li>
In this updated expression, you can change the 50 value to anything to get different configurations (even float values): 

<ul>
<li>
<code>round(fit01(rand(detail(-1, "iteration", 0)+50),1, 5))</code>

</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-Compiled Block-Editing the 'pscale' to be limited in value"><h3 id="Editing the 'pscale' to be limited in value" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-Editing the 'pscale' to be limited in value">Editing the 'pscale' to be limited in value</a></h3></div>

<ul>
<li>
Go to the <code>set_pscale</code> node (<code>Attribute Wrangle</code>):

<ul>
<li>
Adjust the expression to:

<ul>
<li>
<code>@pcale = (@ptnum+1) * ch("pscale_mult");</code>

<li>
This creates a slider called <code>Pscale Mult</code> and multiplies the result.

<li>
Set the slider to 0.65

</ul>
</ul>
<li>
Now the shards are only shattered by concentric circles in closer proximity to the center.

</ul>
<div id="Voxyde - Fracture Setups-Compiled Block-Using the 'metadata' iteration count to change the Attribute Randomize"><h3 id="Using the 'metadata' iteration count to change the Attribute Randomize" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-Using the 'metadata' iteration count to change the Attribute Randomize">Using the 'metadata' iteration count to change the Attribute Randomize</a></h3></div>

<ul>
<li>
On the <code>Attribute Randomize</code> node:

<ul>
<li>
Cog-wheel and select <code>Add Spare Input</code>:

<ul>
<li>
Enter the path to our <code>foreach_begin_metadata</code> node

</ul>
</ul>
<li>
Go to the <code>Options</code> tab:

<ul>
<li>
In the <code>Global Seed</code> field:

<ul>
<li>
<code>detail(-1, "iteration", 0)</code>

</ul>
</ul>
</ul>
<p>
This gives the concentric breaks a real random location on each shard.
</p>

<div id="Voxyde - Fracture Setups-Compiled Block-Repeat of 'metadata' iteration count to change the 'Mountain' noise"><h3 id="Repeat of 'metadata' iteration count to change the 'Mountain' noise" class="header"><a href="#Voxyde - Fracture Setups-Compiled Block-Repeat of 'metadata' iteration count to change the 'Mountain' noise">Repeat of 'metadata' iteration count to change the 'Mountain' noise</a></h3></div>

<ul>
<li>
On the <code>Mountain</code> node, edit the <code>Offset</code> parameter:

<ul>
<li>
Don't forget to <code>Add Spare Input</code> from the Cog-wheel icon!

<li>
<code>detail(-1, "iteration", 0)</code>

<li>
Disable the previous expression by un-checking the <code>Use VEXpression</code> checkbox.

</ul>
</ul>
 
<p>
Now the actual cutter route will be less consistent and more natural.
</p>

<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture"><h2 id="Glass Voronoi Fracture" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture">Glass Voronoi Fracture</a></h2></div>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5909s|YouTube - Glass Voronoi Fracture]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5909s|YouTube - Glass Voronoi Fracture]]" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5909s|YouTube - Glass Voronoi Fracture]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=5909s">YouTube - Glass Voronoi Fracture</a></a></h4></div>

<p>
Next we'll look at using Voronoi Fracturing for glass.
</p>

<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Demo - Voronoi Glass Fracture"><h3 id="Demo - Voronoi Glass Fracture" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Demo - Voronoi Glass Fracture">Demo - Voronoi Glass Fracture</a></h3></div>

<p>
At the SOP level (in a <code>Geometry</code> node):
</p>
<ul>
<li>
Create a <code>Grid</code>:

<ul>
<li>
<code>Primitive Type</code> to <code>Polygon</code>

<li>
<code>Orientation</code> to <code>ZX Plane</code>

<li>
<code>Size</code> 10 x 10

<li>
<code>Rotate</code> to 90, 0, 0

<li>
<code>Rows</code> and <code>Columns</code> to 50 x 50

</ul>
</ul>
<p>
Place a <code>Null</code> to keep things organized.
</p>
<ul>
<li>
From the <code>Null</code>:

<ul>
<li>
Add a <code>Scatter</code> node:

<ul>
<li>
<code>Relax Iterations</code> OFF

<li>
<code>Force Total Count</code> to 90

</ul>
</ul>
<li>
Fork a <code>Voronoi Fracture</code> from the <code>Null</code>:

<ul>
<li>
Plug the <code>Scatter</code> node into input 2

<li>
The Viewport might be glitchy:

<ul>
<li>
Turn off the <code>Create Interior Surfaces</code> checkbox on the <code>Voronoi Fracture</code> parameters.

<li>
Glitch should be gone.

<li>
For color cells in the Viewport, switch on the 'name' attribute in the <code>i</code> panel for the <code>Voronoi Fracture</code> node

</ul>
</ul>
</ul>
<p>
As usual, drop an <code>Exploded View</code> to see how it's all working out.
</p>

<p>
We'll use the <code>Rest Position</code> nodes again to record the attributes before we add noise to restore when we've completed the distortion:
</p>
<ul>
<li>
Add a <code>Rest Position</code> node <em>BEFORE</em> the <code>Null</code> node:

<ul>
<li>
<code>Mode</code> to <code>Store Rest</code>

</ul>
<li>
Add another <code>Rest Position</code> after the <code>Voronoi Fracture</code> node.

<ul>
<li>
<code>Mode</code> to <code>Swap Rest</code>

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Illustrating The Function of Rest Postion"><h3 id="Illustrating The Function of Rest Postion" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Illustrating The Function of Rest Postion">Illustrating The Function of Rest Postion</a></h3></div>

<p>
As a temporary aside:
</p>

<ul>
<li>
After the first <code>Rest Postion</code> node:

<ul>
<li>
Add a <code>Transform</code> node:

<ul>
<li>
<code>Scale</code> to 1, 3, 1

</ul>
</ul>
<li>
Look again at the second <code>Rest Postion</code> and see that the transforms are restored to the 'rest position', causing the Voronoi patterns to be squeezed into the original aspect of the grid (before the scaling).

</ul>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Back to the build"><h3 id="Back to the build" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Back to the build">Back to the build</a></h3></div>

<p>
With the function of the <code>Rest Position</code> in mind, we need to somehow radially stretch the grid's points to get a glass shard format going.
</p>

<p>
After the first <code>Rest Position</code>:
</p>
<ul>
<li>
Add an <code>Attribute VOP</code> node:

<ul>
<li>
Rename to <code>stretch</code>:

<ul>
<li>
Inside:

<ul>
<li>
From the <code>P</code> output of the INPUT node:

<ul>
<li>
Drop a <code>Subtract</code> node:

<ul>
<li>
Promote input 2 to a <code>Constant</code>.

<li>
Set the <code>Constant Type</code> to <code>3 Floats (vector)</code>

<li>
If you plug the <code>diff</code> output into the OUTPUT's <code>N</code> input, you'll see the normals all pointing away from the center point.

<li>
You can unplug this from the <code>N</code> input once you've seen the normals do their thing.

</ul>
<li>
Add a <code>Normalize</code> node after the <code>Subract</code>

</ul>
<li>
From the <code>P</code> output of the INPUT node:

<ul>
<li>
Fork an <code>Add</code> node:

<ul>
<li>
Plug the <code>nvec</code> output of the <code>Normalize</code> to the <code>Add</code> node's input 2

</ul>
<li>
Plug the <code>sum</code> from the <code>Add</code> node into the <code>P</code> input of the OUTPUT node.

</ul>
</ul>
</ul>
</ul>
</ul>
<p>
You should see the grid start to bloat from the center point outwards, with the greatest distortion of points nearer the center.
</p>

<ul>
<li>
Between the <code>Normalize</code> and the <code>Add</code> create a <code>Multiply</code> node:

<ul>
<li>
Promote the <code>input2</code>:

<ul>
<li>
Label as <code>Stretch</code>

</ul>
</ul>
</ul>
<p>
Now, from the SOP level, on the <code>stretch</code> ('Attribute VOP'), we have a slider to control the <code>Stretch</code> amount.
</p>

<ul>
<li>
Push the stretch to <code>5.6</code>

<li>
Look at the grid after the second <code>Rest Postion</code>. It should look like shards:

<ul>
<li>
There is an issue of too many shards in the center.

<li>
This is because when we stretch, there a huge polygon in the center, and there are multiple points scattered within.

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Back to the build-Diagram - Attribute VOP - Stretch"><h4 id="Diagram - Attribute VOP - Stretch" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Back to the build-Diagram - Attribute VOP - Stretch">Diagram - Attribute VOP - Stretch</a></h4></div>

<pre>
                                                                           ┌───────────────┐          ┌───────────────────┐
                                                                           │      add      │          │geometryvopoutput1 │
                                                                           │               │          │                   │
                       ┌───────────────────────────────────────────────────┤input1     sum ├──────────│P                  │
                       │                                             ┌─────┤input2         │          │                   │
                       │                                             │     └───────────────┘          │                   │
                       │                                             │                                │                   │
                       │                                             │                                │                   │
                       │                                             │                                └───────────────────┘
                       │                                             │
                       │                                             └──────────────────────────────────────┐
                       │                                                                                    │
                       │                                                                                    │
  ┌──────────────────┐ │                 ┌──────────────┐       ┌─────────────┐     ┌──────────────────┐    │
  │geometryvopglobal1│ │                 │   subtract   │       │  normalize  │     │     multiply     │    │
  │                  │ │                 │              │       │             │     │                  │    │
  │                P ├─┴─────────────────┤input1   diff ├───────┤ vec    nvec ├─────┤input1    product ├────┘
  │                  │                 ┌─┤input2        │       │             │     │                  │
  │                  │     ┌────────┐  │ └──────────────┘       └─────────────┘     │input2            │
  │                  │     │constant│  │                                            │(promoted)        │
  │                  │     │0,0,0   ├──┘                                            └──────────────────┘
  │                  │     └────────┘
  │                  │
  │                  │
  │                  │
  │                  │
  │                  │
  │                  │
  │                  │
  └──────────────────┘
</pre>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-What's happening in the VOP?"><h3 id="What's happening in the VOP?" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-What's happening in the VOP?">What's happening in the VOP?</a></h3></div>

<ul>
<li>
The position of each point is having the <em>constant</em> vector (0,0,0) <em>subtracted</em> from it:

<ul>
<li>
Result - their position becomes a vector pointing away from the <em>constant</em> vector (center in our case)

</ul>
<li>
This vector is <em>normalized</em>.

<li>
The vector is then (user) <em>multiplied</em> ('more' or 'less' vector magnitude).

<li>
The resulting components of the vector are <em>added</em> back onto the components of the current position coordinates of each point:

<ul>
<li>
Result - each point moves in the direction and magnitude of the vector value.

</ul>
</ul>
<p>
<span id="Voxyde - Fracture Setups-Glass Voronoi Fracture-What's happening in the VOP?-NOTE"></span><strong id="NOTE">NOTE</strong>: Temporarily plugging into the <code>N</code> (normals) slot allows a visual assessment of the value.
</p>

<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Controlling the inner stretch in VOPs"><h3 id="Controlling the inner stretch in VOPs" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Controlling the inner stretch in VOPs">Controlling the inner stretch in VOPs</a></h3></div>

<ul>
<li>
Back inside the <code>stretch</code> ('Attribute VOP'):

<ul>
<li>
Fork a <code>Distance</code> node from the <code>P</code> output of the INPUT node:

<ul>
<li>
Plug the <code>Constant</code> node directly into input 2 of the Distance node (center)

<li>
Temporarily disable (<code>Q</code>) the <code>Add</code> node to see the undistorted <code>Grid</code> if you are viewing before the second <code>Rest Position</code>.

<li>
(Switch off the <code>Visualizer</code> icon in the Viewport if you have the shards colored by the 'name' attribute.)

<li>
If we plug the Distance output into the <code>Cd</code> of the OUTPUT node, we'll see what's happening as a grayscale radial ramp:

<ul>
<li>
To control this ramp of values, add a <code>Fit Range</code> node after the <code>Distance</code> node:

<ul>
<li>
Set the <code>Source Max</code> to about 7 to grow the central effect.

</ul>
</ul>
<li>
Add a <code>Ramp Parameter</code> after the <code>Fit Range</code>:

<ul>
<li>
Set <code>Ramp Type</code> to <code>Spline Ramp (float)</code>

<li>
Go up to the SOP level, and on the <code>stretch</code> node, fix the ramp:

<ul>
<li>
Reset the <code>ramp</code> (<code>&lt;cntl&gt; MMB</code> on the <code>ramp</code> label)

<li>
A steep humpy shape seems best.

</ul>
<li>
Back inside the VOP:

<ul>
<li>
Plug the output from the <code>Ramp Parameter</code> to the existing <code>Multiply</code> (input 3)

</ul>
<li>
Cut the link to the <code>Cd</code> (<code>Y</code> key and drag)

<li>
Turn the <code>Add</code> back on.

</ul>
</ul>
<li>
Now we can adjust the ramp curve to control the expansion of all the points from the center and create a really smooth expansion.

<li>
To add even more control of the shards, promote the <code>Source Max</code> parameter on the <code>Fit Range</code>:

<ul>
<li>
<span id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Controlling the inner stretch in VOPs-NOTE"></span><strong id="NOTE">NOTE</strong>: I had to move the promoted <code>Source Max</code> slider to get it to register. (The slider is labeled <code>Maximum Value In Source Range</code>.)

<li>
Lower numbers here, make sharper shards.

<li>
Set to a value of <code>5</code> 

</ul>
<li>
We now have two controls to adjust the expansion:

<ul>
<li>
<code>Stretch</code>

<li>
<code>Source Max</code>

</ul>
</ul>
</ul>
<p>
Now add more scatter points:
</p>
<ul>
<li>
On the <code>Scatter</code> node:

<ul>
<li>
Push the <code>Force Total Count</code> to 250

</ul>
</ul>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Controlling the inner stretch in VOPs-Diagram - Attribute VOP - Stretch - More control"><h4 id="Diagram - Attribute VOP - Stretch - More control" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Controlling the inner stretch in VOPs-Diagram - Attribute VOP - Stretch - More control">Diagram - Attribute VOP - Stretch - More control</a></h4></div>

<pre>
                             ┌─────────────┐  ┌──────────────┐    ┌────────────┐
                             │   distance  │  │     fit      │    │    ramp    │
                             │             │  │              │    │            │
                        ┌────┤ p1     dist │  │  val  shift  │    │input  ramp ├────┐
                        │ ┌──┤ p2          │  │              │    │            │    │
                        │ │  │             │  │  srcmax      │    └────────────┘    │
                        │ │  └─────────────┘  └──────────────┘                      │
                        │ └─────────────┐                           ┌───────────────┘
                        │               │                           │            ┌───────────────┐          ┌───────────────────┐
                        │               │                           │            │      add      │          │geometryvopoutput1 │
                        │               │                           │            │               │          │                   │
                        │    ┌──────────┼───────────────────────────┼────────────┤input1     sum ├──────────│P                  │
                        │    │          │                           │      ┌─────┤input2         │          │                   │
                        │    │          │                           │      │     └───────────────┘          │                   │
                        │    │          │                           │      │                                │                   │
                        │    │          │                           │      │                                │                   │
                        │    │          │                           │      │                                └───────────────────┘
                        │    │          │                           │      │
                        │    │          │                           │      └──────────────────────────────────────┐
                        │    │          │                           └─────────────────┐                           │
                        │    │          │                                             │                           │
 ┌──────────────────┐   │    │          │      ┌──────────────┐       ┌─────────────┐ │   ┌──────────────────┐    │
 │geometryvopglobal1│   │    │          │      │   subtract   │       │  normalize  │ │   │     multiply     │    │
 │                  │   │    │          │      │              │       │             │ │   │                  │    │
 │                P ├───┴────┴──────────┼──────┤input1   diff ├───────┤ vec    nvec ├─┼───│input1    product │────┘
 │                  │                   │    ┌─┤input2        │       │             │ │   │                  │
 │                  │        ┌────────┐ │    │ └──────────────┘       └─────────────┘ │   │input2            │
 │                  │        │constant│ │    │                                        │   │(promoted)        │
 │                  │        │0,0,0   ├─┴────┘                                        │   │                  │
 │                  │        └────────┘                                               └───┤input3            │
 │                  │                                                                     └──────────────────┘
 │                  │
 │                  │
 │                  │
 │                  │
 │                  │
 │                  │
 └──────────────────┘
</pre>

<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Removing unwanted points"><h3 id="Removing unwanted points" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Removing unwanted points">Removing unwanted points</a></h3></div>

<p>
To remove unwanted points (at the center) template the <code>Voronoi Fracture</code> and look at the <code>Scatter</code> node.
</p>
<ul>
<li>
Add a <code>Group Create</code> node after the <code>Scatter</code>

<ul>
<li>
<code>Group Name</code> to <code>toDel</code>

<li>
Set the <code>Group Type</code> to <code>Points</code> on the dropdown.

<li>
Check 'off' the <code>Base Group</code>

<li>
Check 'on' the <code>Keep in Bounding Regions</code> &gt; <code>Enable</code> checkbox:

<ul>
<li>
Set the <code>Bounding Type</code> to <code>Bounding Sphere</code>:

<ul>
<li>
Size to <code>5.8</code>

</ul>
</ul>
</ul>
<li>
Add a <code>Blast</code> node after the <code>Group Create</code>:

<ul>
<li>
<code>Group</code> field to <code>toDel</code>

</ul>
</ul>
<p>
Reviewing the end of the chain will reveal that the busy cells in the center will have become much more simplified.
</p>

<ul>
<li>
Increase the size of the <code>Group Create</code> node's <code>Size</code> control to get even simpler and sharper shapes

</ul>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Introducing Noise to the Stretch"><h3 id="Introducing Noise to the Stretch" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Introducing Noise to the Stretch">Introducing Noise to the Stretch</a></h3></div>

<ul>
<li>
Inside the <code>stretch</code> VOP, copy the INPUT node ('geometryvopglobal1'):

<ul>
<li>
This will give us access to the parameters again for a cleaner graph.

<li>
From this INPUT's <code>P</code> output:

<ul>
<li>
Add a <code>Turbulent Noise</code> node:

<ul>
<li>
<code>Signature</code> to <code>3D Noise</code>

<li>
<code>RMB</code> and promote all inputs:

<li>
<code>VEX/VOP Options</code> &gt; <code>Create Input Parameters</code>

</ul>
<li>
Connect the <code>Turbulent Noise</code> output into the existing <code>Add</code> node's input3

</ul>
<li>
We want no distortion on the <code>z</code> axis, so between the <code>Turbulent Noise</code> and the <code>Add</code>:

<ul>
<li>
Drop a <code>Multiply</code> node:

<ul>
<li>
Promote the input2 to a <code>Constant</code>:

<ul>
<li>
Set to <code>3 Float (vector)</code>

<li>
Set the <code>3 Float Default</code> fields to <code>1, 1, 0</code> to eliminate the <code>z</code> values.

</ul>
</ul>
</ul>
</ul>
<li>
At the SOP level, on the <code>stretch</code> VOP:

<ul>
<li>
Change <code>Noise Type</code> to <code>Sparse Convolution Noise</code>

<li>
Change the <code>Frequency</code> to <code>1.5</code>

<li>
<code>Amplitude</code> to <code>0.54</code>

</ul>
</ul>
<p>
Feel free to increase the original <code>Grid</code> rows and columns to <code>100 x100</code> to see a more refined Voronoi pattern after distortion.
</p>

<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Introducing Noise to the Stretch-Diagram - Attribute VOP - Stretch - with noise"><h4 id="Diagram - Attribute VOP - Stretch - with noise" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Introducing Noise to the Stretch-Diagram - Attribute VOP - Stretch - with noise">Diagram - Attribute VOP - Stretch - with noise</a></h4></div>

<pre>
This doesn't have a duplicated `geometryvopglobal` INPUT. Same thing.

                              ┌─────────────┐  ┌──────────────┐    ┌────────────┐
                              │   distance  │  │     fit      │    │    ramp    │
                              │             │  │              │    │            │
                         ┌────┤ p1     dist │  │  val  shift  │    │input  ramp ├────┐
                         │ ┌──┤ p2          │  │              │    │            │    │
                         │ │  │             │  │  srcmax      │    └────────────┘    │
                         │ │  └─────────────┘  └──────────────┘                      │
                         │ └─────────────┐                           ┌───────────────┘
                         │               │                           │            ┌───────────────┐          ┌───────────────────┐
                         │               │                           │            │      add      │          │geometryvopoutput1 │
                         │               │                           │            │               │          │                   │
                         │    ┌──────────┼───────────────────────────┼────────────│input1     sum │──────────│P                  │
                         │    │          │                           │      ┌─────│input2         │          │                   │
                         │    │          │                         ┌─┼──────┼─────┤input3         │          │                   │
                         │    │          │                         │ │      │     └───────────────┘          │                   │
                         │    │          │                         │ │      │                                │                   │
                         │    │          │                         │ │      │                                └───────────────────┘
                         │    │          │                         │ │      │
                         │    │          │                         │ │      └──────────────────────────────────────┐
                         │    │          │                         │ └─────────────────┐                           │
                         │    │          │                         │                   │                           │
  ┌──────────────────┐   │    │          │      ┌──────────────┐   │   ┌─────────────┐ │   ┌──────────────────┐    │
  │geometryvopglobal1│   │    │          │      │   subtract   │   │   │  normalize  │ │   │     multiply     │    │
  │                  │   │    │          │      │              │   │   │             │ │   │                  │    │
  │                P ├─┬─┴────┴──────────┼──────┤input1   diff ├───┼───┤ vec    nvec ├─┼───│input1    product │────┘
  │                  │ │                 │    ┌─┤input2        │   │   │             │ │   │                  │
  │                  │ │      ┌────────┐ │    │ └──────────────┘   │   └─────────────┘ │   │input2            │
  │                  │ │      │constant│ │    │                    │                   │   │(promoted)        │
  │                  │ │      │0,0,0   ├─┴────┘                    │                   │   │                  │
  │                  │ │      └────────┘                           │                   └───┤input3            │
  │                  │ │                                           └──────┐                └──────────────────┘
  │                  │ │                                                  │
  │                  │ │                                                  │
  │                  │ │     ┌───────────────────┐    ┌──────────────┐    │
  │                  │ │     │  turbulentnoise   │    │  multiply    │    │
  │                  │ │     │                   │    │              │    │
  │                  │ └─────┤ position  noise   ├────│input1 product├────┘
  └──────────────────┘       │                   │    │              │
                             │(all rest promoted)│  ┌─┤input2        │
                             └───────────────────┘  │ │              │
                                                    │ └──────────────┘
                              ┌──────────┐          │
                              │ constant │          │
                              │          ├──────────┘
                              │ 0,0,0    │
                              └──────────┘
</pre>

<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Fix Normal Artifacts"><h3 id="Fix Normal Artifacts" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Fix Normal Artifacts">Fix Normal Artifacts</a></h3></div>

<p>
If the distortion was extreme, you may get 'Normal' artifacts on the surface.
</p>
<ul>
<li>
Drop a <code>Normal</code> node to fix them (at the end after the <code>Rest Postion</code> swap.

</ul>
<div id="Voxyde - Fracture Setups-Glass Voronoi Fracture-Extrude to Finish"><h3 id="Extrude to Finish" class="header"><a href="#Voxyde - Fracture Setups-Glass Voronoi Fracture-Extrude to Finish">Extrude to Finish</a></h3></div>


<p>
Add a <code>PolyExtrude</code> at the end of the network:
</p>
<ul>
<li>
Check <code>Output Back</code> to close off the back surfaces.

<li>
<code>Extrusion</code> tab &gt; <code>Front Transform</code>:

<ul>
<li>
Check 'on' the <code>Transform Extruded Front</code>:

<ul>
<li>
<code>Transform Space</code> to <code>Global</code>

<li>
<code>Translate</code> to <code>0, 0 , 0.1</code>

</ul>
</ul>
</ul>
<div id="Voxyde - Fracture Setups-RBD Connected Faces"><h2 id="RBD Connected Faces" class="header"><a href="#Voxyde - Fracture Setups-RBD Connected Faces">RBD Connected Faces</a></h2></div>
<div id="Voxyde - Fracture Setups-RBD Connected Faces-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=6579s|YouTube - RBD Connected Faces]]"><h4 id="[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=6579s|YouTube - RBD Connected Faces]]" class="header"><a href="#Voxyde - Fracture Setups-RBD Connected Faces-[[https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=6579s|YouTube - RBD Connected Faces]]"><a href="https://www.youtube.com/watch?v=0vqRqKpI-LY&amp;t=6579s">YouTube - RBD Connected Faces</a></a></h4></div>

<p>
When creating glass fractures, we don't want the inside edges and faces to exist (or show) when rendering, as presumably, the glass is whole when the pieces are at connected and at rest.
</p>

<ul>
<li>
The <code>RBD Connected Faces</code> node has the facility to remove this issue for us:

<ul>
<li>
We need an <code>inside</code> group for this to work.

</ul>
</ul>
<p>
Back on the <code>PolyExtrude</code> node:
</p>
<ul>
<li>
In the <code>Output Geometry and Groups</code> section of the parameters:

<ul>
<li>
Enable the <code>Side Group</code> checkbox:

<ul>
<li>
and rename the attribute to <code>inside</code>

</ul>
</ul>
</ul>
<p>
To see if it is working, add an <code>RBD Disconnected Faces</code> node after the <code>RBD Connected Faces</code> node:
</p>
<ul>
<li>
Set <code>Mode</code> (above the <code>Disconnected Attribute</code> field) to <code>Delete Connected</code>:

<ul>
<li>
In the exploded view, you should see those edges (faces) are gone.

<li>
You might have to adjust the <code>Distance Threshold</code> to finesse the result:

<ul>
<li>
I got rid of all the <code>inside</code> faces with a value of <code>0.842</code>.

</ul>
</ul>
</ul>
<div id="Google's NotebookLM Study Guide"><h1 id="Google's NotebookLM Study Guide" class="header"><a href="#Google's NotebookLM Study Guide">Google's NotebookLM Study Guide</a></h1></div>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ"><h2 id="Houdini Fracturing FAQ" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ">Houdini Fracturing FAQ</a></h2></div>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-1) What are the main fracturing methods available in Houdini?"><h4 id="1) What are the main fracturing methods available in Houdini?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-1) What are the main fracturing methods available in Houdini?">1) What are the main fracturing methods available in Houdini?</a></h4></div>
<p>
Houdini primarily offers two methods for fracturing: Voronoi and Boolean.
</p>

<p>
Voronoi Fracturing divides the geometry into cells based on the proximity to scattered points within the object. Imagine dropping grains of sand inside a mold – the space around each grain becomes a separate piece.
</p>

<p>
Boolean Fracturing uses cutter objects to slice through the geometry. This method is like using cookie cutters to carve shapes out of dough. The cutter objects determine the size, shape, and complexity of the resulting fractures.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-2) Why is the built-in RBD Material Fracture tool not always ideal for complex fracturing tasks?"><h4 id="2) Why is the built-in RBD Material Fracture tool not always ideal for complex fracturing tasks?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-2) Why is the built-in RBD Material Fracture tool not always ideal for complex fracturing tasks?">2) Why is the built-in RBD Material Fracture tool not always ideal for complex fracturing tasks?</a></h4></div>
<p>
While the RBD Material Fracture tool is convenient for simple scenarios, it can become inefficient and slow when dealing with a large number of pieces or intricate fracture patterns. Its main drawback is its reliance on re-baking the entire fracture for even minor adjustments, leading to prolonged waiting times and hindering creative exploration.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-3) How can I add detail to the interior surfaces of Voronoi-fractured pieces?"><h4 id="3) How can I add detail to the interior surfaces of Voronoi-fractured pieces?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-3) How can I add detail to the interior surfaces of Voronoi-fractured pieces?">3) How can I add detail to the interior surfaces of Voronoi-fractured pieces?</a></h4></div>
<p>
Basic Voronoi fracturing often results in flat, featureless interior surfaces, causing potential shading artifacts. To overcome this, you can employ a technique that involves storing the original point positions (using the "rest" attribute), applying noise to the geometry before the fracture, and then swapping back to the original "rest" attribute. This introduces detail along the fracture borders and creates a more visually appealing result.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-4) What is crucial to consider when using Boolean fracturing with cutter objects?"><h4 id="4) What is crucial to consider when using Boolean fracturing with cutter objects?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-4) What is crucial to consider when using Boolean fracturing with cutter objects?">4) What is crucial to consider when using Boolean fracturing with cutter objects?</a></h4></div>
<p>
The size of your cutter objects is paramount in Boolean fracturing. They must be large enough to completely encompass the target geometry. If the cutters are too small, they will only partially cut through the object, leading to incomplete fractures and messy geometry. This can create problems for subsequent operations, especially recursive fracturing.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-5) What is &quot;grout&quot; in fracturing and how can I create it?"><h4 id="5) What is &quot;grout&quot; in fracturing and how can I create it?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-5) What is &quot;grout&quot; in fracturing and how can I create it?">5) What is "grout" in fracturing and how can I create it?</a></h4></div>
<p>
"Grout" refers to the smaller, fragmented pieces that settle between the larger fractured chunks. This detail enhances realism and resembles the debris often found in real-world fractures. You can achieve this effect using Boolean fracturing by duplicating your cutter objects, offsetting their noise patterns slightly, and applying multiple Boolean operations to create these additional pieces along the fracture lines.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-6) What are the advantages of combining Voronoi and Boolean fracturing techniques?"><h4 id="6) What are the advantages of combining Voronoi and Boolean fracturing techniques?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-6) What are the advantages of combining Voronoi and Boolean fracturing techniques?">6) What are the advantages of combining Voronoi and Boolean fracturing techniques?</a></h4></div>
<p>
Merging Voronoi and Boolean workflows brings together the strengths of both methods, enabling you to create highly realistic and intricate fracture patterns. Voronoi fracturing ensures consistent piece sizes, providing a predictable base for the fracture. Boolean fracturing then adds detailed and random cuts, enhancing visual complexity and simulating the unpredictable nature of real-world fractures.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-7) Can I control the direction and placement of fractures using Voronoi techniques?"><h4 id="7) Can I control the direction and placement of fractures using Voronoi techniques?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-7) Can I control the direction and placement of fractures using Voronoi techniques?">7) Can I control the direction and placement of fractures using Voronoi techniques?</a></h4></div>
<p>
Yes, Voronoi fracturing allows for artistic control by strategically manipulating the placement of scatter points. For instance, scattering points along predefined lines concentrates fractures along those specific paths, enabling you to simulate directional forces or create visually interesting patterns.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing FAQ-8) How can I maintain consistent texture mapping across fractured pieces?"><h4 id="8) How can I maintain consistent texture mapping across fractured pieces?" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing FAQ-8) How can I maintain consistent texture mapping across fractured pieces?">8) How can I maintain consistent texture mapping across fractured pieces?</a></h4></div>
<p>
To avoid texture stretching or misalignment after fracturing, you need to manage UVs (texture coordinates) carefully. Apply the "UV Flatten" node to your cutter surfaces before remeshing. In the Boolean Fracture node, enable the "Copy Cutting Surface Attributes" option to transfer UVs from the cutters to the fractured pieces. You can then use UV Transform nodes to adjust scale and position if needed, ensuring a seamless texture appearance across all fragments.
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Deep Dive"><h2 id="Houdini Fracturing Techniques: A Deep Dive" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Deep Dive">Houdini Fracturing Techniques: A Deep Dive</a></h2></div>

<p>
This briefing document reviews the main themes and crucial insights from two sources: "Fracture Setups - Houdini VFX Course" and "Houdini Fracturing Techniques: A Study Guide."
</p>

<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Deep Dive-Key Takeaways"><h3 id="Key Takeaways" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Deep Dive-Key Takeaways">Key Takeaways</a></h3></div>

<ul>
<li>
Two Primary Fracturing Methods: Houdini offers two primary fracturing approaches: Voronoi and Boolean. Voronoi fracturing divides geometry based on proximity to scattered points, while Boolean fracturing uses cutter objects to slice through the geometry.

<li>
RBD Material Fracture Limitations: The built-in RBD Material Fracture tool, while convenient for simple tasks, becomes inefficient for complex fracturing due to its slow re-baking process for even minor adjustments.

<li>
Voronoi Challenges and Enhancements: Simple Voronoi fracturing often results in straight, detail-less interior surfaces, causing shading issues. A common solution involves storing the initial positions (rest attribute), applying noise to the geometry before the fracture, and then swapping back the original rest attribute to introduce detail along fracture borders.

<li>
Boolean Considerations: Cutter object size is critical in Boolean fracturing. Cutters must fully encompass the target geometry to avoid incomplete cuts and messy geometry, which can hinder further operations like recursive fracturing. Additionally, limiting cutter geometry outside the target object's bounds enhances performance.

<li>
Grout and Detail Enhancement: Grout, referring to smaller pieces nestled between larger fragments, increases realism. This effect can be achieved by duplicating and offsetting the noise patterns of cutter objects before applying Boolean fractures.

<li>
Combining Voronoi and Boolean: Merging Voronoi and Boolean workflows leverages the strengths of both methods. Voronoi ensures consistent piece sizes, while Boolean adds intricate cuts and randomness, striking a balance between predictability and complexity.

<li>
Art-Directing Fractures: Voronoi fracturing offers artistic control by manipulating scatter point placement. Strategically positioning points along lines, for instance, concentrates fractures along those paths.

<li>
UV Management: Consistent texture mapping across fractured pieces requires careful UV management. Applying UV Flatten to cutter surfaces before remeshing and enabling "Copy Cutting Surface Attributes" in the Boolean Fracture node transfers UVs to the fragments. UV Transforms can address any scaling discrepancies.

<li>
Recursive Fracturing: For intricate detail, recursive fracturing breaks down already fractured pieces. This involves selecting pieces for further fracturing based on attributes like size or proximity to other geometry. Packing those pieces as points, iterating through them with a For Each Named Primitive loop, and carefully managing the "name" attribute for proper reassembly is crucial.

<li>
Chipping Detail: Chipping adds realism by targeting corners and edges for additional fracturing. Identifying corner points using pointPrims function, blurring the selection for a smoother transition, scattering points based on this blurred attribute, and using Boolean operations with small cutters create convincing chips.

<li>
Glass Shattering Effects: Achieving realistic glass shattering involves specific considerations:

<li>
Radial Shards: Manipulating point positions with radial stretching and controlling the effect with a ramp to avoid overly small shards in the center.

<li>
Concentric Fractures: Generating concentric cutter surfaces with randomized parameters for each piece using a compiled block for performance optimization.

<li>
Interior Geometry Handling: Using the RBD Connected Faces node with an "inside" group to remove interior geometry for rendering the glass as a solid object.

</ul>
<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Deep Dive-Optimization Strategies"><h3 id="Optimization Strategies" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Deep Dive-Optimization Strategies">Optimization Strategies</a></h3></div>

<ul>
<li>
Compiled Blocks: Encapsulating repetitive operations within compiled blocks significantly enhances performance, particularly for recursive fracturing and per-piece modifications.

<li>
Point Cloud Operations: Utilizing point clouds for tasks like selecting pieces or calculating distances leverages the efficiency of point-based operations.

<li>
Geometry Reduction: Eliminating unnecessary cutter geometry outside the target object's bounds and utilizing techniques like Boolean Union to remove intersecting geometry improves processing speed.

</ul>
<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide"><h2 id="Houdini Fracturing Techniques: A Study Guide" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide">Houdini Fracturing Techniques: A Study Guide</a></h2></div>
<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Quiz"><h3 id="Quiz" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Quiz">Quiz</a></h3></div>

<ol>
<li>
What are the two main options for fracturing in Houdini, and how do they differ?

<li>
Why is the RBD Material Fracture tool often not preferred for complex fracturing tasks in Houdini?

<li>
Explain the issue of straight interiors in Voronoi fracturing and a common technique to address it.

<li>
What is the key consideration regarding cutter object size in Boolean fracturing, and why is it important?

<li>
Describe the concept of "grout" in fracturing and how it can be achieved using Boolean techniques.

<li>
Why is combining Voronoi and Boolean workflows often a preferred method for fracturing?

<li>
How can the Voronoi fracturing technique be art-directed to achieve specific fracture patterns?

<li>
Explain how UVs can be handled during the fracturing process to maintain consistent texture mapping.

<li>
Describe the concept of recursive fracturing and a common method for selecting pieces for further fracturing.

<li>
Explain how chipping details can be added to fractured objects using techniques like pointPrims and Boolean operations.

</ol>
<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Answer Key"><h3 id="Answer Key" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Answer Key">Answer Key</a></h3></div>

<ol>
<li>
The two main options are Voronoi fracturing, which utilizes points scattered within the geometry to define fracture cells, and Boolean fracturing, which employs cutter objects to slice the geometry.

<li>
The RBD Material Fracture tool, while useful for simple cases, can become slow and clunky when dealing with a large number of pieces due to its reliance on re-baking the entire fracture for even minor changes.

<li>
Straight interiors lack detail and can lead to shading issues. A common technique involves storing the original position (rest), applying noise to the geometry, then performing the Voronoi fracture, and finally swapping the rest attribute to introduce detail on piece borders.

<li>
Cutter objects in Boolean fracturing must be large enough to completely cover the geometry being fractured. Smaller cutters result in incomplete cuts and messy geometry, causing issues with subsequent operations like recursive fracturing.

<li>
Grout refers to the smaller pieces situated along the fracture lines, adding realism to the overall effect. It can be achieved by duplicating the cutter objects, offsetting their noise patterns, and performing Boolean fractures to create these additional pieces.

<li>
Combining Voronoi and Boolean workflows allows for both consistent piece sizes (from Voronoi) and detailed, intricate cuts (from Boolean) with added randomness. This offers a balance between predictability and visual complexity.

<li>
Voronoi fracturing can be art-directed by strategically placing scatter points that dictate the fracture pattern. For instance, scattering points along lines can create fractures concentrated in specific directions.

<li>
UVs can be handled by applying UV Flatten to the cutter surfaces before remeshing and then enabling "Copy Cutting Surface Attributes" in the Boolean Fracture node to transfer the UVs to the fractured pieces. Additional UV transforms might be necessary for scale adjustments.

<li>
Recursive fracturing involves fracturing already fractured pieces to achieve finer detail. This can be done by selecting pieces based on attributes like size or proximity to other geometry, packing them as points, and then iterating through them with a For Each Named Primitive loop to apply further fracturing.

<li>
Chipping details involve selectively targeting corners or edges for additional fracturing. This can be achieved by using techniques like pointPrims to identify points with multiple primitives attached, applying a blur to spread the selection, scattering points on the blurred attribute, and then using Boolean operations with small cutter objects to create the chips.

</ol>
<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Essay Questions"><h3 id="Essay Questions" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Essay Questions">Essay Questions</a></h3></div>

<ul>
<li>
Discuss the advantages and disadvantages of both Voronoi and Boolean fracturing techniques in Houdini. Consider factors such as speed, control, and resulting fracture characteristics.

<li>
Explain how manipulating attributes like normals, rest positions, and noise can be used to control and enhance the appearance of fractured surfaces.

<li>
Describe the process of setting up and executing recursive fracturing in Houdini. Explain different strategies for selecting pieces for further fracturing and the importance of managing the "name" attribute.

<li>
Discuss specific techniques and considerations for creating realistic glass shattering effects in Houdini. Include explanations of methods for achieving radial shard shapes, concentric fractures, and handling interior geometry for rendering.

<li>
How can you optimize the performance of complex fracturing setups in Houdini? Discuss strategies like utilizing compiled blocks, point cloud operations, and reducing unnecessary geometry.

</ul>
<div id="Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Glossary"><h3 id="Glossary" class="header"><a href="#Google's NotebookLM Study Guide-Houdini Fracturing Techniques: A Study Guide-Glossary">Glossary</a></h3></div>

<ul>
<li>
RBD Material Fracture: A built-in Houdini tool for fracturing geometry based on material properties.

<li>
Voronoi Fracture: A fracturing technique that divides space into cells based on the proximity to scattered points.

<li>
Boolean Fracture: A fracturing technique that utilizes cutter objects to slice the geometry.

<li>
Cutter Object: Geometry used in Boolean fracturing to define the cuts in the target object.

<li>
Grout: Smaller fractured pieces that fill the spaces between larger fractured chunks.

<li>
Rest Attribute: Stores the initial position of points before any transformations are applied.

<li>
UV Flatten: A node that generates UVs for a surface by flattening its 3D structure.

<li>
Recursive Fracturing: The process of further fracturing already fractured pieces.

<li>
For Each Named Primitive: A loop that iterates over individual pieces within a fractured object.

<li>
pointPrims: A function that returns an array of primitives connected to a given point.

<li>
Compiled Block: A section of a Houdini network that can be pre-compiled for faster execution.

<li>
RBD Connected Faces: A node specifically designed for handling glass fractures, removing interior geometry for rendering purposes.

<li>
Poly Extrude: A node that adds thickness to a surface by extruding it along a specified direction.

<li>
Attribute Wrangle: A node for manipulating attributes using VEX code.

<li>
This study guide provides a comprehensive overview of the essential concepts and techniques presented in the provided excerpt. Engaging with the quiz, exploring the essay questions, and referring to the glossary will help solidify your understanding of Houdini fracturing techniques.

</ul>
<p>
<br>
<a href="Houdini.html">Houdini</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
