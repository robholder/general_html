<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>shell_scripts_bash</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>


<p>
<a href="index.html">index</a>
</p>

<p>
<a href="shell_and_bash.html">Shell and Bash</a> 
</p>

<div id="Bash and Shell Scripts"><h1 id="Bash and Shell Scripts" class="header"><a href="#Bash and Shell Scripts">Bash and Shell Scripts</a></h1></div>

<div id="Contents" class="toc"><h1 id="Contents" class="header"><a href="#Contents">Contents</a></h1></div>
<ul>
<li>
<a href="shell_scripts_bash.html#Bash and Shell Scripts">Bash and Shell Scripts</a>

<li>
<a href="shell_scripts_bash.html#Alias or Bin">Alias or Bin</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Option 1: Create a Bash Alias">Option 1: Create a Bash Alias</a>

<li>
<a href="shell_scripts_bash.html#Option 2: Convert It into an Executable Command">Option 2: Convert It into an Executable Command</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Which Method is Best?">Which Method is Best?</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Source The Script From Its Location">Source The Script From Its Location</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Steps to Achieve This:">Steps to Achieve This:</a>

<li>
<a href="shell_scripts_bash.html#What Happens Now?">What Happens Now?</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Return to Original Directory">Return to Original Directory</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Updated Script with Cleanup">Updated Script with Cleanup</a>

<li>
<a href="shell_scripts_bash.html#How This Works">How This Works</a>

</ul>
</ul>
<li>
<a href="shell_scripts_bash.html#Conditional Alias (Function)">Conditional Alias (Function)</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Solution: Conditional Check Inside an Alias">Solution: Conditional Check Inside an Alias</a>

<li>
<a href="shell_scripts_bash.html#Solution: Use command -v for External Scripts">Solution: Use command -v for External Scripts</a>

<li>
<a href="shell_scripts_bash.html#Why Is This Useful?">Why Is This Useful?</a>

</ul>
<li>
<a href="shell_scripts_bash.html#If the Script Moves">If the Script Moves</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Solution: Store the Last Used Path in a File">Solution: Store the Last Used Path in a File</a>

<li>
<a href="shell_scripts_bash.html#How This Works">How This Works</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Bash Script To Set Environment Variables">Bash Script To Set Environment Variables</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Setting Show, Seq And Shot Variables">Setting Show, Seq And Shot Variables</a>

<ul>
<li>
<a href="shell_scripts_bash.html#How This Bash Script Works">How This Bash Script Works</a>

<ul>
<li>
<a href="shell_scripts_bash.html#To Use It">To Use It</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Key Differences Between Python &amp; Bash Versions">Key Differences Between Python &amp; Bash Versions</a>

</ul>
</ul>
<li>
<a href="shell_scripts_bash.html#Another Example (Enhanced)">Another Example (Enhanced)</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Key Updates:">Key Updates:</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Hybrid - Positional &amp; Flags">Hybrid - Positional &amp; Flags</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Key Features">Key Features</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Hybrid Bash Script">Hybrid Bash Script</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Breaking It Down">Breaking It Down</a>

<li>
<a href="shell_scripts_bash.html#How It Works in Context">How It Works in Context</a>

<li>
<a href="shell_scripts_bash.html#Key Behavior">Key Behavior</a>

<li>
<a href="shell_scripts_bash.html#Why Use This?">Why Use This?</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Usage Examples">Usage Examples</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Using Positional Arguments">Using Positional Arguments</a>

<li>
<a href="shell_scripts_bash.html#Using Flags">Using Flags</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Using Flags">Using Flags</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Why Use This Hybrid Approach?">Why Use This Hybrid Approach?</a>

</ul>
<li>
<a href="shell_scripts_bash.html#Abbreviated Flags">Abbreviated Flags</a>

<ul>
<li>
<a href="shell_scripts_bash.html#Now You Can Use:">Now You Can Use:</a>

<li>
<a href="shell_scripts_bash.html#Why Use Both?">Why Use Both?</a>

</ul>
</ul>
<div id="Alias or Bin"><h1 id="Alias or Bin" class="header"><a href="#Alias or Bin">Alias or Bin</a></h1></div>

<p>
You can turn your Bash script into a command using an alias or by placing it in a directory where your shell can find it.
</p>

<div id="Alias or Bin-Option 1: Create a Bash Alias"><h2 id="Option 1: Create a Bash Alias" class="header"><a href="#Alias or Bin-Option 1: Create a Bash Alias">Option 1: Create a Bash Alias</a></h2></div>

<p>
Aliases are great for quick commands but only work in the current shell session (or permanently if added to .bashrc).
</p>

<p>
For a script named <code>set_env.sh</code>, open your terminal and run:
</p>

<pre sh>
alias setenv='source /path/to/set_env.sh'
</pre>

<p>
Now, you can call the script simply by typing:
</p>

<pre sh>
setenv "MyShow" "Seq01" "Shot005"
</pre>

<ul>
<li>
ðŸ”¹ Make It Permanent: To keep the alias after rebooting, add it to your .bashrc or .zshrc file:

</ul>
  
<pre sh>
echo 'alias setenv="source /path/to/set_env.sh"' &gt;&gt; ~/.bashrc
source ~/.bashrc  # Apply changes
</pre>

<div id="Alias or Bin-Option 2: Convert It into an Executable Command"><h2 id="Option 2: Convert It into an Executable Command" class="header"><a href="#Alias or Bin-Option 2: Convert It into an Executable Command">Option 2: Convert It into an Executable Command</a></h2></div>

<p>
If you want the script to act like a real command:
</p>

<p>
Move the script to /usr/local/bin/ (or another executable directory):
</p>

<pre sh>
mv set_env.sh /usr/local/bin/setenv
</pre>

<p>
Give it execution permissions:
</p>

<pre sh>
chmod +x /usr/local/bin/setenv
</pre>

<p>
Now you can use it like a normal command:
</p>

<pre sh>
setenv "MyShow" "Seq01" "Shot005"
</pre>

<table>
<tr>
<td>
âš  Note: Since source is needed for environment variables to persist, you must run:
</td>
</tr>
</table>

<pre sh>
source setenv "MyShow" "Seq01"
</pre>

<p>
Otherwise, the variables will only exist in the script's process and disappear afterward.
</p>

<div id="Alias or Bin-Option 2: Convert It into an Executable Command-Which Method is Best?"><h4 id="Which Method is Best?" class="header"><a href="#Alias or Bin-Option 2: Convert It into an Executable Command-Which Method is Best?">Which Method is Best?</a></h4></div>

<ul>
<li>
âœ” Alias â†’ Quick setup, useful for temporary commands. 

<li>
âœ” Executable Script in <code>/usr/local/bin/</code> â†’ Better for standalone scripts but requires manual sourcing for env variables.

</ul>
<div id="Alias or Bin-Source The Script From Its Location"><h2 id="Source The Script From Its Location" class="header"><a href="#Alias or Bin-Source The Script From Its Location">Source The Script From Its Location</a></h2></div>

<p>
NOTE: Unlike Python scripts, Bash scripts often have to be 'sourced' instead of 'run' ~ using a 'source' command:
</p>

<pre sh>
source mybashscript.sh
</pre>

<p>
To expand on this, we can set an alias to 'source' the script, but sometimes we need to to think it's being sourced from the enclosing directory, and not from where we might be in the shell:
</p>

<ul>
<li>
Question: Is it possible to source a bash script with an alias, but make it think it's being run from the location of the bash script, and not where the alias is called?

<li>
Yes, you can do this using DIR="\((dirname "\)(realpath "$BASH_SOURCE")")", which ensures that your Bash script thinks it's running from its own directory, even when sourced via an alias.

</ul>
<div id="Alias or Bin-Source The Script From Its Location-Steps to Achieve This:"><h4 id="Steps to Achieve This:" class="header"><a href="#Alias or Bin-Source The Script From Its Location-Steps to Achieve This:">Steps to Achieve This:</a></h4></div>

<p>
Modify Your Script (set_env.sh) Add this snippet at the top:
</p>

<pre bash>
# Get the directory where the script is located
DIR="$(dirname "$(realpath "$BASH_SOURCE")")"

# Change to that directory
cd "$DIR" || exit 1

echo "Running script from: $DIR"
</pre>

<p>
Create an Alias in .bashrc or .zshrc
</p>

<pre sh>
alias setenv="source /path/to/set_env.sh"
</pre>

<p>
Reload your shell with:
</p>

<pre sh>
source ~/.bashrc  # Or ~/.zshrc if using Zsh
</pre>

<div id="Alias or Bin-Source The Script From Its Location-What Happens Now?"><h4 id="What Happens Now?" class="header"><a href="#Alias or Bin-Source The Script From Its Location-What Happens Now?">What Happens Now?</a></h4></div>

<ul>
<li>
When you run <code>setenv</code>, the script will change to its directory instead of where the alias was called.

<li>
<code>realpath "$BASH_SOURCE"</code> ensures the script knows its actual location.

</ul>
<div id="Alias or Bin-Source The Script From Its Location-Return to Original Directory"><h3 id="Return to Original Directory" class="header"><a href="#Alias or Bin-Source The Script From Its Location-Return to Original Directory">Return to Original Directory</a></h3></div>

<p>
To ensure they return to the original directory, you can store the starting location before changing directories, and then cd back at the end of the script.
</p>

<div id="Alias or Bin-Source The Script From Its Location-Return to Original Directory-Updated Script with Cleanup"><h4 id="Updated Script with Cleanup" class="header"><a href="#Alias or Bin-Source The Script From Its Location-Return to Original Directory-Updated Script with Cleanup">Updated Script with Cleanup</a></h4></div>

<pre bash>
#!/bin/bash

# Store the directory the user was in before sourcing the script
ORIGINAL_DIR="$(pwd)"

# Get the directory where the script is located
# DIR="$(dirname "$(realpath "$BASH_SOURCE")")"
DIR="$(dirname "$(realpath "$0")")"

# Change to the script's directory
cd "$DIR" || exit 1

echo "Running script from: $DIR"

# (Insert your script logic here)

# Return the user to their original directory before the script was sourced
cd "$ORIGINAL_DIR"

echo "Returned to: $ORIGINAL_DIR"
</pre>

<div id="Alias or Bin-Source The Script From Its Location-Return to Original Directory-How This Works"><h4 id="How This Works" class="header"><a href="#Alias or Bin-Source The Script From Its Location-Return to Original Directory-How This Works">How This Works</a></h4></div>

<ul>
<li>
<code>ORIGINAL_DIR="$(pwd)"</code> â†’ Captures the directory the user started in.

<li>
Switches to the scriptâ€™s location (<code>cd "$DIR"</code>).

<li>
Runs the script logic while inside its own directory.

<li>
Returns the user to <code>ORIGINAL_DIR</code> at the end.

</ul>
<p>
Now, no matter where the user calls <code>source script.sh</code>, they will end up back where they started once the script finishes running.
</p>

<div id="Conditional Alias (Function)"><h1 id="Conditional Alias (Function)" class="header"><a href="#Conditional Alias (Function)">Conditional Alias (Function)</a></h1></div>

<p>
You can add a conditional to detect whether the script still exists before attempting to run the alias. This helps prevent confusion if the script gets moved or deleted.
</p>

<div id="Conditional Alias (Function)-Solution: Conditional Check Inside an Alias"><h3 id="Solution: Conditional Check Inside an Alias" class="header"><a href="#Conditional Alias (Function)-Solution: Conditional Check Inside an Alias">Solution: Conditional Check Inside an Alias</a></h3></div>

<p>
Since aliases are simple command substitutions, they donâ€™t support conditionals directly. However, you can wrap the alias inside a function in .zshrc:
</p>

<pre zsh>
sme() {
    SCRIPT_PATH="$HOME/scripts/my_script.sh"

    if [[ -f "$SCRIPT_PATH" ]]; then
        source "$SCRIPT_PATH"
    else
        echo "Error: Command missing! The script '$SCRIPT_PATH' does not exist."
    fi
}
</pre>


<ul>
<li>
âœ” Defines a function (which behaves like an alias but allows conditionals). 

<li>
âœ” Checks if the file exists before running it. 

<li>
âœ” Displays an error message instead of failing silently.

</ul>
<div id="Conditional Alias (Function)-Solution: Use command -v for External Scripts"><h3 id="Solution: Use command -v for External Scripts" class="header"><a href="#Conditional Alias (Function)-Solution: Use command -v for External Scripts">Solution: Use command -v for External Scripts</a></h3></div>

<p>
If the alias points to an executable script (not sourced), use command -v:
</p>

<pre zsh>
sme() {
    SCRIPT_PATH="$HOME/scripts/my_script.sh"

    if command -v "$SCRIPT_PATH" &gt;/dev/null 2&gt;&amp;1; then
        "$SCRIPT_PATH"
    else
        echo "Error: Command missing! '$SCRIPT_PATH' is unavailable."
    fi
}
</pre>


<ul>
<li>
âœ” Detects whether the command exists before running it. 

<li>
âœ” Works well for executable scripts, but not for sourced ones.

</ul>
<div id="Conditional Alias (Function)-Why Is This Useful?"><h3 id="Why Is This Useful?" class="header"><a href="#Conditional Alias (Function)-Why Is This Useful?">Why Is This Useful?</a></h3></div>

<ul>
<li>
âœ… Prevents confusion if the script gets moved or deleted.

<li>
âœ… Ensures users get feedback instead of silent failures.

<li>
âœ… Keeps your aliases more robust and user-friendly.

</ul>
<div id="Conditional Alias (Function)-If the Script Moves"><h2 id="If the Script Moves" class="header"><a href="#Conditional Alias (Function)-If the Script Moves">If the Script Moves</a></h2></div>

<p>
If the script moves, let's give a user the opportunity to pass in a new path, and have it remembered.
</p>

<div id="Conditional Alias (Function)-If the Script Moves-Solution: Store the Last Used Path in a File"><h3 id="Solution: Store the Last Used Path in a File" class="header"><a href="#Conditional Alias (Function)-If the Script Moves-Solution: Store the Last Used Path in a File">Solution: Store the Last Used Path in a File</a></h3></div>

<p>
We'll save the last successful script path in a hidden file (e.g., ~/.last_script_path) so it can be retrieved automatically in future sessions.
</p>

<pre zsh>
sme() {
    SCRIPT_NAME="my_script.sh"
    SEARCH_DIRS=("$HOME/scripts" "$HOME/bin" "$HOME/.local/bin" "$PWD")
    LAST_PATH_FILE="$HOME/.last_script_path"

    # Try using the last known path first
    if [[ -f "$LAST_PATH_FILE" ]]; then
        LAST_PATH=$(cat "$LAST_PATH_FILE")
        if [[ -f "$LAST_PATH" ]]; then
            SCRIPT_PATH="$LAST_PATH"
        fi
    fi

    # If the script isn't found via the last path, search predefined directories
    if [[ -z "$SCRIPT_PATH" ]]; then
        for dir in "${SEARCH_DIRS[@]}"; do
            if [[ -f "$dir/$SCRIPT_NAME" ]]; then
                SCRIPT_PATH="$dir/$SCRIPT_NAME"
                break
            fi
        done
    fi

    # If script wasn't found, prompt user for input
    while [[ -z "$SCRIPT_PATH" ]]; do
        echo "Error: Could not find '$SCRIPT_NAME'."
        echo "Please enter the correct path or type 'cancel' to abort:"
        read -r user_path

        if [[ "$user_path" == "cancel" ]]; then
            echo "Operation canceled."
            return 1
        fi

        if [[ -f "$user_path" ]]; then
            SCRIPT_PATH="$user_path"
            echo "$SCRIPT_PATH" &gt; "$LAST_PATH_FILE"  # Save the new path for future use
        else
            echo "Invalid path: '$user_path' does not exist."
        fi
    done

    # If we successfully locate the script, source it
    echo "Found script at: $SCRIPT_PATH"
    source "$SCRIPT_PATH"
}
</pre>

<div id="Conditional Alias (Function)-If the Script Moves-How This Works"><h3 id="How This Works" class="header"><a href="#Conditional Alias (Function)-If the Script Moves-How This Works">How This Works</a></h3></div>

<ul>
<li>
âœ” Checks if a last-known path exists (~/.last_script_path). 

<li>
âœ” Uses the saved path automatically if the script is still there. 

<li>
âœ” Searches known directories as a fallback. 

<li>
âœ” Asks the user for input if needed and remembers the new path for next time.

</ul>
<p>
Now your function intelligently remembers the script location across sessions, reducing user effort! ðŸš€
</p>

<div id="Bash Script To Set Environment Variables"><h1 id="Bash Script To Set Environment Variables" class="header"><a href="#Bash Script To Set Environment Variables">Bash Script To Set Environment Variables</a></h1></div>

<p>
Python has a hard time updating shell env vars. This is because the Python script is a subprocess.
</p>

<div id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables"><h2 id="Setting Show, Seq And Shot Variables" class="header"><a href="#Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables">Setting Show, Seq And Shot Variables</a></h2></div>

<p>
This example sets 1, 2 or all 3 environment variables, based on input:
</p>

<pre bash>
#!/bin/bash

# Function to set hierarchical environment variables
set_env_variables() {
    local show="$1"
    local sequence="$2"
    local shot="$3"

    # Set the SHOW variable
    export SHOW="$show"

    # If SHOW is set, reset SEQ and SHOT
    if [[ -n "$SHOW" ]]; then
        export SEQ=""
        export SHOT=""
    fi

    # If SEQ is set, reset SHOT
    if [[ -n "$sequence" ]]; then
        export SEQ="$sequence"
        export SHOT=""
    fi

    # If SHOT is set, do not reset anything else
    if [[ -n "$shot" ]]; then
        export SHOT="$shot"
    fi

    # Print the environment variables
    echo "Environment variables set:"
    echo "SHOW: $SHOW"
    echo "SEQ: $SEQ"
    echo "SHOT: $SHOT"
}

# Accept up to three positional arguments
set_env_variables "$1" "$2" "$3"
</pre>

<div id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-How This Bash Script Works"><h3 id="How This Bash Script Works" class="header"><a href="#Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-How This Bash Script Works">How This Bash Script Works</a></h3></div>

<ul>
<li>
Accepts up to three positional arguments (SHOW, SEQ, SHOT).

<li>
If only SHOW is provided, it resets SEQ and SHOT.

<li>
If SEQ is provided, it sets SEQ and resets SHOT.

<li>
If SHOT is provided, it sets SHOT but does not reset other values.

<li>
Uses export so the variables persist in the shell.

</ul>
<div id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-How This Bash Script Works-To Use It"><h4 id="To Use It" class="header"><a href="#Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-How This Bash Script Works-To Use It">To Use It</a></h4></div>

<p>
Save the script as set_env.sh and run:
</p>

<pre sh>
source set_env.sh "MyShow" "Seq01" "Shot005"
</pre>

<p>
For with fewer arguments:
</p>

<pre sh>
source set_env.sh "MyShow"
source set_env.sh "MyShow" "Seq01"
</pre>

<p>
Using source ensures the variables persist in your shell session.
</p>

<div id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-Key Differences Between Python &amp; Bash Versions"><h3 id="Key Differences Between Python &amp; Bash Versions" class="header"><a href="#Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-Key Differences Between Python &amp; Bash Versions">Key Differences Between Python &amp; Bash Versions</a></h3></div>

<table>
<tr>
<td>
<span id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-Key Differences Between Python &amp; Bash Versions-Feature"></span><strong id="Feature">Feature</strong>
</td>
<td>
<span id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-Key Differences Between Python &amp; Bash Versions-Python Version"></span><strong id="Python Version">Python Version</strong>
</td>
<td>
<span id="Bash Script To Set Environment Variables-Setting Show, Seq And Shot Variables-Key Differences Between Python &amp; Bash Versions-Bash Version"></span><strong id="Bash Version">Bash Version</strong>
</td>
</tr>
<tr>
<td>
Argument Parsing
</td>
<td>
<code>argparse</code> module
</td>
<td>
Positional parameters (<code>\(1</code>, <code>\)2</code>, <code>$3</code>)
</td>
</tr>
<tr>
<td>
Environment Setting
</td>
<td>
<code>os.environ["VAR"] = value</code>
</td>
<td>
<code>export VAR=value</code>
</td>
</tr>
<tr>
<td>
Hierarchical Logic
</td>
<td>
<code>if show: ...</code> Python-style
</td>
<td>
<code>if [[ -n "$VAR" ]]; ...</code> Bash-style
</td>
</tr>
<tr>
<td>
Reset Mechanism
</td>
<td>
<code>os.environ.pop()</code>
</td>
<td>
<code>export VAR=""</code>
</td>
</tr>
</table>

<div id="Another Example (Enhanced)"><h1 id="Another Example (Enhanced)" class="header"><a href="#Another Example (Enhanced)">Another Example (Enhanced)</a></h1></div>

<p>
Here's how we can refine the Bash script to 'zero out' <code>SEQ</code> and <code>SHOT</code> when only <code>SHOW</code> is provided, and set <code>SHOW</code> to None if only <code>SEQ</code> and <code>SHOT</code> are provided.
</p>

<div id="Another Example (Enhanced)-Key Updates:"><h2 id="Key Updates:" class="header"><a href="#Another Example (Enhanced)-Key Updates:">Key Updates:</a></h2></div>

<ul>
<li>
âœ… If only SHOW is provided, then SEQ and SHOT will be cleared (None). 

<li>
âœ… If only SEQ and SHOT are given, then SHOW will be set to "None". 

<li>
âœ… Flags (--show, --seq, --shot) introduced using getopts.
<pre bash>
#!/bin/bash

# Default values
SHOW=""
SEQ=""
SHOT=""

# Parse command-line flags using getopts
while [[ $# -gt 0 ]]; do
    case "$1" in
        --show)
            SHOW="$2"
            shift 2
            ;;
        --seq)
            SEQ="$2"
            shift 2
            ;;
        --shot)
            SHOT="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Apply hierarchy logic
if [[ -n "$SHOW" &amp;&amp; -z "$SEQ" &amp;&amp; -z "$SHOT" ]]; then
    SEQ="None"
    SHOT="None"
elif [[ -z "$SHOW" &amp;&amp; -n "$SEQ" &amp;&amp; -n "$SHOT" ]]; then
    SHOW="None"
fi

# Construct directory path
HOME_DIR="$HOME"
DIRECTORY_PATH="$HOME_DIR/projects/$SHOW/$SEQ/$SHOT"

# Set environment variables
export SHOW
export SEQ
export SHOT

echo "SHOW: $SHOW"
echo "SEQ: $SEQ"
echo "SHOT: $SHOT"
echo "Generated directory path: $DIRECTORY_PATH"

# Optional: Create the directory if it doesnâ€™t exist
mkdir -p "$DIRECTORY_PATH"
</pre>

</ul>
<div id="Hybrid - Positional &amp; Flags"><h1 id="Hybrid - Positional &amp; Flags" class="header"><a href="#Hybrid - Positional &amp; Flags">Hybrid - Positional &amp; Flags</a></h1></div>

<p>
Here's a Bash script that supports both flags and positional arguments, making it flexible for different use cases.
</p>

<div id="Hybrid - Positional &amp; Flags-Key Features"><h4 id="Key Features" class="header"><a href="#Hybrid - Positional &amp; Flags-Key Features">Key Features</a></h4></div>

<ul>
<li>
âœ… Supports Positional Arguments â†’ Simply provide "Show" "Sequence" "Shot". 

<li>
âœ… Supports Flags (--show, --seq, --shot) â†’ Explicitly set values. 

<li>
âœ… Auto-corrects hierarchy â†’ Ensures SEQ and SHOT reset if only SHOW is set, and SHOW is "None" when only SEQ and SHOT are given.

</ul>
<div id="Hybrid - Positional &amp; Flags-Hybrid Bash Script"><h3 id="Hybrid Bash Script" class="header"><a href="#Hybrid - Positional &amp; Flags-Hybrid Bash Script">Hybrid Bash Script</a></h3></div>

<pre bash>
#!/bin/bash

# Default values
SHOW=""
SEQ=""
SHOT=""

# Check for flags first
while [[ $# -gt 0 ]]; do
    case "$1" in
        --show)
            SHOW="$2"
            shift 2
            ;;
        --seq)
            SEQ="$2"
            shift 2
            ;;
        --shot)
            SHOT="$2"
            shift 2
            ;;
        *)
            break # Stop processing flags when encountering positional arguments
            ;;
    esac
done

# If no flags were used, capture positional arguments
if [[ -z "$SHOW" &amp;&amp; -n "$1" ]]; then SHOW="$1"; shift; fi
if [[ -z "$SEQ" &amp;&amp; -n "$1" ]]; then SEQ="$1"; shift; fi
if [[ -z "$SHOT" &amp;&amp; -n "$1" ]]; then SHOT="$1"; shift; fi

# Apply hierarchy logic
if [[ -n "$SHOW" &amp;&amp; -z "$SEQ" &amp;&amp; -z "$SHOT" ]]; then
    SEQ="None"
    SHOT="None"
elif [[ -z "$SHOW" &amp;&amp; -n "$SEQ" &amp;&amp; -n "$SHOT" ]]; then
    SHOW="None"
fi

# Construct directory path
HOME_DIR="$HOME"
DIRECTORY_PATH="$HOME_DIR/projects/$SHOW/$SEQ/$SHOT"

# Set environment variables
export SHOW
export SEQ
export SHOT

echo "SHOW: $SHOW"
echo "SEQ: $SEQ"
echo "SHOT: $SHOT"
echo "Generated directory path: $DIRECTORY_PATH"

# Optional: Create the directory if it doesnâ€™t exist
mkdir -p "$DIRECTORY_PATH"
</pre>

<p>
The line:
</p>

<pre bash>
while [[ $# -gt 0 ]]; do
</pre>
<p>
...is a loop in Bash that continues executing while there are remaining command-line arguments.
</p>

<div id="Hybrid - Positional &amp; Flags-Hybrid Bash Script-Breaking It Down"><h4 id="Breaking It Down" class="header"><a href="#Hybrid - Positional &amp; Flags-Hybrid Bash Script-Breaking It Down">Breaking It Down</a></h4></div>
 
<ul>
<li>
<code>#</code> â†’ Represents the number of positional parameters (arguments) passed to the script.

<li>
<code>-gt 0</code> â†’ Checks if the number of arguments is greater than zero.

<li>
<code>while [[ ... ]]; do</code> â†’ Starts a loop that will run until all arguments are processed.

</ul>
<div id="Hybrid - Positional &amp; Flags-Hybrid Bash Script-How It Works in Context"><h4 id="How It Works in Context" class="header"><a href="#Hybrid - Positional &amp; Flags-Hybrid Bash Script-How It Works in Context">How It Works in Context</a></h4></div>

<p>
This pattern is commonly used when parsing flags and arguments in scripts:
</p>

<pre bash>
while [[ $# -gt 0 ]]; do
    case "$1" in
        --show)
            SHOW="$2"
            shift 2  # Move to the next argument pair
            ;;
        --seq)
            SEQ="$2"
            shift 2
            ;;
        --shot)
            SHOT="$2"
            shift 2
            ;;
        *)
            break  # Exit loop if an unknown argument is encountered
            ;;
    esac
done
</pre>

<div id="Hybrid - Positional &amp; Flags-Hybrid Bash Script-Key Behavior"><h4 id="Key Behavior" class="header"><a href="#Hybrid - Positional &amp; Flags-Hybrid Bash Script-Key Behavior">Key Behavior</a></h4></div>

<ul>
<li>
Reads the first argument (<code>$1</code>) and checks if it matches an expected flag.

<li>
Uses <code>shift</code> to move to the next argument (removing the processed ones).

<li>
Continues until all arguments are processed, meaning <code>$#</code> becomes 0, and the loop stops.

</ul>
<div id="Hybrid - Positional &amp; Flags-Hybrid Bash Script-Why Use This?"><h4 id="Why Use This?" class="header"><a href="#Hybrid - Positional &amp; Flags-Hybrid Bash Script-Why Use This?">Why Use This?</a></h4></div>

<ul>
<li>
âœ” Efficient for processing multiple flags dynamically 

<li>
âœ” Avoids manual indexing (<code>\(1</code>, <code>\)2</code>, etc.), which is error-prone 

<li>
âœ” Works even if arguments are provided in any order

</ul>
<div id="Hybrid - Positional &amp; Flags-Usage Examples"><h2 id="Usage Examples" class="header"><a href="#Hybrid - Positional &amp; Flags-Usage Examples">Usage Examples</a></h2></div>

<div id="Hybrid - Positional &amp; Flags-Usage Examples-Using Positional Arguments"><h3 id="Using Positional Arguments" class="header"><a href="#Hybrid - Positional &amp; Flags-Usage Examples-Using Positional Arguments">Using Positional Arguments</a></h3></div>

<pre sh>
source set_env.sh "MyShow" "Seq01" "Shot005"
</pre>
<p>
âœ” Sets SHOW, SEQ, and SHOT.
</p>

<pre sh>
source set_env.sh "MyShow"
</pre>
<p>
âœ” Sets SHOW, resets SEQ and SHOT to "None".
</p>

<pre sh>
source set_env.sh "Seq01" "Shot005"
</pre>
<p>
âœ” Since no SHOW was provided, it will default to "None".
</p>

<div id="Hybrid - Positional &amp; Flags-Usage Examples-Using Flags"><h3 id="Using Flags" class="header"><a href="#Hybrid - Positional &amp; Flags-Usage Examples-Using Flags">Using Flags</a></h3></div>

<pre sh>
source set_env.sh --show "MyShow" --seq "Seq01" --shot "Shot005"
</pre>
<p>
âœ” Explicitly sets variables.
</p>

<pre sh>
source set_env.sh --show "MyShow"
</pre>
<p>
âœ” Sets SHOW, resets lower values.
</p>

<pre sh>
source set_env.sh --seq "Seq01" --shot "Shot005"
</pre>
<p>
âœ” Since no SHOW was set, it defaults to "None".
</p>

<pre sh>
source set_env.sh "MyShow"
</pre>
<p>
âœ” Sets SHOW, resets SEQ and SHOT to "None".
</p>

<pre sh>
source set_env.sh "Seq01" "Shot005"
</pre>
<p>
âœ” Since no SHOW was provided, it will default to "None".
</p>

<div id="Hybrid - Positional &amp; Flags-Usage Examples-Using Flags-Using Flags"><h4 id="Using Flags" class="header"><a href="#Hybrid - Positional &amp; Flags-Usage Examples-Using Flags-Using Flags">Using Flags</a></h4></div>

<pre sh>
source set_env.sh --show "MyShow" --seq "Seq01" --shot "Shot005"
</pre>
<p>
âœ” Explicitly sets variables.
</p>

<pre sh>
source set_env.sh --show "MyShow"
</pre>
<p>
âœ” Sets SHOW, resets lower values.
</p>

<pre sh>
source set_env.sh --seq "Seq01" --shot "Shot005"
</pre>
<p>
âœ” Since no SHOW was set, it defaults to "None".
</p>

<div id="Hybrid - Positional &amp; Flags-Usage Examples-Why Use This Hybrid Approach?"><h3 id="Why Use This Hybrid Approach?" class="header"><a href="#Hybrid - Positional &amp; Flags-Usage Examples-Why Use This Hybrid Approach?">Why Use This Hybrid Approach?</a></h3></div>

<ul>
<li>
âœ… Positional arguments â†’ Quick, simple input. 

<li>
âœ… Flags (--show, --seq, --shot) â†’ More explicit control. 

<li>
âœ… Hierarchy auto-corrects itself, ensuring logical dependencies.

</ul>
<div id="Abbreviated Flags"><h1 id="Abbreviated Flags" class="header"><a href="#Abbreviated Flags">Abbreviated Flags</a></h1></div>

<ul>
<li>
Question: Is it possible to offer abbreviated flag options? (Like both --seq and -sq?)

<li>
Answer: Yes, you can absolutely support both long (--seq) and short (-sq) flag options in a Bash script! This is done using getopts, which allows you to define abbreviated versions of your flags.

</ul>
<p>
Updated Script with Abbreviated Flags
</p>

<pre bash>
#!/bin/bash

# Default values
SHOW=""
SEQ=""
SHOT=""

# Parse command-line flags with short (-sq, -sh) and long (--seq, --shot) options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -sh|--show)  # Support both -s and --show
            SHOW="$2"
            shift 2
            ;;
        -sq|--seq)  # Support both -sq and --seq
            SEQ="$2"
            shift 2
            ;;
        -s|--shot)  # Support both -sh and --shot
            SHOT="$2"
            shift 2
            ;;
        *)
            break  # Stop processing flags when encountering positional arguments
            ;;
    esac
done

# If no flags were used, capture positional arguments
if [[ -z "$SHOW" &amp;&amp; -n "$1" ]]; then SHOW="$1"; shift; fi
if [[ -z "$SEQ" &amp;&amp; -n "$1" ]]; then SEQ="$1"; shift; fi
if [[ -z "$SHOT" &amp;&amp; -n "$1" ]]; then SHOT="$1"; shift; fi

# Apply hierarchy logic
if [[ -n "$SHOW" &amp;&amp; -z "$SEQ" &amp;&amp; -z "$SHOT" ]]; then
    SEQ="None"
    SHOT="None"
elif [[ -z "$SHOW" &amp;&amp; -n "$SEQ" &amp;&amp; -n "$SHOT" ]]; then
    SHOW="None"
fi

# Construct directory path
HOME_DIR="$HOME"
DIRECTORY_PATH="$HOME_DIR/projects/$SHOW/$SEQ/$SHOT"

# Set environment variables
export SHOW
export SEQ
export SHOT

echo "SHOW: $SHOW"
echo "SEQ: $SEQ"
echo "SHOT: $SHOT"
echo "Generated directory path: $DIRECTORY_PATH"

# Optional: Create the directory if it doesnâ€™t exist
mkdir -p "$DIRECTORY_PATH"
</pre>

<div id="Abbreviated Flags-Now You Can Use:"><h4 id="Now You Can Use:" class="header"><a href="#Abbreviated Flags-Now You Can Use:">Now You Can Use:</a></h4></div>

<p>
âœ… Long Flags:
</p>

<pre sh>
source set_env.sh --show "MyShow" --seq "Seq01" --shot "Shot005"
</pre>

<p>
âœ… Abbreviated Flags:
</p>

<pre sh>
source set_env.sh -sh "MyShow" -sq "Seq01" -s "Shot005"
</pre>

<p>
âœ… Positional Arguments Still Work:
</p>

<pre sh>
source set_env.sh "MyShow" "Seq01" "Shot005"
</pre>

<div id="Abbreviated Flags-Why Use Both?"><h4 id="Why Use Both?" class="header"><a href="#Abbreviated Flags-Why Use Both?">Why Use Both?</a></h4></div>

<ul>
<li>
âœ” Users who prefer clarity can use <code>--seq</code>. 

<li>
âœ” Users who prefer speed can use <code>-sq</code>. 

<li>
âœ” Supports both structured and flexible workflows.

</ul>
<p>
<a href="shell_and_bash.html">Shell and Bash</a> 
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
