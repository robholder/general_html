<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>houdini_personal_notes_dji_from_blender</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="Houdini.html">Houdini</a>
</p>


<div id="Personal Notes"><h1 id="Personal Notes" class="header"><a href="#Personal Notes">Personal Notes</a></h1></div>


<div id="Personal Notes-Issues"><h2 id="Issues" class="header"><a href="#Personal Notes-Issues">Issues</a></h2></div>

<p>
I tried FBX and USD as a means to import the model from Blender.
</p>

<p>
I ended up looking at the USD solution
</p>
<ul>
<li>
The USD came into Solaris OK, but I wanted to have control over the parts to re-rig and be able to edit in Houdini.

<li>
In the OBJ Context:

<ul>
<li>
I brought the USD file in with a <code>USD Import</code> node

<li>
Added an <code>Attribute Rename</code> node:

<ul>
<li>
<code>Point</code> tab:

<ul>
<li>
<code>Attribute From/To</code> to <code>UVMap</code> to <code>uv</code>

</ul>
<li>
<code>Primitive</code> tab:

<ul>
<li>
<code>Attribute From/To</code> to <code>name</code> to <code>part</code>

<li>
This copied the imported part names to a spare attribute, and allowed the following nodes (<code>Assemble</code>) to use the 'name' attribute. 

<li>
I can use this Blender name attribute (now <code>part</code>) to rename the items at end of the process (so I can recreate the hierarchy in Houdini).

</ul>
</ul>
<li>
Next, I dropped an <code>Assemble</code> node to split up the meshes:

<ul>
<li>
Checked <code>Create Groups</code>

<li>
Unchecked <code>Connect Inside Edges</code> (but there was no reason for this)

</ul>
</ul>
</ul>
<p>
From here
</p>
<ul>
<li>
In 'selection' mode (viewport), I set the <code>Select</code> dropdown on the Viewport top bar to <code>Geometry Groups</code>.

<li>
This shows a HUD with all the groups in a list:

<ul>
<li>
They appear as <code>piece###</code> ('piece0' to 'piece448' in my case).

</ul>
</ul>
<p>
I then had a chain of nodes to:
</p>
<ul>
<li>
Isolate the parts (like propeller, foot, motor etc):

<ul>
<li>
I used a <code>Blast</code> node for each of the parts (using the <code>piece##</code> attribute) set to delete unselected

</ul>
</ul>
<p>
Some of the parts of the model were made using the 'mirror' tool in Blender ,and apparently, this can screw up normals in such a way that most software can't fix them. I have to compromise and get them to look decent (even though some of the polys never get 'cured').
</p>

<p>
There's a node called <code>Polydoctor</code>, but it was too destructive for my case, and I used a <code>Clean</code> node instead:
</p>
<ul>
<li>
<code>Clean</code>:

<ul>
<li>
<code>Remove Degenerate Primitives</code> set to <code>Off</code>

<li>
<code>Reverse Winding</code> to <code>On</code>

<li>
All other settings to 'default'

</ul>
<li>
This seemed to fix most items (although something's amiss with the Blender normals when formed on mirrored geometry.

</ul>
<p>
Next, I added a <code>Stash</code> node, to essentially 'bake' the meshes. (This should be like other software meshes with no history.)
</p>

<div id="Personal Notes-Issues-Diagram - USD Import, through to separation of 'parts'"><h4 id="Diagram - USD Import, through to separation of 'parts'" class="header"><a href="#Personal Notes-Issues-Diagram - USD Import, through to separation of 'parts'">Diagram - USD Import, through to separation of 'parts'</a></h4></div>

<pre>
                     ┌────────────┐
                     │ USD Import │     From Blender
                     └──────┬─────┘
                            │
                  ┌─────────┴─────────┐   Point: UVMap --&gt; uv
                  │ Attribute Rename  │
                  └─────────┬─────────┘   Primitive: name --&gt; part
                            │
                      ┌─────┴─────┐
                      │  Assemble │    Create Groups On
                      └─────┬─────┘
                            │
            ┌───────────────┴────────────────────┐
            │                                    │
┌───────────┴─────────────┐          ┌───────────┴─────────────┐
│         Blast           │          │         Blast           │
│ (set to 'name' as Group)│          │ (set to 'name' as Group)│   'name' as in the Assemble
│   Delete Non Selected   │          │   Delete Non Selected   │        name ('piece###')
└───────────┬─────────────┘          └───────────┬─────────────┘
            │                                    │
    ┌───────┴─────────┐                  ┌───────┴─────────┐
    │     Clean       │                  │     Clean       │
    │ Reverse Winding │                  │ Reverse Winding │
    └───────┬─────────┘                  └───────┬─────────┘
            │                                    │
            │                                    │
 ┌──────────┴─────────────┐           ┌──────────┴─────────────┐
 │         Stash          │           │         Stash          │
 │(renamed to 'part' name)│           │(renamed to 'part' name)│
 └────────────────────────┘           └────────────────────────┘
</pre>

<div id="Personal Notes-Issues-Python To Separate Meshes"><h3 id="Python To Separate Meshes" class="header"><a href="#Personal Notes-Issues-Python To Separate Meshes">Python To Separate Meshes</a></h3></div>
<p>
This script originated with Copilot's advice on getting the piece numbers (items) from an assemble node:
</p>


<pre>
#####################################################################################
# Description:
# Specifically for re-building the DJI Inspire model as built in Blender and
# imported to Houdini as a USDImport.
#
# Created by Rob Holder
#
## ## Add to shelf button:
## import importlib
## import assemble_parts
##
## importlib.reload(assemble_parts)
## assemble_parts.main()
#


__author__ = "Rob Holder"
__date__ = "25/02/09"
__version__ = "0.0.1"


import hou
import re


# Function to extract the numerical part of the string for sorting
def sort_key(s):
    match = re.match(r'([a-zA-Z]+)(\d+)', s)
    if match:
        stem, num = match.groups()
        return (stem, int(num))
    return (s, 0)

def main():
    # Get the assemble node
    assemble_node = hou.node('/obj/geo1/assemble1')
    # Get the parent network where you want to create the nodes
    parent_container = assemble_node.parent()


    # Check if the node exists
    if not assemble_node:
        print("Node not found")
    else:
        # Get the output geometry
        output_geo = assemble_node.geometry()

        # Check if the geometry exists
        if not output_geo:
            print("Geometry not found")
        else:
            # Get the 'name' attribute values
            name_values = output_geo.primStringAttribValues('name')
            print(name_values)
            # Check if the 'name' attribute values exist
            if not name_values:
                print("No 'name' values found")

            else:
                # Convert the tuple of values to a set to remove duplicates
                unique_values = set(name_values)

                # Sort the list using the custom sort key
                sorted_values = sorted(unique_values, key=sort_key)
                print(sorted_values)
                print(len(sorted_values))

                stash_nodes = list()

                for value in sorted_values:

                    # Create a 'blast' node
                    blast_node = parent_container.createNode('blast', node_name=f'blast_{value}')
                    # Connect the blast node to the assemble node
                    blast_node.setInput(0, assemble_node)
                    # Set the 'Group' parameter
                    blast_node.parm('group').set(value)
                    blast_node.parm('negate').set(True)
                    print("blast_node created")

                    # Create a 'clean' node
                    clean_node = parent_container.createNode('clean', node_name=f'clean_{value}')
                    # Connect the clean node to the blast node
                    clean_node.setInput(0, blast_node)
                    # Check the 'Reverse Winding' option
                    clean_node.parm('reversewinding').set(True)
                    # Set 'bypass' to off
                    clean_node.bypass(True)
                    print(f'clean node created')

                    # Evaluate the geometry of the blast node to get the 'part' attribute value
                    blast_geo = blast_node.geometry()
                    part_attrib = blast_geo.findPrimAttrib('part')
                    if not part_attrib:
                        print("No 'part' values found")
                        break

                    else:
                        part_value = blast_geo.prim(0).stringAttribValue(part_attrib.name())

                        # Create a 'stash' node
                        stash_node = parent_container.createNode('stash', node_name=f'stash_{part_value}')
                        # Connect the clean node to the stash node
                        stash_node.setInput(0, clean_node)
                        # Activate the 'Stash Input' button
                        stash_node.parm('stashinput').pressButton()

                        # Add the stash node to the list
                        stash_nodes.append(stash_node)

                        # Layout the nodes for better visibility
                        #parent_container.layoutChildren()

                # Create a 'merge' node
                merge_node = parent_container.createNode('merge', node_name='merge_all_stash_nodes')

                # Connect all stash nodes to the merge node
                for i, stash_node in enumerate(stash_nodes):
                    merge_node.setInput(i, stash_node)


                # Layout the parent network nodes for better visibility
                parent_container.layoutChildren()


#print("LOADED")

if __name__ == "__main__":
    main()

</pre>

<div id="Personal Notes-Issues-Python To Separate Meshes-A lot of my meshes had flipped normals"><h4 id="A lot of my meshes had flipped normals" class="header"><a href="#Personal Notes-Issues-Python To Separate Meshes-A lot of my meshes had flipped normals">A lot of my meshes had flipped normals</a></h4></div>
<p>
<a href="https://www.youtube.com/watch?v=ICZv_u65hH8">YouTube - Houdini - Reversing &amp; Correcting Normals in Houdini</a>
</p>



<div id="Personal Notes-Issues-Python To Separate Meshes-Directly from Copilot"><h4 id="Directly from Copilot" class="header"><a href="#Personal Notes-Issues-Python To Separate Meshes-Directly from Copilot">Directly from Copilot</a></h4></div>
<pre>
import hou
import re

# Function to extract the numerical part of the string for sorting
def sort_key(s):
    match = re.match(r'([a-zA-Z]+)(\d+)', s)
    if match:
        stem, num = match.groups()
        return (stem, int(num))
    return (s, 0)

# List of 'name' attributes from the assemble node
name_values = ['value1', 'value20', 'value3', 'value100', 'value2']

# Sort the list using the custom sort key
sorted_values = sorted(name_values, key=sort_key)

# Get the parent container of the assemble node
assemble_node = hou.node('/obj/your_assemble_node')
parent_network = assemble_node.parent()

# Loop through the sorted values and create nodes
for value in sorted_values:
    # Create a 'blast' node
    blast_node = parent_network.createNode('blast', node_name=f'blast_{value}')
    # Set the 'Group' parameter
    blast_node.parm('group').set(value)
    
    # Create a 'clean' node
    clean_node = parent_network.createNode('clean', node_name=f'clean_{value}')
    # Connect the blast node to the clean node
    clean_node.setInput(0, blast_node)
    # Check the 'Reverse Winding' option
    clean_node.parm('reversewinding').set(True)
    # Set 'bypass' flag to off
    clean_node.bypass(True)
    
    # Evaluate the geometry of the blast node to get the 'part' attribute value
    blast_geo = blast_node.geometry()
    part_attrib = blast_geo.findPrimAttrib('part')
    part_value = blast_geo.prim(0).stringAttribValue(part_attrib.name())
    
    # Create a 'stash' node with the 'part' attribute value as the suffix
    stash_node = parent_network.createNode('stash', node_name=f'stash_{part_value}')
    # Connect the clean node to the stash node
    stash_node.setInput(0, clean_node)
    # Activate the 'Stash Input' button
    stash_node.parm('stashinput').pressButton()
    
    # Add the stash node to the list
    stash_nodes.append(stash_node)
    
    # Layout the nodes for better visibility
    parent_network.layoutChildren()

# Create a 'merge' node
merge_node = parent_network.createNode('merge', node_name='merge_all_stash_nodes')

# Connect all stash nodes to the merge node
for i, stash_node in enumerate(stash_nodes):
    merge_node.setInput(i, stash_node)

# Layout the parent network nodes for better visibility
parent_network.layoutChildren()
</pre>

</body>
</html>
