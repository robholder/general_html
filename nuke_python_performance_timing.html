<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_python_performance_timing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="Performance Timings"><h1 id="Performance Timings" class="header"><a href="#Performance Timings">Performance Timings</a></h1></div>

<div id="Performance Timings-External Links"><h2 id="External Links" class="header"><a href="#Performance Timings-External Links">External Links</a></h2></div>

<ul>
<li>
<a href="https://support.foundry.com/hc/en-us/articles/206510844-Q100225-Profiling-your-Nuke-script-to-isolate-performance-issues">Performance article</a>

<li>
<a href="https://learn.foundry.com/nuke/content/comp_environment/organizing_scripts/using_performance_timingscript_profiling.html">Performance Guide</a>

<li>
<a href="https://splitthediff.com/performance-timers/">SplitTheDiff - Performance-Timers article</a>

</ul>
<div id="Performance Timings-YouTube"><h2 id="YouTube" class="header"><a href="#Performance Timings-YouTube">YouTube</a></h2></div>

<ul>
<li>
<a href="https://www.youtube.com/watch?v=U0f_MCb-GZc">Nuke Timeout - EP03 - Performance Timers</a>

<li>
<a href="https://www.youtube.com/watch?v=eZo05U04WBg">Nuke Timeout - EP04 - Profile Node</a>

</ul>
<div id="Performance Timings-Notes"><h2 id="Notes" class="header"><a href="#Performance Timings-Notes">Notes</a></h2></div>

<ul>
<li>
Commandline launching:

<ul>
<li>
Add <code>-P</code> to switch on performance monitoring

<li>
Add -Pf &lt;file path and name&gt;.xml to export XML reports (when rendering)

</ul>
<li>
Scripting Python commands:

<ul>
<li>
<code>nuke.startPerformanceTimers()</code> # Enable performance timing

<li>
<code>nuke.usingPerformanceTimers()</code> # Start performance timers

<li>
<code>nuke.stopPerformanceTimers()</code> # Turn off performance timers

<li>
<code>nuke.resetPerformanceTimers()</code> # Reset all timers to zero

</ul>
<li>
Obtain performance Timing via Python:

</ul>
  
<pre python>
for n in nuke.allNodes(recurseGroups = True):
    print n.fullName()
    print n.performanceInfo()
</pre>

<p>
The output from this will look similar to the following output, for a simple tree consisting of Checkerboard -&gt; Blur -&gt; Defocus -&gt; Viewer:
</p>

<pre text>
Defocus1
{'callCount': 10228, 'timeTakenWall': 28524348, 'timeTakenCPU': 624512794}
Blur1
{'callCount': 9607, 'timeTakenWall': 9906815, 'timeTakenCPU': 151406143}
Viewer1
{'callCount': 0, 'timeTakenWall': 0, 'timeTakenCPU': 0}
CheckerBoard1
{'callCount': 34396, 'timeTakenWall': 3923322, 'timeTakenCPU': 29982254}
</pre>

<p>
As you can see from the above, nuke.Node.performanceInfo() returns a dictionary containing the following performance statistics:
</p>
<ul>
<li>
callCount tells you the number of times this part of the processing has been called.

<li>
timeTakenWall is the time taken as it would be measured by a clock on the wall, i.e. the actual time a user would have to wait for the processing to complete. This time is measured in microseconds.

<li>
timeTakenCPU:

</ul>
<p>
On Linux, this is the time the CPU spent executing the processing code, and again is measured in microseconds. It is an aggregate over all CPU threads so, for example, for the multi-threaded engine processing this will typically be much larger than the wall time. If the average CPU time per thread (timeTakenCPU divided by the number of threads used) is much shorter than the wall time, this suggests that the CPU threads have spent a lot of time not executing code - for example, waiting on locks - and could indicate a performance problem.
</p>

<p>
If we look again at the timings for the two most expensive nodes, the Blur and the Defocus:
</p>

<pre text>
Defocus1
{'callCount': 10228, 'timeTakenWall': 28524348, 'timeTakenCPU': 624512794}
Blur1
{'callCount': 9607, 'timeTakenWall': 9906815, 'timeTakenCPU': 151406143}
</pre>

<p>
...we can see that while the Blur node’s CPU time is fairly close to being 24 times as long as its wall time, the Defocus node’s CPU time is only two-thirds as long as we might expect. This shows us that the engine threads are all being kept busy by the Blur node, while in the Defocus node they are spending a considerable amount of their time waiting in this script
</p>

<div id="Writing Performance Information to an XML File"><h1 id="Writing Performance Information to an XML File" class="header"><a href="#Writing Performance Information to an XML File">Writing Performance Information to an XML File</a></h1></div>

<p>
Finally, note that the above performance information will automatically be written to an XML file when Nuke is run with “-Pf &lt;filename&gt;”, along with some information about your system. In this mode, performance timers will be started before a render and the timings output to the requested file in XML format once the render is complete. When Nuke is run in this mode, calling:
</p>

<pre python>
nuke.performanceProfileFilename()
</pre>

<p>
...will return the full path to the XML profile file.
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
