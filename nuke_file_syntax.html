<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_file_syntax</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<ul>
<li>
<a href="nuke_index.html">Nuke Index</a>

<li>
<a href="vim_learning.html">Vim Learning</a>

</ul>
<div id="Nuke File Syntax"><h1 id="Nuke File Syntax" class="header"><a href="#Nuke File Syntax">Nuke File Syntax</a></h1></div>

<p>
A Nuke scene file (.nk) is fundamentally a text file written using Tcl (Tool Command Language) syntax. It captures all node relationships and their parameter values in a hierarchical structure. 
</p>

<p>
A Nuke script is:
</p>
<ul>
<li>
a static description

<li>
a snapshot of the node graph

<li>
a declarative representation

<li>
not a dynamic program

</ul>
<p>
This snapshot paradigm helps to realize, the format is a descriptive list rather than a prescriptive script.
</p>

<div id="Nuke File Syntax-Core Syntax Elements"><h2 id="Core Syntax Elements" class="header"><a href="#Nuke File Syntax-Core Syntax Elements">Core Syntax Elements</a></h2></div>

<ul>
<li>
<span id="Nuke File Syntax-Core Syntax Elements-Node Definition"></span><strong id="Node Definition">Node Definition</strong>: Each node begins with its class name, followed by curly braces {} containing its parameters and connections. The Root node is at the top level of every script.

</ul>
  
<pre tcl>
Root {
 # Root node parameters go here
}
</pre>

<ul>
<li>
<span id="Nuke File Syntax-Core Syntax Elements-Parameters (Knobs)"></span><strong id="Parameters (Knobs)">Parameters (Knobs)</strong>: Node parameters, referred to as "knobs" in Nuke, are defined within the node's braces using the format parameter_name value. String values may require quotes if they contain spaces.

</ul>
  
<pre tcl>
ColorBars {
 inputs 0
 name ColorBars1
}
</pre>
  
<ul>
<li>
<span id="Nuke File Syntax-Core Syntax Elements-Connections"></span><strong id="Connections">Connections</strong>: Node connections are managed via a stack system using set and push commands, though these are often abstracted in a saved .nk file by the inputs keyword.

</ul>
  
<pre tcl>
Read {
 file "/path/to/my/footage.####.exr"
 # other parameters
}
# This push command puts the Read node onto the stack for the next node to use as input
push 0 
Merge2 {
 inputs 2
 # Input A is empty/nothing pushed, Input B is the Read node that was just pushed
}
</pre>
  
<ul>
<li>
<span id="Nuke File Syntax-Core Syntax Elements-Groups"></span><strong id="Groups">Groups</strong>: Group nodes (Group {}) contain their own nested structure and form new group stacks. The end_group keyword marks the end of a group definition.

</ul>
  
<pre tcl>
Group {
 name Group1
 Input { inputs 0 }
 Output { name Output1 }
}
end_group 
</pre>

<ul>
<li>
<span id="Nuke File Syntax-Core Syntax Elements-Tcl Expressions"></span><strong id="Tcl Expressions">Tcl Expressions</strong>: Nuke allows Tcl expressions to be used in nearly any knob field to create dynamic links and automation. Square brackets [] trigger Tcl evaluation within a knob's value.

<li>
<code>[value knob_name]</code> retrieves the value of a knob. For example, [value root.name] returns the current script's full path and name.

<li>
<code>[file dirname [value root.name]]</code> uses Tcl's file command to extract the directory name from the current script's path.

<li>
<code>####</code> or <code>%04d</code> is used in file paths as a variable for the frame number, padded to four digits. 

</ul>
<div id="Nuke File Syntax-Key Characteristics"><h2 id="Key Characteristics" class="header"><a href="#Nuke File Syntax-Key Characteristics">Key Characteristics</a></h2></div>

<ul>
<li>
<span id="Nuke File Syntax-Key Characteristics-Human-Readable"></span><strong id="Human-Readable">Human-Readable</strong>: Nuke scripts are designed to be read, edited, and even generated with a simple text editor.

<li>
<span id="Nuke File Syntax-Key Characteristics-Context-Aware"></span><strong id="Context-Aware">Context-Aware</strong>: Tcl commands in Nuke are context-aware, allowing them to reference other nodes or script properties using commands like [topnode], [thisNode], or [metadata]. 

</ul>
<div id="The Stack System"><h1 id="The Stack System" class="header"><a href="#The Stack System">The Stack System</a></h1></div>

<p>
In Nuke’s .nk (Tcl-based) files, the "stack" is a Last-In, First-Out (LIFO) mechanism used to manage node connections as the file is read sequentially from top to bottom. 
</p>

<div id="How the Stack Works"><h1 id="How the Stack Works" class="header"><a href="#How the Stack Works">How the Stack Works</a></h1></div>

<p>
When Nuke processes a script, it maintains a temporary list (the stack) of nodes that are "active" and available to be connected. 
</p>
<ul>
<li>
<span id="How the Stack Works-Node Creation"></span><strong id="Node Creation">Node Creation</strong>: When Nuke encounters a node definition (e.g., Blur { ... }), it creates that node and immediately pushes it onto the top of the stack.

<li>
<span id="How the Stack Works-Input Consumption"></span><strong id="Input Consumption">Input Consumption</strong>: If the next node in the file requires inputs (e.g., inputs 1), Nuke pops (removes) the required number of nodes from the top of the stack and connects them to the new node's inputs.

<li>
<span id="How the Stack Works-Result Replacement"></span><strong id="Result Replacement">Result Replacement</strong>: After connecting, the new node is pushed onto the stack, becoming the new "top" item for the next node to use. 

</ul>
<div id="How the Stack Works-The Role of set and push"><h3 id="The Role of set and push" class="header"><a href="#How the Stack Works-The Role of set and push">The Role of set and push</a></h3></div>

<p>
These commands allow Nuke to handle complex branching or non-linear connections that a simple sequential stack cannot manage alone. 
</p>
<ul>
<li>
<code>set [Variable] [stack 0]</code>: This command "remembers" a node. It takes the node currently at the top of the stack (stack 0) and assigns it to a Tcl variable (usually a unique ID like N1a2b3c4). This does not remove the node from the stack.

<ul>
<li>
In other words, it references the node currently at index 0 (<code>[stack 0]</code>), and assigns it to a variable (<code>set &lt;variable&gt; [stack 0]</code>).

</ul>
<li>
<code>push $[Variable]</code>: This command retrieves a previously "set" node and places a reference to it back on the top of the stack. This is how Nuke handles branches, such as a single Read node feeding into two different Grade nodes.

<li>
<code>push 0</code>: This clears the stack (or pushes a "null" entry), ensuring the next node created does not automatically connect to whatever was previously on top. 

</ul>
<div id="How the Stack Works-The Role of set and push-Note on 'clear the stack'"><h4 id="Note on 'clear the stack'" class="header"><a href="#How the Stack Works-The Role of set and push-Note on 'clear the stack'">Note on 'clear the stack'</a></h4></div>

<p>
In a Nuke .nk file, push 0 inserts a "null" or "empty" entry onto the stack; it does not clear the entire stack. 
</p>

<p>
While some legacy documentation colloquially refers to it as "clearing" the stack, its function within the Tcl parser is to manage specific input indices. 
</p>

<div id="How the Stack Works-Group Hierarchy and the Stack"><h3 id="Group Hierarchy and the Stack" class="header"><a href="#How the Stack Works-Group Hierarchy and the Stack">Group Hierarchy and the Stack</a></h3></div>

<p>
Nuke uses a separate stack for every Group or LiveGroup. 
</p>

<ul>
<li>
<span id="How the Stack Works-Group Hierarchy and the Stack-Starting a Group"></span><strong id="Starting a Group">Starting a Group</strong>: Encountering Group { ... } creates a new, empty stack for that group's internal nodes.

<li>
<span id="How the Stack Works-Group Hierarchy and the Stack-end_group"></span><strong id="end_group">end_group</strong>: This keyword signals the end of the group's internal node list. It collapses the group's internal stack and pushes the Group node itself onto the parent's stack. 

</ul>
<div id="How the Stack Works-More on Push"><h2 id="More on Push" class="header"><a href="#How the Stack Works-More on Push">More on Push</a></h2></div>

<p>
In a Nuke .nk file, the command push 0 is used to push a "null" or "empty" slot onto the connection stack. 
</p>

<p>
This is a critical flow-control tool that serves two primary purposes:
</p>

<div id="How the Stack Works-More on Push-How push 0 Operates on the Stack"><h4 id="How push 0 Operates on the Stack" class="header"><a href="#How the Stack Works-More on Push-How push 0 Operates on the Stack">How push 0 Operates on the Stack</a></h4></div>

<p>
Nuke maintains a Last-In, First-Out (LIFO) stack where the most recently created or pushed item is at index 0. 
</p>
<ul>
<li>
<span id="How the Stack Works-More on Push-How push 0 Operates on the Stack-Inserting a Placeholder"></span><strong id="Inserting a Placeholder">Inserting a Placeholder</strong>: When Nuke executes push 0, it adds an "empty" slot to the top of the stack (index 0).

<li>
<span id="How the Stack Works-More on Push-How push 0 Operates on the Stack-Shifting Indices"></span><strong id="Shifting Indices">Shifting Indices</strong>: Any existing nodes on the stack are shifted down. What was at index 0 moves to index 1, and so on.

<li>
<span id="How the Stack Works-More on Push-How push 0 Operates on the Stack-Input Consumption"></span><strong id="Input Consumption">Input Consumption</strong>: When a node with inputs 2 is created, it pops the two topmost items from the stack to fill its inputs.

<ul>
<li>
If the stack is [0, Read1], the node's Input A (index 0) connects to the "null" entry, and Input B (index 1) connects to Read1. 

</ul>
</ul>
<div id="How the Stack Works-More on Push-Why this distinction matters for troubleshooting"><h4 id="Why this distinction matters for troubleshooting" class="header"><a href="#How the Stack Works-More on Push-Why this distinction matters for troubleshooting">Why this distinction matters for troubleshooting</a></h4></div>

<p>
If push 0 actually cleared the stack, you could never have a node with multiple inputs where one input is empty but the other is connected. By pushing a "null" entry, Nuke precisely controls which node connects to which specific pipe (A, B, Mask, etc.). 
</p>

<table>
<tr>
<td>
<span id="How the Stack Works-More on Push-Why this distinction matters for troubleshooting-Command"></span><strong id="Command">Command</strong>
</td>
<td>
<span id="How the Stack Works-More on Push-Why this distinction matters for troubleshooting-Effect on Stack"></span><strong id="Effect on Stack">Effect on Stack</strong>
</td>
</tr>
<tr>
<td>
Node definition
</td>
<td>
Creates node, pops required inputs, then pushes itself to the top.
</td>
</tr>
<tr>
<td>
push $Var
</td>
<td>
Pushes a reference to a specific node onto the top.
</td>
</tr>
<tr>
<td>
push 0
</td>
<td>
Pushes a "null" entry onto the top.
</td>
</tr>
<tr>
<td>
pop
</td>
<td>
Removes items from the top of the stack.
</td>
</tr>
</table>

<ul>
<li>
<span id="How the Stack Works-More on Push-Why this distinction matters for troubleshooting-Repair Tip"></span><strong id="Repair Tip">Repair Tip</strong>: If a file is corrupt because a Merge node has the wrong inputs, check for an extra or missing push 0 just before the node definition. Adding a push 0 will "bump" the intended node from Input A to Input B.

</ul>
<div id="How the Stack Works-More on Push-1. Breaking the Chain (Isolation)"><h3 id="1. Breaking the Chain (Isolation)" class="header"><a href="#How the Stack Works-More on Push-1. Breaking the Chain (Isolation)">1. Breaking the Chain (Isolation)</a></h3></div>

<p>
By default, Nuke nodes are "greedy"—they automatically try to connect to whatever node is currently at the top of the stack. If you want to create a new node (like a second Read node) that should not connect to the previous node, you use push 0 to clear the "active" connection slot. 
</p>
<ul>
<li>
<span id="How the Stack Works-More on Push-1. Breaking the Chain (Isolation)-Without push 0"></span><strong id="Without push 0">Without push 0</strong>: The next node with inputs will automatically latch onto the previous node.

<li>
<span id="How the Stack Works-More on Push-1. Breaking the Chain (Isolation)-With push 0"></span><strong id="With push 0">With push 0</strong>: The stack now has an "empty" entry at index 0. The next node created will see this empty slot and start its own independent branch. 

</ul>
<div id="How the Stack Works-More on Push-2. Managing Specific Input Ports"><h3 id="2. Managing Specific Input Ports" class="header"><a href="#How the Stack Works-More on Push-2. Managing Specific Input Ports">2. Managing Specific Input Ports</a></h3></div>

<p>
For nodes with multiple inputs (like a Merge node with A and B pipes), push 0 is used to skip a specific input. 
</p>

<ul>
<li>
<span id="How the Stack Works-More on Push-2. Managing Specific Input Ports-Example"></span><strong id="Example">Example</strong>: If you want to connect a node to a Merge’s Input B but leave Input A disconnected, the script will:

<ul>
<li>
<code>push $NodeForB</code> (puts the node on the stack).

<li>
<code>push 0</code> (puts an "empty" slot at the very top of the stack).

<li>
<code>Merge { inputs 2 }</code> (Nuke pops the top item—the empty slot—for Input 0/A, and then pops the next item—the actual node—for Input 1/B). 

</ul>
</ul>
<div id="How the Stack Works-More on Push-Why it Matters for Fixing Corrupt Files"><h3 id="Why it Matters for Fixing Corrupt Files" class="header"><a href="#How the Stack Works-More on Push-Why it Matters for Fixing Corrupt Files">Why it Matters for Fixing Corrupt Files</a></h3></div>

<p>
If you are manually repairing a broken .nk file:
</p>
<ul>
<li>
<span id="How the Stack Works-More on Push-Why it Matters for Fixing Corrupt Files-Too many push 0 commands"></span><strong id="Too many push 0 commands">Too many push 0 commands</strong>: Can cause subsequent nodes to lose their intended connections, resulting in "disconnected" nodes in the DAG.

<li>
<span id="How the Stack Works-More on Push-Why it Matters for Fixing Corrupt Files-Missing push 0 commands"></span><strong id="Missing push 0 commands">Missing push 0 commands</strong>: Will cause nodes to connect to the wrong things, often creating massive "snakes" of nodes that should be separate branches.

<li>
<span id="How the Stack Works-More on Push-Why it Matters for Fixing Corrupt Files-Variable Missing"></span><strong id="Variable Missing">Variable Missing</strong>: If you see an error like can't read "N...": no such variable, you can sometimes temporarily replace that push $Variable with a push 0 just to get the script to open so you can manually reconnect the pipe in the GUI. 

</ul>
<div id="How the Stack Works-Debugging and Fixing Corrupt Files"><h2 id="Debugging and Fixing Corrupt Files" class="header"><a href="#How the Stack Works-Debugging and Fixing Corrupt Files">Debugging and Fixing Corrupt Files</a></h2></div>

<p>
Understanding this logic is essential for manual repairs:
</p>

<ul>
<li>
<span id="How the Stack Works-Debugging and Fixing Corrupt Files-Missing end_group"></span><strong id="Missing end_group">Missing end_group</strong>: If this keyword is missing, Nuke will continue to treat every subsequent node in the file as if it belongs inside that Group. To fix, locate the node that should be the last one in the group and insert end_group immediately after it.

<li>
<span id="How the Stack Works-Debugging and Fixing Corrupt Files-can't read [Variable]"></span><strong id="can't read [Variable]">can't read [Variable]</strong>: no such variable: This happens when a push $Variable command appears before its corresponding set Variable command, or if the set command was deleted. You can often fix this by finding the intended source node, adding set [MissingVariableName] [stack 0] after it, or by changing the push command to reference a known node name.

<li>
<span id="How the Stack Works-Debugging and Fixing Corrupt Files-Divide and Conquer"></span><strong id="Divide and Conquer">Divide and Conquer</strong>: If a script fails to open, you can copy-paste chunks of the text file into a fresh Nuke session. When a chunk fails, you have isolated the specific nodes or stack commands causing the corruption.

</ul>
<div id="Another Run Through the Stack (and Set &amp; Push)"><h1 id="Another Run Through the Stack (and Set &amp; Push)" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)">Another Run Through the Stack (and Set &amp; Push)</a></h1></div>

<p>
In the .nk file syntax, the nodes are listed sequentially. Because the Merge node uses the LIFO (Last-In, First-Out) stack to assign inputs, the order in which they appear in the text dictates which node becomes "A" and which becomes "B."
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure"><h2 id="The .nk Syntax Structure" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure">The .nk Syntax Structure</a></h2></div>

<p>
Here is how that specific setup would be written in the script:
</p>

<pre tcl>
CheckerBoard2 {
 inputs 0
 name CheckerBoard1
 xpos -200
 ypos -150
}
ColorWheel {
 inputs 0
 name ColorWheel1
 xpos 0
 ypos -150
}
Merge2 {
 inputs 2
 name Merge1
 xpos -100
 ypos -50
}
</pre>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How the Stack Decides the Inputs"><h3 id="How the Stack Decides the Inputs" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How the Stack Decides the Inputs">How the Stack Decides the Inputs</a></h3></div>

<p>
When Nuke reads this text, it follows the "Node-Node-Pop" logic we discussed:
</p>

<ul>
<li>
<span id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How the Stack Decides the Inputs-Line 1 (CheckerBoard)"></span><strong id="Line 1 (CheckerBoard)">Line 1 (CheckerBoard)</strong>: Nuke creates the CheckerBoard and pushes it onto the stack.

<li>
<span id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How the Stack Decides the Inputs-Line 7 (ColorWheel)"></span><strong id="Line 7 (ColorWheel)">Line 7 (ColorWheel)</strong>: Nuke creates the ColorWheel and pushes it onto the stack. The stack now looks like: [CheckerBoard1, ColorWheel1].

<li>
<span id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How the Stack Decides the Inputs-Line 13 (Merge2)"></span><strong id="Line 13 (Merge2)">Line 13 (Merge2)</strong>: The Merge node sees inputs 2.

<ul>
<li>
It pops the top item (ColorWheel1) and assigns it to Input B (the primary input).

<li>
It pops the next item (CheckerBoard1) and assigns it to Input A.

</ul>
</ul>
<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Why B is &quot;Top&quot; and A is &quot;Bottom&quot;"><h3 id="Why B is &quot;Top&quot; and A is &quot;Bottom&quot;" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Why B is &quot;Top&quot; and A is &quot;Bottom&quot;">Why B is "Top" and A is "Bottom"</a></h3></div>

<p>
In Nuke's internal logic, the B input is considered the main flow of the stack, while the A input is the "add-on." Therefore, the very last node created before the Merge is always grabbed first and assigned to B.
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-What if you wanted to flip them?"><h3 id="What if you wanted to flip them?" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-What if you wanted to flip them?">What if you wanted to flip them?</a></h3></div>

<p>
If you wanted the CheckerBoard to be the B input and the ColorWheel to be the A input, you would simply swap their positions in the text file:
</p>
<ul>
<li>
List the ColorWheel first (pushes to stack).

<li>
List the CheckerBoard second (pushes to top of stack).

<li>
The Merge then pops the CheckerBoard as B and the ColorWheel as A.

</ul>
<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Summary of the &quot;A/B&quot; Stack Rule"><h3 id="Summary of the &quot;A/B&quot; Stack Rule" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Summary of the &quot;A/B&quot; Stack Rule">Summary of the "A/B" Stack Rule</a></h3></div>

<ul>
<li>
The last node before the Merge = Input B.

<li>
The second-to-last node before the Merge = Input A.

<li>
The third-to-last node before the Merge = Input Mask (if inputs 3 is specified).
<table>
<tr>
<td>
Would you like to see what happens to the syntax if you manually "offset" the pipes using a push command?
</td>
</tr>
</table>

</ul>
<p>
In a Nuke script, set and push are the commands that transform a simple "stack" into a complex, branching tree. Without these, your script would be a single straight line; with them, you can reuse nodes and create the complex DAG (Directed Acyclic Graph) structures Nuke is famous for.
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-1. The set command: Naming the Branch"><h3 id="1. The set command: Naming the Branch" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-1. The set command: Naming the Branch">1. The set command: Naming the Branch</a></h3></div>

<p>
The set command assigns a variable name to the node that was just created. Think of it like a bookmark. It tells Nuke: "Remember this specific point in the stack so I can jump back to it later."
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-2. The push command: The &quot;Teleporter&quot;"><h3 id="2. The push command: The &quot;Teleporter&quot;" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-2. The push command: The &quot;Teleporter&quot;">2. The push command: The "Teleporter"</a></h3></div>

<p>
The push command tells Nuke to go find a previously set bookmark and place a reference to it back onto the top of the stack.
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Example: Branching a CheckerBoard into two paths"><h3 id="Example: Branching a CheckerBoard into two paths" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Example: Branching a CheckerBoard into two paths">Example: Branching a CheckerBoard into two paths</a></h3></div>

<p>
Let’s look at a script where one CheckerBoard is used as the background (B) for a Merge, but also goes through a Blur to become the foreground (A) of that same Merge.
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Example: Branching a CheckerBoard into two paths-The .nk Syntax Logic:"><h4 id="The .nk Syntax Logic:" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Example: Branching a CheckerBoard into two paths-The .nk Syntax Logic:">The .nk Syntax Logic:</a></h4></div>

<pre tcl>
CheckerBoard2 {
 name CheckerBoard1
}
set N72a5c00 [stack 0]  # BOOKMARK: 'set' remembers the CheckerBoard

Blur {
 size 20
 name Blur1
 # Note: Blur automatically pops/connects to the CheckerBoard above it
}

push $N72a5c00          # TELEPORT: Bring the original CheckerBoard back to the top

Merge2 {
 inputs 2
 name Merge1
}
</pre>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Example: Branching a CheckerBoard into two paths-The Stack Table for this Branch"><h4 id="The Stack Table for this Branch" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Example: Branching a CheckerBoard into two paths-The Stack Table for this Branch">The Stack Table for this Branch</a></h4></div>

<table>
<tr>
<td>
Line
</td>
<td>
Action
</td>
<td>
The Stack (Bottom to Top)
</td>
<td>
Logic
</td>
</tr>
<tr>
<td>
CheckerBoard
</td>
<td>
Push
</td>
<td>
[CheckerBoard1]
</td>
<td>
The node is created.
</td>
</tr>
<tr>
<td>
set N72a...
</td>
<td>
Assign
</td>
<td>
[CheckerBoard1]
</td>
<td>
We bookmark the top of the stack as "N72a...".
</td>
</tr>
<tr>
<td>
Blur
</td>
<td>
Pop/Push
</td>
<td>
[Blur1]
</td>
<td>
Blur grabs CheckerBoard, connects, and replaces it.
</td>
</tr>
<tr>
<td>
push $N72a...
</td>
<td>
Push Ref
</td>
<td>
[Blur1, CheckerBoard1]
</td>
<td>
We "teleport" the original node back onto the top.
</td>
</tr>
<tr>
<td>
Merge
</td>
<td>
Pop 2
</td>
<td>
[Merge1]
</td>
<td>
Merge pops CheckerBoard1 (A) and Blur1 (B).
</td>
</tr>
</table>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How this dictates the DAG (Visual Graph)"><h3 id="How this dictates the DAG (Visual Graph)" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-How this dictates the DAG (Visual Graph)">How this dictates the DAG (Visual Graph)</a></h3></div>

<p>
By using set and push, Nuke creates a "Y" split in your script. In the visual Node Graph, this looks like one node having two output arrows pointing to different places.
</p>

<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Why does Nuke use weird names like N72a5c00?"><h3 id="Why does Nuke use weird names like N72a5c00?" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Why does Nuke use weird names like N72a5c00?">Why does Nuke use weird names like N72a5c00?</a></h3></div>

<p>
When you copy-paste nodes, Nuke generates these hex codes automatically. They are unique IDs for that specific instance of the node in memory.
</p>
<ul>
<li>
<span id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-Why does Nuke use weird names like N72a5c00?-Manual Control"></span><strong id="Manual Control">Manual Control</strong>: You can actually edit the .nk file and rename set N72a5c00 to set MY_BRANCH. As long as you change the corresponding push \(N72a5c00 to push \)MY_BRANCH, the script will still work perfectly.

</ul>
<div id="Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-The &quot;Hidden&quot; Branching Rule"><h3 id="The &quot;Hidden&quot; Branching Rule" class="header"><a href="#Another Run Through the Stack (and Set &amp; Push)-The .nk Syntax Structure-The &quot;Hidden&quot; Branching Rule">The "Hidden" Branching Rule</a></h3></div>

<p>
If you see a push command in a Nuke script that doesn't have a name (just push), it tells Nuke to look for the "next available" item lower down in the stack. However, for branching (using the same node twice), the named set/push method is mandatory.
</p>

<div id="Example Nuke Node Script"><h1 id="Example Nuke Node Script" class="header"><a href="#Example Nuke Node Script">Example Nuke Node Script</a></h1></div>

<pre tcl>
CheckerBoard2 {
	inputs 0
	name CheckerBoard1
	xpos -48
	ypos -290
}
set N2099800 [stack 0]
Blur {
	size 15
	name Blur1
	xpos -171
	ypos -145
}
push $N2099800
Grade {
	name Grade1
	xpos -48
	ypos -160
}
ColorCorrect {
	name ColorCorrect1
	xpos -48
	ypos -115
}
</pre>

<p>
In the provided snippet, <code>[stack 0]</code> is a Tcl command that retrieves the identity of the node currently at the very top of Nuke's internal stack. 
</p>

<p>
When used in the command set N2099800 [stack 0], it "bookmarks" the most recently created node so it can be referenced later. 
</p>

<div id="Example Nuke Node Script-Step-by-Step Logic of Your Snippet"><h2 id="Step-by-Step Logic of Your Snippet" class="header"><a href="#Example Nuke Node Script-Step-by-Step Logic of Your Snippet">Step-by-Step Logic of Your Snippet</a></h2></div>

<ul>
<li>
<span id="Example Nuke Node Script-Step-by-Step Logic of Your Snippet-CheckerBoard2"></span><strong id="CheckerBoard2">CheckerBoard2</strong>: Nuke creates this node. Because it has inputs 0, it doesn't take anything from the stack. Once created, the CheckerBoard1 node is pushed to the top of the stack (it is now at index 0).

<li>
<code>set N2099800 [stack 0]</code>:

<ul>
<li>
<code>[stack 0]</code> looks at the top of the stack and sees CheckerBoard1.

<li>
The set command assigns that node's unique internal ID to the variable N2099800.

<li>
Crucially, this does not remove the node from the stack; it just creates a "pointer" to it for later use.

</ul>
<li>
<span id="Example Nuke Node Script-Step-by-Step Logic of Your Snippet-Blur"></span><strong id="Blur">Blur</strong>: Nuke creates the Blur node. It defaults to having 1 input.

<ul>
<li>
Nuke pops (removes) the top item from the stack (CheckerBoard1) and connects it to the Blur node's input.

<li>
The Blur1 node is then pushed to the top of the stack.

</ul>
<li>
<code>push $N2099800</code>:

<ul>
<li>
This manually retrieves the node we bookmarked earlier (CheckerBoard1) and pushes it onto the top of the stack.

<li>
The stack now has two items: CheckerBoard1 (at index 0) and Blur1 (at index 1).

</ul>
<li>
<span id="Example Nuke Node Script-Step-by-Step Logic of Your Snippet-Grade"></span><strong id="Grade">Grade</strong>: Nuke creates the Grade node.

</ul>
<p>
It pops the top item from the stack (CheckerBoard1) and connects it to Grade1's input.
</p>
<ul>
<li>
Grade1 is pushed to the top of the stack.

</ul>
<li>
ColorCorrect: Nuke creates this node.

<ul>
<li>
It pops the top item (Grade1) and connects it to ColorCorrect1. 

</ul>
<div id="Example Nuke Node Script-Step-by-Step Logic of Your Snippet-Why [stack 0] is Used"><h3 id="Why [stack 0] is Used" class="header"><a href="#Example Nuke Node Script-Step-by-Step Logic of Your Snippet-Why [stack 0] is Used">Why [stack 0] is Used</a></h3></div>

<p>
In this specific script, [stack 0] is used to create a branch in the DAG. By "setting" the CheckerBoard to a variable, the script can connect it to the Blur node (linear flow) and then jump back to connect it to the Grade node as well (branching flow). 
</p>

<p>
Without that set and the subsequent push, the Grade node would have automatically connected to the Blur node because the Blur would have been at the top of the stack. 
</p>


<div id="Stack and Pop Logic"><h1 id="Stack and Pop Logic" class="header"><a href="#Stack and Pop Logic">Stack and Pop Logic</a></h1></div>

<p>
In the "Node-Node-Pop" logic, a 1-input node doesn't just sit on top of the stack—it consumes what is currently at the top, connects to it, and then replaces it as the new "top."
</p>

<p>
Let’s look at how the stack actually evolves when a 1-input node like a Grade is involved. It acts as a transaction.
</p>

<table>
<tr>
<td>
Line in .nk File
</td>
<td>
Action
</td>
<td>
The "Stack" (Bottom to Top)
</td>
<td>
Logic
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Read { name Read1 }
</td>
<td>
Push
</td>
<td>
[Read1]
</td>
<td>
The starting point.
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Grade { name Grade1 }
</td>
<td>
Pop 1, Push 1
</td>
<td>
[Grade1]
</td>
<td>
Grade1 "pops" Read1, connects its input to it, then "pushes" itself onto the stack.
</td>
<td>
&nbsp;
</td>
</tr>
</table>
<p>
|Read { name Read2 }	|Push|	[Grade1, Read2]|	A new branch/node is added.
|Merge2 { inputs 2 }|	Pop 2, Push 1|	[Merge1]|	Merge pops Read2 (Input A) and Grade1 (Input B), then pushes itself.
</p>

<div id="Stack and Pop Logic-Why this happens: Input Requirements"><h3 id="Why this happens: Input Requirements" class="header"><a href="#Stack and Pop Logic-Why this happens: Input Requirements">Why this happens: Input Requirements</a></h3></div>

<p>
The behavior of the stack is dictated by the node's input count.
</p>

<ul>
<li>
0-Input Nodes (Read, CheckerBoard, Constant): These nodes just Push. They don't need anything from the stack to exist.

<li>
1-Input Nodes (Grade, Blur, ColorCorrect): These Pop 1 and then Push 1. This creates a linear chain.

<li>
Multi-Input Nodes (Merge, JoinViews): These Pop N (where N is the number of inputs) and then Push 1. This is what actually "merges" the branches of your script.

</ul>
<div id="Stack and Pop Logic-The &quot;Hidden&quot; DAG"><h3 id="The &quot;Hidden&quot; DAG" class="header"><a href="#Stack and Pop Logic-The &quot;Hidden&quot; DAG">The "Hidden" DAG</a></h3></div>

<p>
If you visualize this as the stack "consuming" its predecessors, you can see how the 1D text file builds the 2D graph.
</p>

<p>
In the example:
</p>

<ul>
<li>
Read1 enters the stack.

<li>
Grade1 sees Read1, grabs it, and now Grade1 represents the end of that specific "pipe."

<li>
Read2 is placed on the stack as a totally separate pipe.

<li>
Merge sees two pipes available, grabs both, and combines them into one final pipe.

</ul>
<div id="Stack and Pop Logic-The &quot;Hidden&quot; DAG-A Quick Way to See This in Nuke"><h4 id="A Quick Way to See This in Nuke" class="header"><a href="#Stack and Pop Logic-The &quot;Hidden&quot; DAG-A Quick Way to See This in Nuke">A Quick Way to See This in Nuke</a></h4></div>

<p>
If you ever want to see this "stack" logic in the actual Nuke UI, try this:
</p>
<ul>
<li>
Select two Read nodes.

<li>
Press M to Merge.

</ul>
<p>
Nuke will automatically connect them based on the order they were selected—which is Nuke's way of creating a temporary "selection stack."
</p>

<div id="Mask Inputs"><h1 id="Mask Inputs" class="header"><a href="#Mask Inputs">Mask Inputs</a></h1></div>

<p>
When a node has a Mask input (or any optional 3rd input), the stack logic gets slightly more sophisticated. In a Nuke script, these are often referred to as "side-pipe" inputs.
</p>

<p>
In the .nk file, Nuke handles this by looking at the Input Count defined in the node's class. For a Merge node, the inputs are usually numbered: input0 (B), input1 (A), and input2 (Mask).
</p>

<div id="Mask Inputs-The &quot;Side-Pipe&quot; Stack Logic"><h3 id="The &quot;Side-Pipe&quot; Stack Logic" class="header"><a href="#Mask Inputs-The &quot;Side-Pipe&quot; Stack Logic">The "Side-Pipe" Stack Logic</a></h3></div>

<p>
Here is how the robot handles a Merge with a Mask. Note how it "reaches deeper" into the stack:
</p>

<table>
<tr>
<td>
Line in .nk File
</td>
<td>
Action
</td>
<td>
The "Stack" (Bottom to Top)
</td>
<td>
Logic
</td>
</tr>
<tr>
<td>
Read { name BG }
</td>
<td>
Push
</td>
<td>
[BG]
</td>
<td>
The background layer.
</td>
</tr>
<tr>
<td>
Read { name FG }
</td>
<td>
Push
</td>
<td>
[BG, FG]
</td>
<td>
The foreground layer.
</td>
</tr>
<tr>
<td>
Radial { name Mask1 }
</td>
<td>
Push
</td>
<td>
[BG, FG, Mask1]
</td>
<td>
The mask shape.
</td>
</tr>
<tr>
<td>
Merge2 { inputs 3 }
</td>
<td>
Pop 3, Push 1
</td>
<td>
[Merge1]
</td>
<td>
Pop Mask1 (Input 2), Pop FG (Input 1), Pop BG (Input 0).
</td>
</tr>
</table>

<div id="Mask Inputs-The &quot;Nuke Rule of Three&quot;"><h3 id="The &quot;Nuke Rule of Three&quot;" class="header"><a href="#Mask Inputs-The &quot;Nuke Rule of Three&quot;">The "Nuke Rule of Three"</a></h3></div>

<p>
When the Merge2 node is created with 3 inputs, it executes a specific "ordering" from the stack:
</p>
<ul>
<li>
The Top Item on the stack becomes the Mask (Input 2).

<li>
The Second Item down becomes the A pipe (Input 1).

<li>
The Third Item down becomes the B pipe (Input 0).

</ul>
<p>
This is why, if you were to accidentally create your nodes in the wrong order—for example, creating your Background after your Mask—the Merge node would plug your background image into the Mask input!
</p>

<div id="Mask Inputs-Visualizing the Connections (The DAG)"><h3 id="Visualizing the Connections (The DAG)" class="header"><a href="#Mask Inputs-Visualizing the Connections (The DAG)">Visualizing the Connections (The DAG)</a></h3></div>

<p>
In the Node Graph, this "Pop 3" action creates the familiar three-way junction. The stack is essentially "collapsing" three separate branches into a single output pipe.
</p>

<div id="Mask Inputs-What happens if the Stack is too &quot;Short&quot;?"><h3 id="What happens if the Stack is too &quot;Short&quot;?" class="header"><a href="#Mask Inputs-What happens if the Stack is too &quot;Short&quot;?">What happens if the Stack is too "Short"?</a></h3></div>

<p>
If you write a Nuke script that calls for a Merge2 { inputs 3 } but there is only one node on the stack, Nuke won't crash. Instead:
</p>
<ul>
<li>
It connects Input 0 to the available node.

<li>
It leaves Input 1 and Input 2 disconnected.

<li>
The stack then contains only the Merge node, waiting for the next command.

</ul>
<div id="Mask Inputs-Identifying &quot;Stack Errors&quot; in your Script"><h3 id="Identifying &quot;Stack Errors&quot; in your Script" class="header"><a href="#Mask Inputs-Identifying &quot;Stack Errors&quot; in your Script">Identifying "Stack Errors" in your Script</a></h3></div>

<p>
If you are looking at a raw Nuke script and you see a node that looks like it's floating or connected to the wrong thing, check the lines directly above it.
</p>

<p>
Pro-Tip: In Nuke, the push command can be used explicitly in the text file to duplicate an item already on the stack. If you see push $cut_paste_input, Nuke is "copying" a lower item in the stack and putting it back on top so a node can grab it again!
</p>


<div id="More on Copy and Push"><h1 id="More on Copy and Push" class="header"><a href="#More on Copy and Push">More on Copy and Push</a></h1></div>

<p>
In a raw Nuke script (.nk), $cut_paste_input is a placeholder variable. It is a temporary "memory link" used by Nuke when you copy a node that was connected to something you didn't select.
</p>

<p>
When you paste that node, Nuke uses $cut_paste_input to try and reconnect it to the "current" top of the stack in your new location.
</p>

<div id="More on Copy and Push-1. The push Command: Reusing the Stack"><h3 id="1. The push Command: Reusing the Stack" class="header"><a href="#More on Copy and Push-1. The push Command: Reusing the Stack">1. The push Command: Reusing the Stack</a></h3></div>

<p>
In the Nuke text format, the push command is how the script re-uses a node that is already existing in the script. It literally tells the robot: "Go back to that specific node we made earlier and put a 'virtual copy' of it on top of the stack so I can use it again."
</p>

<p>
The push logic in action: Imagine you have a Read1 node. You use it for your main pipe, but you also want to use it as a mask for a Merge later down the script.
</p>

<table>
<tr>
<td>
Line in .nk File
</td>
<td>
Action
</td>
<td>
The Stack
</td>
<td>
Result
</td>
</tr>
<tr>
<td>
Read { name Read1 }
</td>
<td>
Push
</td>
<td>
[Read1]
</td>
<td>
Creates the node.
</td>
</tr>
<tr>
<td>
Blur { name Blur1 }
</td>
<td>
Pop 1, Push 1
</td>
<td>
[Blur1]
</td>
<td>
Read1 flows into Blur1.
</td>
</tr>
<tr>
<td>
push $Read1
</td>
<td>
Push (Ref)
</td>
<td>
[Blur1, Read1]
</td>
<td>
The Magic: Read1 is now at the top again!
</td>
</tr>
<tr>
<td>
Merge2 { inputs 2 }
</td>
<td>
Pop 2, Push 1
</td>
<td>
[Merge1]
</td>
<td>
Merge connects Input B to Blur1 and Input A back to Read1.
</td>
</tr>
</table>

<div id="More on Copy and Push-2. How $cut_paste_input Works"><h3 id="2. How $cut_paste_input Works" class="header"><a href="#More on Copy and Push-2. How $cut_paste_input Works">2. How $cut_paste_input Works</a></h3></div>

<p>
When you select a node (let's say a Grade) and copy it, but you don't select the Read node it’s attached to, Nuke generates this text:
</p>

<pre tcl>
set cut_paste_input [stack 0]  # Store the current top of the stack
version 15.0
push $cut_paste_input          # Push that stored "ghost" onto the stack
Grade {
 name Grade_Copied
 ...
}
</pre>

<ul>
<li>
<code>[stack 0]</code>: This tells Nuke to look at whatever node is currently at the very top of the stack where you are about to paste.

<li>
<span id="More on Copy and Push-2. How $cut_paste_input Works-The Result"></span><strong id="The Result">The Result</strong>: When you paste, Nuke "pushes" whatever you were just clicking on (the current stack top) into the input of your pasted node. This is why pasted nodes "jump" onto your active selection.

</ul>
<div id="More on Copy and Push-3. The copy Logic (Node Level)"><h3 id="3. The copy Logic (Node Level)" class="header"><a href="#More on Copy and Push-3. The copy Logic (Node Level)">3. The copy Logic (Node Level)</a></h3></div>

<p>
The Copy node in Nuke (which copies channels like Alpha from one pipe to another) works exactly like the 3-input Merge we discussed, but it relies heavily on the push command to bring the two pipes together.
</p>

<div id="More on Copy and Push-3. The copy Logic (Node Level)-The Stack Flow for a Copy Node:"><h4 id="The Stack Flow for a Copy Node:" class="header"><a href="#More on Copy and Push-3. The copy Logic (Node Level)-The Stack Flow for a Copy Node:">The Stack Flow for a Copy Node:</a></h4></div>

<ul>
<li>
<span id="More on Copy and Push-3. The copy Logic (Node Level)-The Stack Flow for a Copy Node:-Pipe B"></span><strong id="Pipe B">Pipe B</strong>: You define your main image (pushed to stack).

<li>
<span id="More on Copy and Push-3. The copy Logic (Node Level)-The Stack Flow for a Copy Node:-Pipe A"></span><strong id="Pipe A">Pipe A</strong>: You define your Alpha source (pushed to stack).

<li>
<span id="More on Copy and Push-3. The copy Logic (Node Level)-The Stack Flow for a Copy Node:-The Copy Node"></span><strong id="The Copy Node">The Copy Node</strong>: It pops the Alpha source, then pops the main image, combines the channels, and pushes the result back to the top.

</ul>
<div id="More on Copy and Push-3. The copy Logic (Node Level)-Why this matters for the &quot;Ghost&quot; Connection"><h4 id="Why this matters for the &quot;Ghost&quot; Connection" class="header"><a href="#More on Copy and Push-3. The copy Logic (Node Level)-Why this matters for the &quot;Ghost&quot; Connection">Why this matters for the "Ghost" Connection</a></h4></div>

<p>
If you see $cut_paste_input and push commands in a script, it means Nuke is doing non-linear branching. It is taking a single node and "splitting" its output to go to multiple places.
</p>

<p>
Without the push command, the stack would only ever be a single straight line. The push command is what allows Nuke to have branches.
</p>

<div id="More on Copy and Push-Pro-Tip: Cleaning up the Stack"><h3 id="Pro-Tip: Cleaning up the Stack" class="header"><a href="#More on Copy and Push-Pro-Tip: Cleaning up the Stack">Pro-Tip: Cleaning up the Stack</a></h3></div>

<p>
If you ever open a Nuke script in a text editor and see hundreds of push \(cut_paste_input lines, it’s usually a sign of a "messy" copy-paste history. You can actually manually change \)cut_paste_input to a specific node name (like Read1) to force a connection to stay put regardless of where it is pasted!
</p>

<div id="PostageStamp Illustration"><h1 id="PostageStamp Illustration" class="header"><a href="#PostageStamp Illustration">PostageStamp Illustration</a></h1></div>

<p>
In Nuke, a PostageStamp node is essentially a "portal" or a "visual reference" node. While it looks like a regular node in the DAG, its behavior in the underlying .nk script is a clever use of the push and hidden logic we’ve been discussing.
</p>

<div id="PostageStamp Illustration-How PostageStamp relates to the Stack"><h3 id="How PostageStamp relates to the Stack" class="header"><a href="#PostageStamp Illustration-How PostageStamp relates to the Stack">How PostageStamp relates to the Stack</a></h3></div>

<p>
When you use a PostageStamp to "clean up" a script, you are essentially telling Nuke: "I want to use the output of a node from way over there, without dragging a long pipe across my whole workspace."
</p>

<p>
In the stack system, the PostageStamp acts as a named push.
</p>

<table>
<tr>
<td>
Action in Node Graph
</td>
<td>
Stack Action in .nk File
</td>
</tr>
<tr>
<td>
Create Read1
</td>
<td>
Push Read1
</td>
</tr>
<tr>
<td>
Create PostageStamp
</td>
<td>
Push a reference to the top of the stack
</td>
</tr>
<tr>
<td>
Change PostageStamp
</td>
<td>
Input	Nuke uses a push $NodeName command to grab a specific point in the script's history
</td>
</tr>
</table>

<div id="PostageStamp Illustration-How PostageStamp relates to the Stack-Using &quot;Hidden Inputs&quot; for a Cleaner Stack"><h4 id="Using &quot;Hidden Inputs&quot; for a Cleaner Stack" class="header"><a href="#PostageStamp Illustration-How PostageStamp relates to the Stack-Using &quot;Hidden Inputs&quot; for a Cleaner Stack">Using "Hidden Inputs" for a Cleaner Stack</a></h4></div>

<p>
The most common way to use this logic for script organization is through Hidden Inputs. If you select a PostageStamp (or any node), go to the Node tab, and check "hide input", the visual pipe disappears, but the Stack Connection remains.
</p>

<ul>
<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Using &quot;Hidden Inputs&quot; for a Cleaner Stack-The Hidden push"></span><strong id="The Hidden push">The Hidden push</strong>: Even though you don't see the line in the DAG, the script still contains a push command.

<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Using &quot;Hidden Inputs&quot; for a Cleaner Stack-The Benefit"></span><strong id="The Benefit">The Benefit</strong>: Your "Stack" stays organized. You can have a "Global Mask" node at the top of your script and "push" it into multiple Merge nodes at the bottom without creating a "spaghetti" graph.

</ul>
<div id="PostageStamp Illustration-How PostageStamp relates to the Stack-The &quot;Clone&quot; vs. &quot;PostageStamp&quot; Stack Logic"><h4 id="The &quot;Clone&quot; vs. &quot;PostageStamp&quot; Stack Logic" class="header"><a href="#PostageStamp Illustration-How PostageStamp relates to the Stack-The &quot;Clone&quot; vs. &quot;PostageStamp&quot; Stack Logic">The "Clone" vs. "PostageStamp" Stack Logic</a></h4></div>

<p>
It is important to distinguish these two, as they handle the stack differently:
</p>
<ul>
<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-The &quot;Clone&quot; vs. &quot;PostageStamp&quot; Stack Logic-PostageStamp"></span><strong id="PostageStamp">PostageStamp</strong>: Creates a new node entry in the stack that simply references the output of another node. It has its own controls.

<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-The &quot;Clone&quot; vs. &quot;PostageStamp&quot; Stack Logic-Clone (Alt+K)"></span><strong id="Clone (Alt+K)">Clone (Alt+K)</strong>: Creates a linked entry. In the .nk file, these nodes share the same parameters. If the stack updates the "Master" node, the "Clone" updates simultaneously because they are essentially the same ID in the stack.

</ul>
<div id="PostageStamp Illustration-How PostageStamp relates to the Stack-Visualizing a Complex Stack"><h4 id="Visualizing a Complex Stack" class="header"><a href="#PostageStamp Illustration-How PostageStamp relates to the Stack-Visualizing a Complex Stack">Visualizing a Complex Stack</a></h4></div>

<p>
If you were to see a "PostageStamp" system animated, it would look like a "Teleporter."
</p>
<ul>
<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Visualizing a Complex Stack-Input"></span><strong id="Input">Input</strong>: A node enters a "PostageStamp" portal.

<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Visualizing a Complex Stack-The Stack"></span><strong id="The Stack">The Stack</strong>: The node doesn't disappear; it stays at its original location in the script.

<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Visualizing a Complex Stack-Output"></span><strong id="Output">Output</strong>: At the bottom of the script, a "Ghost" version of that node is pushed onto the stack exactly when it's needed for a Merge or a ColorCorrect.

</ul>
<div id="PostageStamp Illustration-How PostageStamp relates to the Stack-Summary of the Nuke &quot;Stack&quot; Journey"><h4 id="Summary of the Nuke &quot;Stack&quot; Journey" class="header"><a href="#PostageStamp Illustration-How PostageStamp relates to the Stack-Summary of the Nuke &quot;Stack&quot; Journey">Summary of the Nuke "Stack" Journey</a></h4></div>

<p>
We've traveled from a simple Vimscript stack = 0 counter to the complex, non-linear push/pop logic of a Nuke production script.
</p>
<ul>
<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Summary of the Nuke &quot;Stack&quot; Journey-Vimscript"></span><strong id="Vimscript">Vimscript</strong>: Used the stack to track nesting (opening/closing).

<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Summary of the Nuke &quot;Stack&quot; Journey-Nuke"></span><strong id="Nuke">Nuke</strong>: Uses the stack to track data flow (inputs/outputs).

<li>
<span id="PostageStamp Illustration-How PostageStamp relates to the Stack-Summary of the Nuke &quot;Stack&quot; Journey-Both"></span><strong id="Both">Both</strong>: Rely on the LIFO (Last-In, First-Out) principle to know exactly which "opener" or "node" is currently active.

</ul>
<div id="Python Script to Find Orphan Nodes (and illustrate the stack)"><h1 id="Python Script to Find Orphan Nodes (and illustrate the stack)" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)">Python Script to Find Orphan Nodes (and illustrate the stack)</a></h1></div>

<p>
In Nuke, "orphaned" nodes are nodes that exist in your script but aren't connected to the "Main Pipe" leading to your Viewer or Write nodes. These nodes take up memory and can make the .nk file difficult to read.
</p>

<p>
Because Nuke's Python API (nuke) works by looking at the DAG as a collection of objects, we can write a script that mimics the Stack logic to see which nodes are "dead ends."
</p>

<div id="Python Script to Find Orphan Nodes (and illustrate the stack)-The &quot;Orphan Hunter&quot; Script"><h3 id="The &quot;Orphan Hunter&quot; Script" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)-The &quot;Orphan Hunter&quot; Script">The "Orphan Hunter" Script</a></h3></div>

<p>
This script starts at your selected node (usually your final Write node) and "walks" backwards up the stack. Any node it doesn't touch is considered an orphan.
</p>

<pre python>
import nuke

def find_orphans():
    # 1. Start with the nodes currently leading to your output
    all_nodes = nuke.allNodes()
    connected_nodes = set()
    
    # We "walk" the tree from the selected node backwards
    nodes_to_check = nuke.selectedNodes()
    
    if not nodes_to_check:
        nuke.message("Please select the 'Tail' node (e.g., your Write node) to check connections.")
        return

    while nodes_to_check:
        current = nodes_to_check.pop()
        if current not in connected_nodes:
            connected_nodes.add(current)
            # Add all inputs of this node to the 'to-check' list (the reverse stack)
            for i in range(current.inputs()):
                input_node = current.input(i)
                if input_node:
                    nodes_to_check.append(input_node)

    # 2. Identify who didn't make the list
    orphans = [n for n in all_nodes if n not in connected_nodes]

    # 3. Highlight the orphans in the DAG
    if orphans:
        for n in all_nodes:
            n.setSelected(False)
        for o in orphans:
            o.setSelected(True)
        nuke.message(f"Found {len(orphans)} orphaned nodes. They are now selected.")
    else:
        nuke.message("No orphans found! Your stack is fully connected.")

# Run the function
find_orphans()
</pre>

<div id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack"><h3 id="How this Python relates to the Stack" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack">How this Python relates to the Stack</a></h3></div>

<p>
In this script, the nodes_to_check variable is literally a stack.
</p>
<ul>
<li>
<span id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Push"></span><strong id="Push">Push</strong>: We take the node you selected and put it in the list.

<li>
<span id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Pop"></span><strong id="Pop">Pop</strong>: The while loop "pops" the node out to look at its inputs.

<li>
<span id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Recursive Push"></span><strong id="Recursive Push">Recursive Push</strong>: It then "pushes" all the nodes connected to those inputs back into the list.

</ul>
<div id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Why this is useful for Nuke Scripts"><h4 id="Why this is useful for Nuke Scripts" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Why this is useful for Nuke Scripts">Why this is useful for Nuke Scripts</a></h4></div>

<ul>
<li>
<span id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Why this is useful for Nuke Scripts-Performance"></span><strong id="Performance">Performance</strong>: Orphaned nodes with "heavy" calculations (like a MotionBlur or Defocus) can sometimes still render in the background if they are part of a side-pipe.

<li>
<span id="Python Script to Find Orphan Nodes (and illustrate the stack)-How this Python relates to the Stack-Why this is useful for Nuke Scripts-Debugging"></span><strong id="Debugging">Debugging</strong>: If your PostageStamp logic broke (the $cut_paste_input failed), this script will highlight that the Stamp is no longer "connected" to the main stack.

</ul>
<div id="Python Script to Find Orphan Nodes (and illustrate the stack)-Comparison: Vim vs. Nuke Stack Logic"><h3 id="Comparison: Vim vs. Nuke Stack Logic" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)-Comparison: Vim vs. Nuke Stack Logic">Comparison: Vim vs. Nuke Stack Logic</a></h3></div>

<p>
To wrap up our deep dive, let's look at the two systems we've explored:
</p>

<table>
<tr>
<td>
Feature
</td>
<td>
Vimscript Stack
</td>
<td>
Nuke Script Stack
</td>
</tr>
<tr>
<td>
Purpose
</td>
<td>
Balancing Syntax (if/endif)
</td>
<td>
Routing Data (Read/Merge)
</td>
</tr>
<tr>
<td>
Items Stored
</td>
<td>
Line Numbers / Tags
</td>
<td>
Node Objects / Pointers
</td>
</tr>
<tr>
<td>
Logic Type
</td>
<td>
LIFO (Last-In, First-Out)
</td>
<td>
LIFO (for input assignment)
</td>
</tr>
<tr>
<td>
Goal
</td>
<td>
Preventing Syntax Errors
</td>
<td>
Creating an Image
</td>
</tr>
</table>

<div id="Python Script to Find Orphan Nodes (and illustrate the stack)-Adding as a Command (Menu)"><h3 id="Adding as a Command (Menu)" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)-Adding as a Command (Menu)">Adding as a Command (Menu)</a></h3></div>

<p>
To add this to your menu.py, you just need to wrap the function and use the nuke.menu method to assign it a place in the UI and a keyboard shortcut.
</p>

<p>
I've assigned it to Alt+Shift+O (for "Orphans") in the example below.
</p>

<pre python>
import nuke

def selectOrphanedNodes():
    # Start from selected nodes (the outputs) and find all upstream parents
    start_nodes = nuke.selectedNodes()
    if not start_nodes:
        nuke.message("Please select your 'target' nodes (e.g. Write or Viewer) first.")
        return

    connected = set()
    stack = list(start_nodes)

    while stack:
        node = stack.pop()
        if node not in connected:
            connected.add(node)
            # Add all inputs of current node to the stack to keep searching upstream
            for i in range(node.inputs()):
                upstream = node.input(i)
                if upstream:
                    stack.append(upstream)

    # Find nodes that exist in script but weren't reached in the walk
    orphans = [n for n in nuke.allNodes() if n not in connected]

    if orphans:
        # Clear current selection and select only the orphans
        for n in nuke.allNodes():
            n.setSelected(False)
        for o in orphans:
            o.setSelected(True)
        nuke.message(f"Selected {len(orphans)} orphaned nodes.")
    else:
        nuke.message("No orphans found! Everything is connected to your selection.")

# --- ADD TO MENU.PY ---
# This adds a 'Tools' menu (or uses existing one) and puts the command inside
m = nuke.menu('Nuke')
menu_tools = m.addMenu('Tools')
menu_tools.addCommand('Select Orphaned Nodes', 'selectOrphanedNodes()', 'alt+shift+o')
</pre>

<div id="Python Script to Find Orphan Nodes (and illustrate the stack)-Adding as a Command (Menu)-Quick Usage Tip:"><h4 id="Quick Usage Tip:" class="header"><a href="#Python Script to Find Orphan Nodes (and illustrate the stack)-Adding as a Command (Menu)-Quick Usage Tip:">Quick Usage Tip:</a></h4></div>

<ul>
<li>
Save this in your .nuke/menu.py file.

<li>
Restart Nuke.

<li>
Select your Write node or Viewer.

<li>
Press Alt+Shift+O.

<li>
Any node that Nuke doesn't need to calculate that specific output will be highlighted, allowing you to delete them and keep your "stack" clean.

</ul>
<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
