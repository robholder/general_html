<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_expressions_fbm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="fBm - Fractional Brownian Motion"><h1 id="fBm - Fractional Brownian Motion" class="header"><a href="#fBm - Fractional Brownian Motion">fBm - Fractional Brownian Motion</a></h1></div>

<p>
Nuke offers support for fractional Brownian motion (fBm) directly in its expression language. This facility is commonly used when creating procedural noise effects such as turbulence or natural-looking textures by summing octaves of noise. Here’s a breakdown of how it works and how you might use it:
</p>

<div id="fBm - Fractional Brownian Motion-fBm in Nuke's Expression Language"><h2 id="fBm in Nuke's Expression Language" class="header"><a href="#fBm - Fractional Brownian Motion-fBm in Nuke's Expression Language">fBm in Nuke's Expression Language</a></h2></div>

<p>
In Nuke’s built‑in expression system, there is a function called fBm that you can use to generate fBm noise. The usage is similar to many common fBm implementations in graphics. The basic form of the call is:
</p>

<pre plaintext>
fBm(x, y, z, octaves, lacunarity, gain)
</pre>

<ul>
<li>
<span id="fBm - Fractional Brownian Motion-fBm in Nuke's Expression Language-x, y, z"></span><strong id="x, y, z">x, y, z</strong>: These are your coordinate inputs. In many cases for 2D noise, you’ll replace or repurpose z (e.g., as a seed or time parameter).

<li>
<span id="fBm - Fractional Brownian Motion-fBm in Nuke's Expression Language-octaves"></span><strong id="octaves">octaves</strong>: Specifies how many layers (or details) of noise to add together.

<li>
<span id="fBm - Fractional Brownian Motion-fBm in Nuke's Expression Language-lacunarity"></span><strong id="lacunarity">lacunarity</strong>: Controls the increase in frequency for each successive octave. Typically, this value is &gt; 1.

<li>
<span id="fBm - Fractional Brownian Motion-fBm in Nuke's Expression Language-gain"></span><strong id="gain">gain</strong>: Modulates the amplitude for each octave, generally set to a value less than 1.

</ul>
<p>
Under the hood, the fBm function works by summing several scaled calls to the base noise function (often Perlin noise), where each octave increases the frequency (via lacunarity) and reduces the amplitude (via gain). This provides the characteristic “fractal” quality that can mimic natural textures.
</p>

<div id="fBm - Fractional Brownian Motion-How It’s Used in Practice"><h2 id="How It’s Used in Practice" class="header"><a href="#fBm - Fractional Brownian Motion-How It’s Used in Practice">How It’s Used in Practice</a></h2></div>

<p>
Nuke’s Expression node or channels in certain nodes (like Noise or Distort nodes) can accept these mathematical functions directly. For example, you might overlay an fBm expression onto a grayscale channel to drive a distortion effect or to generate procedural patterns.
</p>

<p>
A common scenario might involve something like this in an Expression node:
</p>

<pre plaintext>
r = fBm(r, g, seed, octaves, lacunarity, gain)
</pre>

<p>
Here, the red and green channels (or even the screen coordinates) act as your x and y input, while a control parameter (like “seed” or even the current frame) can be fed in as z. Adjust the number of octaves and tuning parameters until the output noise feels “right” for your compositing task.
</p>

<div id="fBm - Fractional Brownian Motion-Other Considerations"><h2 id="Other Considerations" class="header"><a href="#fBm - Fractional Brownian Motion-Other Considerations">Other Considerations</a></h2></div>

<ul>
<li>
<span id="fBm - Fractional Brownian Motion-Other Considerations-Tuning Parameters"></span><strong id="Tuning Parameters">Tuning Parameters</strong>: Experiment with the values for octaves, lacunarity, and gain. The intended look – whether you need subtle texture or a heavily turbulent pattern – will determine the right balance.

<li>
<span id="fBm - Fractional Brownian Motion-Other Considerations-Integration with Nodes"></span><strong id="Integration with Nodes">Integration with Nodes</strong>: While the Expression node is a direct way to use fBm in your expressions, many nodes (like the Noise node in Nuke) internally use fBm. Understanding the underlying fBm parameters can help you fine-tune these nodes to get desired procedural effects.

<li>
<span id="fBm - Fractional Brownian Motion-Other Considerations-Documentation and Examples"></span><strong id="Documentation and Examples">Documentation and Examples</strong>: The function is documented in Nuke’s expression reference, and there are various Nukepedia pages and Foundry documents that illustrate its use in practical shader and node setups.

</ul>
<div id="fBm - Fractional Brownian Motion-Other Considerations-Summary"><h3 id="Summary" class="header"><a href="#fBm - Fractional Brownian Motion-Other Considerations-Summary">Summary</a></h3></div>

<p>
In summary, Nuke includes an fBm function as part of its expression language that lets you generate fractional Brownian motion by specifying coordinate inputs along with octaves, lacunarity, and gain. This makes it a versatile tool for generating noise-based effects right within Nuke’s node system.
</p>

<p>
For a deeper understanding, you might check documentation such as the Nukepedia Expression Reference or the Foundry’s Nuke expression manual that covers noise-related functions in detail
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
