<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>blinkscript_specify_pixel_color</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="nuke_blinkscript_index.html">Nuke - Blinkscript</a>
</p>

<div id="Accessing Components"><h1 id="Accessing Components" class="header"><a href="#Accessing Components">Accessing Components</a></h1></div>


<p>
In BlinkScript with eAccessRanged2D, you can access a range of pixels from a source image and specify the color for the output pixel within your kernel's process() function. 
</p>

<p>
Here's how it generally works:
</p>

<div id="Accessing Components-Declare your source image with eAccessRanged2D:"><h4 id="Declare your source image with eAccessRanged2D:" class="header"><a href="#Accessing Components-Declare your source image with eAccessRanged2D:">Declare your source image with eAccessRanged2D:</a></h4></div>
  
<pre cpp>
Image&lt;eRead, eAccessRanged2D, eEdgeClamped&gt; src; 
</pre>

<ul>
<li>
<span id="Accessing Components-Declare your source image with eAccessRanged2D:-eRead:"></span><strong id="eRead:">eRead:</strong> Indicates read-only access.

<li>
<span id="Accessing Components-Declare your source image with eAccessRanged2D:-eAccessRanged2D:"></span><strong id="eAccessRanged2D:">eAccessRanged2D:</strong> Specifies that the kernel will access a two-dimensional range of pixels from this image.

<li>
<span id="Accessing Components-Declare your source image with eAccessRanged2D:-eEdgeClamped:"></span><strong id="eEdgeClamped:">eEdgeClamped:</strong> Determines how pixels outside the image boundaries are handled (clamped to the edge).

</ul>
<div id="Accessing Components-Set the range in your init() function:"><h4 id="Set the range in your init() function:" class="header"><a href="#Accessing Components-Set the range in your init() function:">Set the range in your init() function:</a></h4></div>

<pre cpp>
void init() {
    src.setRange(-xRadius, -yRadius, xRadius, yRadius); 
}
</pre>

<ul>
<li>
<span id="Accessing Components-Set the range in your init() function:-setRange():"></span><strong id="setRange():">setRange():</strong> Defines the 2D range of pixels the kernel will access relative to the current position. You specify the horizontal minimum, vertical minimum, horizontal maximum, and vertical maximum of the range.

</ul>
<div id="Accessing Components-Access and process pixels within the process() function:"><h4 id="Access and process pixels within the process() function:" class="header"><a href="#Accessing Components-Access and process pixels within the process() function:">Access and process pixels within the process() function:</a></h4></div>

<ul>
<li>
Inside process(), you can loop through the defined range of pixels using nested loops and access the color values of each pixel from the source image.

<li>
The type representing a pixel's color in Nuke is typically a float4 (representing RGBA values) or a float for a single component, depending on whether you're processing pixel-wise or component-wise.

<li>
Example: To access the color of a specific pixel within the range at coordinates (i, j) and set the output dst() color based on some logic:

</ul>
  
<pre cpp>
// Get the color of a pixel from the source image
float4 pixelColor = src(i, j);

// Manipulate the color (example: invert the red channel)
pixelColor.r = 1.0f - pixelColor.r;

// Set the output pixel color
dst() = pixelColor;
</pre>

<ul>
<li>
Note: BlinkScript processes images in a component-wise or pixel-wise manner. When writing a component-wise kernel, each channel is processed independently, and you'll access individual components (like src(i, j) which would return a float). For pixel-wise kernels, you access whole pixels (which return a float4 for RGBA images). 

</ul>
<p>
By using this approach, you can iterate through the specified 2D range, read pixel colors from the source image, and then write the desired color to the corresponding output pixel within the process() function. Remember that the example above simplifies the process, and you can incorporate more complex logic and algorithms within your process() function to achieve specific image processing effects. 
</p>


<p>
<a href="nuke_blinkscript_index.html">Nuke - Blinkscript</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
