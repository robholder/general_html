<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_python_knob_changed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="Index.html">Index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="Nuke - Python - knobChanged"><h1 id="Nuke - Python - knobChanged" class="header"><a href="#Nuke - Python - knobChanged">Nuke - Python - knobChanged</a></h1></div>

<div id="Nuke - Python - knobChanged-Overview"><h2 id="Overview" class="header"><a href="#Nuke - Python - knobChanged-Overview">Overview</a></h2></div>

<p>
Here's a breakdown of <code>nuke.addKnobChanged()</code> and <code>nuke.addUpdateUI()</code> in the Nuke Python API.
</p>

<div id="Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()"><h3 id="nuke.addKnobChanged()" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()">nuke.addKnobChanged()</a></h3></div>

<p>
This method lets you register a callback function that runs whenever a knob is changed in Nuke. It‚Äôs useful for automating tasks when a user adjusts parameters.
</p>

<div id="Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()-Basic Usage:"><h4 id="Basic Usage:" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()-Basic Usage:">Basic Usage:</a></h4></div>
<pre python>
import nuke

def on_knob_changed(knob):
    print(f"Knob {knob.name()} changed!")

# Register the callback
nuke.addKnobChanged(on_knob_changed)
</pre>

<div id="Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()-How It Works:"><h4 id="How It Works:" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()-How It Works:">How It Works:</a></h4></div>

<ul>
<li>
The function <code>on_knob_changed()</code> is triggered every time any knob in Nuke is modified.

<li>
<code>knob.name()</code> returns the name of the modified knob.

<li>
Can be used for custom UI updates, validation, or dependencies.

</ul>
<p>
Example: Trigger Action on Specific Knob Change
</p>
<pre python>
def custom_knob_callback(knob):
    if knob.name() == "blur_size":
        print("Blur size changed!")

nuke.addKnobChanged(custom_knob_callback)
</pre>

<p>
Here, the callback only runs when the "blur_size" knob is changed.
</p>

<div id="Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()-Important Notes:"><h4 id="Important Notes:" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addKnobChanged()-Important Notes:">Important Notes:</a></h4></div>

<ul>
<li>
Runs every time a knob changes, so excessive callbacks can impact performance.

<li>
Use conditional checks to trigger code only for specific knobs.

</ul>
<div id="Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()"><h3 id="nuke.addUpdateUI()" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()">nuke.addUpdateUI()</a></h3></div>

<p>
This method updates the UI but only when necessary, instead of triggering on every knob change.
</p>

<div id="Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()-Why Use nuke.addUpdateUI() Instead?"><h4 id="Why Use nuke.addUpdateUI() Instead?" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()-Why Use nuke.addUpdateUI() Instead?">Why Use nuke.addUpdateUI() Instead?</a></h4></div>

<ul>
<li>
Improves performance‚Äîinstead of reacting to every knob change, it updates only when the UI needs refreshing.

<li>
Useful for scenarios where you want the UI to update only when visible or required.

</ul>
<div id="Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()-Example Usage:"><h4 id="Example Usage:" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()-Example Usage:">Example Usage:</a></h4></div>
<pre python>
def update_ui():
    print("Updating UI...")

nuke.addUpdateUI(update_ui)
</pre>

<div id="Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()-Use Case Comparison:"><h4 id="Use Case Comparison:" class="header"><a href="#Nuke - Python - knobChanged-Overview-nuke.addUpdateUI()-Use Case Comparison:">Use Case Comparison:</a></h4></div>

<ul>
<li>
Use <code>nuke.addKnobChanged()</code> when immediate reaction is needed for a knob change.

<li>
Use <code>nuke.addUpdateUI()</code> when batch UI updates are preferred to reduce overhead.

</ul>
<div id="Nuke - Python - knobChanged-Which One Should You Use?"><h2 id="Which One Should You Use?" class="header"><a href="#Nuke - Python - knobChanged-Which One Should You Use?">Which One Should You Use?</a></h2></div>

<ul>
<li>
If the action depends on a knob change, use <code>nuke.addKnobChanged()</code>. (e.g., auto-adjusting values when a user modifies something).

<li>
If the UI needs refreshing after changes, but reacting to every change is too much, use <code>nuke.addUpdateUI()</code>.

</ul>
<div id="Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?"><h2 id="How are these methods applied to specific nodes, and not the whole script?" class="header"><a href="#Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?">How are these methods applied to specific nodes, and not the whole script?</a></h2></div>

<p>
To apply <code>nuke.addKnobChanged()</code> and <code>nuke.addUpdateUI()</code> to specific nodes instead of globally affecting the whole script, you need to bind the callback to a specific node and verify that the event applies to that node alone.
</p>

<div id="Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?-Applying nuke.addKnobChanged() to a Specific Node"><h3 id="Applying nuke.addKnobChanged() to a Specific Node" class="header"><a href="#Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?-Applying nuke.addKnobChanged() to a Specific Node">Applying nuke.addKnobChanged() to a Specific Node</a></h3></div>

<p>
To ensure the callback only affects a particular node (e.g., "Blur1"), modify the function like this:
</p>

<pre python>
import nuke

def on_knob_changed(knob):
    node = knob.node()
    
    if node.name() == "Blur1":  # Only affect this specific node
        print(f"Knob {knob.name()} changed in {node.name()}!")
        # Example: Auto-set blur size
        if knob.name() == "size":
            node["size"].setValue(50)  # Adjust value when changed

# Register the callback
nuke.addKnobChanged(on_knob_changed)
</pre>

<div id="Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?-Applying nuke.addKnobChanged() to a Specific Node-How This Works:"><h4 id="How This Works:" class="header"><a href="#Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?-Applying nuke.addKnobChanged() to a Specific Node-How This Works:">How This Works:</a></h4></div>

<ul>
<li>
<code>knob.node()</code> retrieves the node linked to the knob change.

<li>
<code>node.name()</code> ensures only <code>Blur1</code> is affected.

<li>
<code>knob.name()</code> filters for specific knob interactions (like <code>size</code>).

</ul>
<div id="Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?-Applying `nuke.addUpdateUI()` to a Specific Node"><h3 id="Applying `nuke.addUpdateUI()` to a Specific Node" class="header"><a href="#Nuke - Python - knobChanged-How are these methods applied to specific nodes, and not the whole script?-Applying `nuke.addUpdateUI()` to a Specific Node">Applying <code>nuke.addUpdateUI()</code> to a Specific Node</a></h3></div>

<p>
If you only want UI updates for a specific node instead of running updates across the entire script, use this approach:
</p>

<pre python>
import nuke

def update_ui():
    node = nuke.toNode("Blur1")  # Target a specific node
    if node:
        node["label"].setValue("UI refreshed!")  # Example: Update UI label

# Register the callback
nuke.addUpdateUI(update_ui)
</pre>

<div id="Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better"><h2 id="Why nuke.addUpdateUI() Might Be Better" class="header"><a href="#Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better">Why nuke.addUpdateUI() Might Be Better</a></h2></div>

<ul>
<li>
Lighter on performance than <code>nuke.addKnobChanged()</code> (which triggers on every knob change).

<li>
Updates only when Nuke redraws the UI, making it useful for batch updates.

</ul>
<div id="Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better-Final Comparison"><h3 id="Final Comparison" class="header"><a href="#Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better-Final Comparison">Final Comparison</a></h3></div>

<table>
<tr>
<td>
<span id="Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better-Final Comparison-Method"></span><strong id="Method">Method</strong>
</td>
<td>
<span id="Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better-Final Comparison-When It Runs"></span><strong id="When It Runs">When It Runs</strong>
</td>
<td>
<span id="Nuke - Python - knobChanged-Why nuke.addUpdateUI() Might Be Better-Final Comparison-Best Use"></span><strong id="Best Use">Best Use</strong>
</td>
</tr>
<tr>
<td>
nuke.addKnobChanged()
</td>
<td>
Every time a knob changes
</td>
<td>
Immediate reactions, automated tweaks
</td>
</tr>
<tr>
<td>
nuke.addUpdateUI()
</td>
<td>
When UI needs refreshing
</td>
<td>
Prevent unnecessary executions, improve performance
</td>
</tr>
</table>


<div id="Examples"><h1 id="Examples" class="header"><a href="#Examples">Examples</a></h1></div>

<p>
Here's an example using both nuke.addKnobChanged() and nuke.addUpdateUI() together for optimized behavior.
</p>

<div id="Examples-Scenario: Auto-Update a Label When a Knob Changes"><h2 id="Scenario: Auto-Update a Label When a Knob Changes" class="header"><a href="#Examples-Scenario: Auto-Update a Label When a Knob Changes">Scenario: Auto-Update a Label When a Knob Changes</a></h2></div>

<p>
Let‚Äôs say we have a node (e.g., "Blur1") and want to:
</p>

<ul>
<li>
Detect when the size knob changes (using <code>nuke.addKnobChanged()</code>).

<li>
Refresh the UI efficiently without excessive updates (using <code>nuke.addUpdateUI()</code>).

</ul>
<div id="Examples-Step 1: Define the Knob Change Callback"><h2 id="Step 1: Define the Knob Change Callback" class="header"><a href="#Examples-Step 1: Define the Knob Change Callback">Step 1: Define the Knob Change Callback</a></h2></div>

<p>
This function triggers only when the knob in "Blur1" changes:
</p>

<pre python>
import nuke

def knob_changed(knob):
    node = knob.node()

    if node.name() == "Blur1" and knob.name() == "size":
        print(f"Blur size updated to: {knob.value()}")

        # Set a label so the user sees the latest size
        node["label"].setValue(f"Size: {knob.value()}")

# Register the callback for knob changes
nuke.addKnobChanged(knob_changed)
</pre>

<p>
‚úÖ Purpose: React immediately when the knob is changed.
</p>

<div id="Examples-Step 2: Use nuke.addUpdateUI() for Smooth UI Refresh"><h2 id="Step 2: Use nuke.addUpdateUI() for Smooth UI Refresh" class="header"><a href="#Examples-Step 2: Use nuke.addUpdateUI() for Smooth UI Refresh">Step 2: Use nuke.addUpdateUI() for Smooth UI Refresh</a></h2></div>

<p>
Instead of updating every time a knob changes, we only refresh the UI when needed:
</p>

<pre python>
def update_ui():
    node = nuke.toNode("Blur1")
    if node:
        print("Refreshing UI for Blur1...")
        node["label"].setValue("UI refreshed!")

# Register UI update callback
nuke.addUpdateUI(update_ui)
</pre>

<p>
‚úÖ Purpose: Prevent unnecessary updates while keeping the UI responsive.
</p>

<div id="Examples-Step 2: Use nuke.addUpdateUI() for Smooth UI Refresh-How These Work Together"><h3 id="How These Work Together" class="header"><a href="#Examples-Step 2: Use nuke.addUpdateUI() for Smooth UI Refresh-How These Work Together">How These Work Together</a></h3></div>

<ul>
<li>
<code>knob_changed()</code> updates the label immediately when the size knob changes.

<li>
<code>update_ui()</code> ensures UI elements refresh only when necessary (e.g., on redraw events).

</ul>
<p>
By combining both callbacks, you: ‚úÖ Keep knob interactions fast and responsive. ‚úÖ Avoid excessive UI redraws, improving performance. ‚úÖ Ensure UI updates only when required, reducing overhead.
</p>

<div id="Multiple Knobs - Dynamically"><h1 id="Multiple Knobs - Dynamically" class="header"><a href="#Multiple Knobs - Dynamically">Multiple Knobs - Dynamically</a></h1></div>

<p>
Let's extend this setup so it can handle multiple knobs dynamically without requiring manual filtering.
</p>

<div id="Multiple Knobs - Dynamically-Enhancing nuke.addKnobChanged() to Handle Multiple Knobs"><h2 id="Enhancing nuke.addKnobChanged() to Handle Multiple Knobs" class="header"><a href="#Multiple Knobs - Dynamically-Enhancing nuke.addKnobChanged() to Handle Multiple Knobs">Enhancing nuke.addKnobChanged() to Handle Multiple Knobs</a></h2></div>

<p>
Instead of checking for just "size", we can handle multiple knobs across different nodes using a dictionary:
</p>

<pre python>
import nuke

# Define which knobs should trigger updates and their corresponding actions
knob_actions = {
    "Blur1": {
        "size": lambda node, knob: node["label"].setValue(f"Size: {knob.value()}"),
        "mix": lambda node, knob: print(f"Blur mix changed to: {knob.value()}"),
    },
    "Transform1": {
        "translate": lambda node, knob: node["label"].setValue(f"Translate: {knob.value()}"),
    }
}

def knob_changed(knob):
    node = knob.node()
    node_name = node.name()
    knob_name = knob.name()
    
    # Check if the node and knob have a defined action
    if node_name in knob_actions and knob_name in knob_actions[node_name]:
        knob_actions[node_name][knob_name](node, knob)  # Execute the mapped function

# Register the callback for knob changes
nuke.addKnobChanged(knob_changed)
</pre>

<div id="Multiple Knobs - Dynamically-Enhancing nuke.addKnobChanged() to Handle Multiple Knobs-How This Works:"><h3 id="How This Works:" class="header"><a href="#Multiple Knobs - Dynamically-Enhancing nuke.addKnobChanged() to Handle Multiple Knobs-How This Works:">How This Works:</a></h3></div>

<ul>
<li>
Define a dictionary (knob_actions) that maps:

<ul>
<li>
Node names (e.g., <code>Blur1</code>, <code>Transform1</code>).

<li>
Knob names (e.g., <code>size</code>, <code>mix</code>, <code>translate</code>).

<li>
Functions that execute the relevant updates.

</ul>
<li>
<code>knob_changed()</code> checks if the changed knob exists in <code>knob_actions</code> and runs its mapped function dynamically.

<li>
Easily add new knobs to be tracked without modifying the core function.

</ul>
<div id="Multiple Knobs - Dynamically-Enhancing `nuke.addUpdateUI()` for Multi-Node Updates"><h2 id="Enhancing `nuke.addUpdateUI()` for Multi-Node Updates" class="header"><a href="#Multiple Knobs - Dynamically-Enhancing `nuke.addUpdateUI()` for Multi-Node Updates">Enhancing <code>nuke.addUpdateUI()</code> for Multi-Node Updates</a></h2></div>

<p>
Now, let's ensure UI updates only refresh necessary nodes instead of affecting the whole script:
</p>

<pre python>
def update_ui():
    tracked_nodes = ["Blur1", "Transform1"]  # List of nodes that require UI updates
    for node_name in tracked_nodes:
        node = nuke.toNode(node_name)
        if node:
            print(f"Refreshing UI for {node_name}...")
            node["label"].setValue("UI refreshed!")

# Register UI update callback
nuke.addUpdateUI(update_ui)
</pre>

<div id="Multiple Knobs - Dynamically-Enhancing `nuke.addUpdateUI()` for Multi-Node Updates-How This Works:"><h3 id="How This Works:" class="header"><a href="#Multiple Knobs - Dynamically-Enhancing `nuke.addUpdateUI()` for Multi-Node Updates-How This Works:">How This Works:</a></h3></div>

<ul>
<li>
Updates only nodes that matter (<code>Blur1</code> and <code>Transform1</code>).

<li>
Doesn't waste cycles on unnecessary UI refreshes, improving performance.

</ul>
<div id="Multiple Knobs - Dynamically-Enhancing `nuke.addUpdateUI()` for Multi-Node Updates-Final Optimization"><h3 id="Final Optimization" class="header"><a href="#Multiple Knobs - Dynamically-Enhancing `nuke.addUpdateUI()` for Multi-Node Updates-Final Optimization">Final Optimization</a></h3></div>

<p>
By combining event-driven updates (<code>nuke.addKnobChanged()</code>) with controlled UI refreshes (<code>nuke.addUpdateUI()</code>), you get:
</p>
<ul>
<li>
‚úÖ Dynamic handling of multiple nodes and knobs.

<li>
‚úÖ Optimized performance, preventing unnecessary updates.

<li>
‚úÖ Flexible scaling, so adding more knobs/nodes is effortless.

</ul>
<div id="Advanced Logic"><h1 id="Advanced Logic" class="header"><a href="#Advanced Logic">Advanced Logic</a></h1></div>

<p>
Let‚Äôs take this automation to the next level with custom expressions and advanced logic when knobs change.
</p>

<div id="Advanced Logic-Extending nuke.addKnobChanged() with Custom Automation"><h2 id="Extending nuke.addKnobChanged() with Custom Automation" class="header"><a href="#Advanced Logic-Extending nuke.addKnobChanged() with Custom Automation">Extending nuke.addKnobChanged() with Custom Automation</a></h2></div>

<p>
Instead of just updating UI elements, let‚Äôs trigger actions dynamically based on knob changes.
</p>

<div id="Advanced Logic-Extending nuke.addKnobChanged() with Custom Automation-Example: Auto-Set Values Based on Knob Input"><h4 id="Example: Auto-Set Values Based on Knob Input" class="header"><a href="#Advanced Logic-Extending nuke.addKnobChanged() with Custom Automation-Example: Auto-Set Values Based on Knob Input">Example: Auto-Set Values Based on Knob Input</a></h4></div>

<p>
Imagine we want to automatically adjust the mix knob when the size knob changes in a "Blur1" node:
</p>

<pre python>
import nuke

def knob_changed(knob):
    node = knob.node()
    node_name = node.name()
    knob_name = knob.name()
    
    if node_name == "Blur1" and knob_name == "size":
        size_value = knob.value()
        
        # Set `mix` based on `size` dynamically
        mix_value = size_value / 100.0
        node["mix"].setValue(mix_value)

        print(f"Blur size changed to {size_value}, setting mix to {mix_value}")

# Register the callback
nuke.addKnobChanged(knob_changed)
</pre>

<div id="Advanced Logic-‚úÖ What This Does:"><h2 id="‚úÖ What This Does:" class="header"><a href="#Advanced Logic-‚úÖ What This Does:">‚úÖ What This Does:</a></h2></div>

<ul>
<li>
Detects changes to size and dynamically updates mix.

<li>
Applies a custom formula to tweak values intelligently.

<li>
Prevents manual adjustments by automating dependent values.

</ul>
<div id="Advanced Logic-‚úÖ What This Does:-Adding Custom Expressions Inside Knobs"><h3 id="Adding Custom Expressions Inside Knobs" class="header"><a href="#Advanced Logic-‚úÖ What This Does:-Adding Custom Expressions Inside Knobs">Adding Custom Expressions Inside Knobs</a></h3></div>

<p>
If you want to attach automatic expressions rather than manually scripting updates, you can inject Python expressions into knobs.
</p>

<div id="Advanced Logic-‚úÖ What This Does:-Adding Custom Expressions Inside Knobs-Example: Link size to mix Without a Script"><h4 id="Example: Link size to mix Without a Script" class="header"><a href="#Advanced Logic-‚úÖ What This Does:-Adding Custom Expressions Inside Knobs-Example: Link size to mix Without a Script">Example: Link size to mix Without a Script</a></h4></div>

<p>
You can manually add this expression into mix:
</p>

<pre>
size / 100.0
</pre>

<p>
Or dynamically add it via Python:
</p>

<pre python>
node = nuke.toNode("Blur1")
if node:
    node["mix"].setExpression("size / 100.0")
</pre>

<div id="Advanced Logic-‚úÖ Why Use Expressions Instead?"><h2 id="‚úÖ Why Use Expressions Instead?" class="header"><a href="#Advanced Logic-‚úÖ Why Use Expressions Instead?">‚úÖ Why Use Expressions Instead?</a></h2></div>

<ul>
<li>
Less overhead than a script.

<li>
Updates in real-time, without needing callbacks.

</ul>
<div id="Advanced Logic-Enhancing nuke.addUpdateUI() with Conditional Refresh"><h2 id="Enhancing nuke.addUpdateUI() with Conditional Refresh" class="header"><a href="#Advanced Logic-Enhancing nuke.addUpdateUI() with Conditional Refresh">Enhancing nuke.addUpdateUI() with Conditional Refresh</a></h2></div>

<p>
Instead of updating the UI for every knob, we can refresh only when a threshold is met.
</p>

<div id="Advanced Logic-Enhancing nuke.addUpdateUI() with Conditional Refresh-Example: Refresh UI Only If size Exceeds 50"><h4 id="Example: Refresh UI Only If size Exceeds 50" class="header"><a href="#Advanced Logic-Enhancing nuke.addUpdateUI() with Conditional Refresh-Example: Refresh UI Only If size Exceeds 50">Example: Refresh UI Only If size Exceeds 50</a></h4></div>

<pre python>
def update_ui():
    node = nuke.toNode("Blur1")
    if node:
        size_value = node["size"].value()

        if size_value &gt; 50:  # Refresh only if size exceeds 50
            node["label"].setValue(f"Large Blur: {size_value}")
            print("UI refreshed due to large blur size.")

# Register the callback
nuke.addUpdateUI(update_ui)
</pre>

<div id="Advanced Logic-‚úÖ What This Does:"><h2 id="‚úÖ What This Does:" class="header"><a href="#Advanced Logic-‚úÖ What This Does:">‚úÖ What This Does:</a></h2></div>

<ul>
<li>
Only updates UI when <code>size</code> exceeds 50, reducing unnecessary refreshes.

<li>
Optimizes performance, preventing excessive redraws.

</ul>
<div id="Advanced Logic-Combining Everything for a Smart System"><h2 id="Combining Everything for a Smart System" class="header"><a href="#Advanced Logic-Combining Everything for a Smart System">Combining Everything for a Smart System</a></h2></div>

<p>
Now, putting it all together:
</p>
<ul>
<li>
‚úÖ Detect knob changes (nuke.addKnobChanged())

<li>
‚úÖ Automate dependent values dynamically

<li>
‚úÖ Use expressions where possible

<li>
‚úÖ Optimize UI refresh (nuke.addUpdateUI())

</ul>
<div id="Event Driven Workflows"><h1 id="Event Driven Workflows" class="header"><a href="#Event Driven Workflows">Event Driven Workflows</a></h1></div>

<p>
Let's push this further by incorporating event-driven workflows, dynamic UI changes, and knob dependencies across multiple nodes for a more automated Nuke scripting experience.
</p>

<div id="Event Driven Workflows-Automatically Link Knobs Between Nodes"><h2 id="Automatically Link Knobs Between Nodes" class="header"><a href="#Event Driven Workflows-Automatically Link Knobs Between Nodes">Automatically Link Knobs Between Nodes</a></h2></div>

<p>
Sometimes, you want one node‚Äôs knob to automatically influence another node without manually setting up expressions. We can achieve this using <code>nuke.addKnobChanged()</code>.
</p>

<div id="Event Driven Workflows-Automatically Link Knobs Between Nodes-Example: Connect Blur Size to a Transform Node"><h4 id="Example: Connect Blur Size to a Transform Node" class="header"><a href="#Event Driven Workflows-Automatically Link Knobs Between Nodes-Example: Connect Blur Size to a Transform Node">Example: Connect Blur Size to a Transform Node</a></h4></div>

<pre python>
import nuke

def sync_knob_values(knob):
    blur_node = nuke.toNode("Blur1")
    transform_node = nuke.toNode("Transform1")

    if knob.node() == blur_node and knob.name() == "size":
        new_value = knob.value()
        transform_node["translate"].setValue(new_value * 2)  # Example scaling rule
        print(f"Updated Transform1 translate to: {new_value * 2}")

nuke.addKnobChanged(sync_knob_values)
</pre>

<div id="Event Driven Workflows-Automatically Link Knobs Between Nodes-‚úÖ What This Does:"><h3 id="‚úÖ What This Does:" class="header"><a href="#Event Driven Workflows-Automatically Link Knobs Between Nodes-‚úÖ What This Does:">‚úÖ What This Does:</a></h3></div>

<ul>
<li>
Whenever <code>Blur1</code>'s <code>size</code> knob changes, it updates <code>Transform1</code>'s translate knob dynamically.

<li>
Applies a simple scaling rule (<code>size * 2</code>), but you can extend it to complex dependencies.

</ul>
<div id="Event Driven Workflows-Toggle UI Elements Based on Conditions"><h2 id="Toggle UI Elements Based on Conditions" class="header"><a href="#Event Driven Workflows-Toggle UI Elements Based on Conditions">Toggle UI Elements Based on Conditions</a></h2></div>

<p>
If you want the UI to show or hide elements dynamically, <code>nuke.addKnobChanged()</code> can control knob visibility.
</p>

<div id="Event Driven Workflows-Toggle UI Elements Based on Conditions-Example: Hide/Show a Knob Based on Another Knob‚Äôs Value"><h4 id="Example: Hide/Show a Knob Based on Another Knob‚Äôs Value" class="header"><a href="#Event Driven Workflows-Toggle UI Elements Based on Conditions-Example: Hide/Show a Knob Based on Another Knob‚Äôs Value">Example: Hide/Show a Knob Based on Another Knob‚Äôs Value</a></h4></div>

<pre python>
def toggle_knob_visibility(knob):
    node = knob.node()
    
    if knob.name() == "enable_feature":
        node["advanced_setting"].setVisible(knob.value() == 1)  # Hide unless enabled

nuke.addKnobChanged(toggle_knob_visibility)
</pre>

<div id="Event Driven Workflows-Toggle UI Elements Based on Conditions-‚úÖ What This Does:"><h3 id="‚úÖ What This Does:" class="header"><a href="#Event Driven Workflows-Toggle UI Elements Based on Conditions-‚úÖ What This Does:">‚úÖ What This Does:</a></h3></div>

<ul>
<li>
If <code>enable_feature</code> is checked (<code>== 1</code>), the hidden <code>advanced_setting</code> knob becomes visible.

<li>
Prevents clutter‚Äîonly relevant knobs appear when needed.

</ul>
<div id="Event Driven Workflows-Create a Dynamic Gizmo That Adapts to User Input"><h2 id="Create a Dynamic Gizmo That Adapts to User Input" class="header"><a href="#Event Driven Workflows-Create a Dynamic Gizmo That Adapts to User Input">Create a Dynamic Gizmo That Adapts to User Input</a></h2></div>

<p>
Let‚Äôs say you have a custom gizmo that should dynamically adjust its internal setup based on user input.
</p>

<div id="Event Driven Workflows-Create a Dynamic Gizmo That Adapts to User Input-Example: Modify Gizmo Behavior in Real-Time"><h4 id="Example: Modify Gizmo Behavior in Real-Time" class="header"><a href="#Event Driven Workflows-Create a Dynamic Gizmo That Adapts to User Input-Example: Modify Gizmo Behavior in Real-Time">Example: Modify Gizmo Behavior in Real-Time</a></h4></div>

<pre python>
def adjust_gizmo_settings(knob):
    node = knob.node()
    
    if knob.name() == "effect_intensity":
        new_value = knob.value()
        
        # Dynamically adjust multiple internal settings
        node["detail_amount"].setValue(new_value * 0.5)
        node["sharpness"].setValue(new_value * 1.2)
        
        print(f"Gizmo updated: Detail={new_value * 0.5}, Sharpness={new_value * 1.2}")

nuke.addKnobChanged(adjust_gizmo_settings)
</pre>

<div id="Event Driven Workflows-Create a Dynamic Gizmo That Adapts to User Input-‚úÖ What This Does:"><h3 id="‚úÖ What This Does:" class="header"><a href="#Event Driven Workflows-Create a Dynamic Gizmo That Adapts to User Input-‚úÖ What This Does:">‚úÖ What This Does:</a></h3></div>

<ul>
<li>
Adjusts detail_amount and sharpness dynamically based on effect_intensity.

<li>
Works well for procedural effects that adapt to user control.

</ul>
<div id="Event Driven Workflows-Batch Process Knobs Across Multiple Nodes"><h2 id="Batch Process Knobs Across Multiple Nodes" class="header"><a href="#Event Driven Workflows-Batch Process Knobs Across Multiple Nodes">Batch Process Knobs Across Multiple Nodes</a></h2></div>

<p>
If you need to modify a whole set of nodes at once (instead of tracking individual knob changes), nuke.addUpdateUI() helps streamline updates.
</p>

<div id="Event Driven Workflows-Batch Process Knobs Across Multiple Nodes-Example: Apply a Global Adjustment to All Blur Nodes"><h4 id="Example: Apply a Global Adjustment to All Blur Nodes" class="header"><a href="#Event Driven Workflows-Batch Process Knobs Across Multiple Nodes-Example: Apply a Global Adjustment to All Blur Nodes">Example: Apply a Global Adjustment to All Blur Nodes</a></h4></div>

<pre python>
def update_blur_nodes():
    blur_nodes = [node for node in nuke.allNodes("Blur")]

    for node in blur_nodes:
        node["size"].setValue(25)  # Apply new blur size globally
        print(f"Updated {node.name()} to size 25")

nuke.addUpdateUI(update_blur_nodes)
</pre>

<div id="Event Driven Workflows-Batch Process Knobs Across Multiple Nodes-‚úÖ What This Does:"><h3 id="‚úÖ What This Does:" class="header"><a href="#Event Driven Workflows-Batch Process Knobs Across Multiple Nodes-‚úÖ What This Does:">‚úÖ What This Does:</a></h3></div>

<ul>
<li>
Runs only when needed, instead of reacting to every knob adjustment.

<li>
Efficiently applies a global setting across all nodes of a certain type.

</ul>
<div id="Event Driven Workflows-Build an Adaptive UI System"><h2 id="Build an Adaptive UI System" class="header"><a href="#Event Driven Workflows-Build an Adaptive UI System">Build an Adaptive UI System</a></h2></div>

<p>
To make an intelligent UI that responds to usage patterns, we can integrate custom logic into knob changes.
</p>

<div id="Event Driven Workflows-Build an Adaptive UI System-Example: Automatically Disable Unused Features"><h4 id="Example: Automatically Disable Unused Features" class="header"><a href="#Event Driven Workflows-Build an Adaptive UI System-Example: Automatically Disable Unused Features">Example: Automatically Disable Unused Features</a></h4></div>

<pre python>
def auto_disable_unused_features(knob):
    node = knob.node()
    
    if knob.name() == "effect_mode":
        selected_mode = knob.value()
        
        if selected_mode == 0:  # Assume mode 0 disables extra features
            node["extra_detail"].setEnabled(False)
            node["fine_tune"].setEnabled(False)
        else:
            node["extra_detail"].setEnabled(True)
            node["fine_tune"].setEnabled(True)

nuke.addKnobChanged(auto_disable_unused_features)
</pre>

<div id="Event Driven Workflows-Build an Adaptive UI System-‚úÖ What This Does:"><h3 id="‚úÖ What This Does:" class="header"><a href="#Event Driven Workflows-Build an Adaptive UI System-‚úÖ What This Does:">‚úÖ What This Does:</a></h3></div>

<ul>
<li>
Disables certain knobs when a specific effect mode is selected (<code>mode 0</code>).

<li>
Prevents users from modifying settings that aren't relevant.

</ul>
<div id="Event Driven Workflows-Build an Adaptive UI System-Where This Could Go Next"><h3 id="Where This Could Go Next" class="header"><a href="#Event Driven Workflows-Build an Adaptive UI System-Where This Could Go Next">Where This Could Go Next</a></h3></div>

<ul>
<li>
üöÄ Want even more automation? We could:

<ul>
<li>
‚úÖ Implement dynamic presets that adjust settings intelligently.

<li>
‚úÖ Create UI elements that change layouts automatically.

<li>
‚úÖ Introduce expressions that interact with external scripts (like file paths).

</ul>
</ul>
<hr />

<div id="Another Approach to the Notes"><h1 id="Another Approach to the Notes" class="header"><a href="#Another Approach to the Notes">Another Approach to the Notes</a></h1></div>

<div id="Another Approach to the Notes-knobChanged"><h2 id="knobChanged" class="header"><a href="#Another Approach to the Notes-knobChanged">knobChanged</a></h2></div>

<p>
The <code>nuke.knobChanged()</code> mechanism is a way in Nuke to set up callbacks that run whenever one or more knobs on a node change their values. In many cases, a node is created with a hidden knob called <code>"knobChanged"</code> ‚Äî this knob can hold a string of Python code, and that code is executed after the user manipulates any of the node‚Äôs knobs (unless that knob is flagged to bypass these callbacks) .
</p>

<div id="Another Approach to the Notes-What It Does"><h2 id="What It Does" class="header"><a href="#Another Approach to the Notes-What It Does">What It Does</a></h2></div>

<ul>
<li>
<span id="Another Approach to the Notes-What It Does-Event Callback"></span><strong id="Event Callback">Event Callback</strong>: When a user changes a knob (for example, toggling a checkbox or sliding a numeric value), Nuke calls the function specified in the "knobChanged" knob. This mechanism allows you to automatically respond to changes‚Äîsuch as enabling/disabling other knobs, showing/hiding UI controls, or updating dependent parameters.

<li>
<span id="Another Approach to the Notes-What It Does-Accessing the Change"></span><strong id="Accessing the Change">Accessing the Change</strong>: Inside your callback function, you can access the node and the specific knob that changed by using the helper functions:

<ul>
<li>
<code>nuke.thisNode()</code> returns the node that triggered the change.

<li>
<code>nuke.thisKnob()</code> returns the knob object that was altered.

</ul>
</ul>
<div id="Another Approach to the Notes-How to Use It"><h2 id="How to Use It" class="header"><a href="#Another Approach to the Notes-How to Use It">How to Use It</a></h2></div>

<p>
There are two common ways to use knobChanged:
</p>
<ul>
<li>
<span id="Another Approach to the Notes-How to Use It-Directly Assigning Code to the Hidden Knob"></span><strong id="Directly Assigning Code to the Hidden Knob">Directly Assigning Code to the Hidden Knob</strong>: You can assign a one‚Äëline string of code so that each time any knob is changed, that code runs. For example:

</ul>
  
<pre python>
nuke.selectedNode().knob('knobChanged').setValue(
    "n = nuke.thisNode(); k = nuke.thisKnob(); "
    "if k.name() == 'myCheckbox' and k.value() == True: "
    "    n['dependentKnob'].setEnabled(False); "
    "else: "
    "    n['dependentKnob'].setEnabled(True)"
)
</pre>

<p>
In this example, whenever any knob is changed, the code checks if the changed knob's name is <code>"myCheckbox"</code>. If so, it enables or disables <code>"dependentKnob"</code> as desired. (Note that for Nuke to properly process multi‚Äëline code, you generally have to compress the code to a single line with explicit semicolons or newline escapes.)
</p>
<ul>
<li>
<span id="Another Approach to the Notes-How to Use It-Defining a Callback Function in an External Module"></span><strong id="Defining a Callback Function in an External Module">Defining a Callback Function in an External Module</strong>: A more flexible approach is to define a Python function‚Äîsay, in your Nuke startup scripts or a separate module‚Äîand then set the "knobChanged" knob to call that function. For example:

</ul>
  
<pre python>
# In your module, e.g., myCallbacks.py
def knob_changed_callback():
    n = nuke.thisNode()
    k = nuke.thisKnob()
    # Check which knob changed and act accordingly.
    if k.name() == 'myMode':
        # For instance, adjust other knobs based on the mode:
        if k.value() == 1:
            n['optionA'].setEnabled(True)
            n['optionB'].setEnabled(False)
        else:
            n['optionA'].setEnabled(False)
            n['optionB'].setEnabled(True)

# Then assign this code to the selected node's knobChanged knob:
nuke.selectedNode().knob('knobChanged').setValue("myCallbacks.knob_changed_callback()")
</pre>

<p>
This method keeps your code modular and easier to maintain‚Äîif you update the callback function, all nodes referencing it will automatically use the new behavior .
</p>

<div id="Another Approach to the Notes-Best Practices"><h2 id="Best Practices" class="header"><a href="#Another Approach to the Notes-Best Practices">Best Practices</a></h2></div>

<ul>
<li>
<span id="Another Approach to the Notes-Best Practices-Selective Behavior"></span><strong id="Selective Behavior">Selective Behavior</strong>: It‚Äôs common to check the name of the knob that caused the change using <code>nuke.thisKnob().name()</code>. This way, your code only does extra work if the knob you care about was adjusted.

<li>
<span id="Another Approach to the Notes-Best Practices-Chaining Calls"></span><strong id="Chaining Calls">Chaining Calls</strong>: For custom operators (Ops) or Gizmos, if you override an existing <code>knobChanged</code> method, it‚Äôs good practice to call the parent class‚Äôs <code>knobChanged</code> at the end. This ensures that any in‚Äëbuilt functionality remains intact .

<li>
<span id="Another Approach to the Notes-Best Practices-One-Liner Code Strings"></span><strong id="One-Liner Code Strings">One-Liner Code Strings</strong>: Because the value passed to a knob must be a string, your callback code is often written on a single line with semicolons separating statements or with newline characters (<code>\n</code>) if you prefer the code to be more readable when editing in your text editor.

</ul>
<div id="Another Approach to the Notes-Best Practices-Summary"><h3 id="Summary" class="header"><a href="#Another Approach to the Notes-Best Practices-Summary">Summary</a></h3></div>

<p>
<code>nuke.knobChanged()</code> is less a function you call and more a callback mechanism. You ‚Äúinstall‚Äù your custom code to be triggered each time a knob's value changes on a node. This can be done directly by setting the hidden <code>"knobChanged"</code> knob with a code string or by referencing an externally defined Python function. Both techniques enable dynamic UI behavior in Nuke, like conditionally enabling/disabling or hiding/showing other knobs based on user interaction.
</p>

<div id="Common Usage"><h1 id="Common Usage" class="header"><a href="#Common Usage">Common Usage</a></h1></div>

<p>
It's very common and by design for custom panels or nodes in Nuke to include a method named knobChanged. While this name isn‚Äôt a built‚Äëin Python keyword, it is the expected callback that Nuke looks for when a knob‚Äôs value changes on a panel or node.
</p>

<div id="Common Usage-What It Does"><h2 id="What It Does" class="header"><a href="#Common Usage-What It Does">What It Does</a></h2></div>

<ul>
<li>
<span id="Common Usage-What It Does-Callback Mechanism"></span><strong id="Callback Mechanism">Callback Mechanism</strong>: Nuke calls the knobChanged method on your panel or node whenever a knob is modified. In your example:
<pre python>
def knobChanged(self, knob):
    if knob is self.openScript:
        nuke.scriptOpen(self.script_path)
    if knob is self.refreshAll:
        refreshScripts = nukeScripts()
        self.scripts.setValues(refreshScripts)
</pre>

</ul>
<p>
The method receives the specific knob that changed as an argument. You can test which knob fired the event (using, for example, if knob is self.openScript:) and then run your custom logic accordingly.
</p>
<ul>
<li>
<span id="Common Usage-What It Does-Integration with Custom Panels"></span><strong id="Integration with Custom Panels">Integration with Custom Panels</strong>: When you subclass Nuke‚Äôs panel classes (like nukescripts.PythonPanel), the framework automatically calls knobChanged on your instance when any knob within the panel is altered by the user. This gives you a central place to handle interactions, update UI states, or trigger additional processing.

</ul>
<div id="Common Usage-Is the Name Special or Required?"><h2 id="Is the Name Special or Required?" class="header"><a href="#Common Usage-Is the Name Special or Required?">Is the Name Special or Required?</a></h2></div>

<ul>
<li>
<span id="Common Usage-Is the Name Special or Required?-Convention in Nuke"></span><strong id="Convention in Nuke">Convention in Nuke</strong>: The name <code>knobChanged</code> is not arbitrary; it‚Äôs part of the conventions that Nuke uses. When you create a custom panel or node using Nuke‚Äôs Python APIs, defining a <code>knobChanged</code> method tells Nuke, "When a knob changes, please call this method." It‚Äôs effectively a hook that the system uses to allow your custom code to respond to UI changes.

<li>
<span id="Common Usage-Is the Name Special or Required?-Built-in vs. Custom Implementation"></span><strong id="Built-in vs. Custom Implementation">Built-in vs. Custom Implementation</strong>: While you could implement other names if you manually attach a callback string to a knob, the advantage of using the method is clarity and integration. For panels, Nuke will automatically route knob changes to your <code>knobChanged</code> method if it exists. Thus, using this method is both common and recommended.

</ul>
<div id="Common Usage-Is the Name Special or Required?-In Summary"><h3 id="In Summary" class="header"><a href="#Common Usage-Is the Name Special or Required?-In Summary">In Summary</a></h3></div>

<ul>
<li>
<span id="Common Usage-Is the Name Special or Required?-In Summary-Common Practice"></span><strong id="Common Practice">Common Practice</strong>: Overriding or defining a <code>knobChanged</code> method in your custom panel class is standard practice‚Äîit integrates smoothly with Nuke‚Äôs event system.

<li>
<span id="Common Usage-Is the Name Special or Required?-In Summary-Naming Convention"></span><strong id="Naming Convention">Naming Convention</strong>: The name <code>knobChanged</code> isn‚Äôt imposed by Python itself, but it‚Äôs required by Nuke‚Äôs framework for panels and nodes that need to respond to knob modifications.

</ul>
<p>
This approach helps keep your UI behavior modular and maintainable; you simply check which knob changed and take action accordingly.
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="Index.html">Index</a>
</p>

</body>
</html>
