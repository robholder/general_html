<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_python_knob_changed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="Index.html">Index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="Nuke - Python - knobChanged"><h1 id="Nuke - Python - knobChanged" class="header"><a href="#Nuke - Python - knobChanged">Nuke - Python - knobChanged</a></h1></div>

<p>
The <code>nuke.knobChanged()</code> mechanism is a way in Nuke to set up callbacks that run whenever one or more knobs on a node change their values. In many cases, a node is created with a hidden knob called <code>"knobChanged"</code> — this knob can hold a string of Python code, and that code is executed after the user manipulates any of the node’s knobs (unless that knob is flagged to bypass these callbacks) .
</p>

<div id="Nuke - Python - knobChanged-What It Does"><h2 id="What It Does" class="header"><a href="#Nuke - Python - knobChanged-What It Does">What It Does</a></h2></div>

<ul>
<li>
<span id="Nuke - Python - knobChanged-What It Does-Event Callback"></span><strong id="Event Callback">Event Callback</strong>: When a user changes a knob (for example, toggling a checkbox or sliding a numeric value), Nuke calls the function specified in the "knobChanged" knob. This mechanism allows you to automatically respond to changes—such as enabling/disabling other knobs, showing/hiding UI controls, or updating dependent parameters.

<li>
<span id="Nuke - Python - knobChanged-What It Does-Accessing the Change"></span><strong id="Accessing the Change">Accessing the Change</strong>: Inside your callback function, you can access the node and the specific knob that changed by using the helper functions:

<ul>
<li>
<code>nuke.thisNode()</code> returns the node that triggered the change.

<li>
<code>nuke.thisKnob()</code> returns the knob object that was altered.

</ul>
</ul>
<div id="Nuke - Python - knobChanged-How to Use It"><h2 id="How to Use It" class="header"><a href="#Nuke - Python - knobChanged-How to Use It">How to Use It</a></h2></div>

<p>
There are two common ways to use knobChanged:
</p>
<ul>
<li>
<span id="Nuke - Python - knobChanged-How to Use It-Directly Assigning Code to the Hidden Knob"></span><strong id="Directly Assigning Code to the Hidden Knob">Directly Assigning Code to the Hidden Knob</strong>: You can assign a one‑line string of code so that each time any knob is changed, that code runs. For example:

</ul>
  
<pre python>
nuke.selectedNode().knob('knobChanged').setValue(
    "n = nuke.thisNode(); k = nuke.thisKnob(); "
    "if k.name() == 'myCheckbox' and k.value() == True: "
    "    n['dependentKnob'].setEnabled(False); "
    "else: "
    "    n['dependentKnob'].setEnabled(True)"
)
</pre>

<p>
In this example, whenever any knob is changed, the code checks if the changed knob's name is <code>"myCheckbox"</code>. If so, it enables or disables <code>"dependentKnob"</code> as desired. (Note that for Nuke to properly process multi‑line code, you generally have to compress the code to a single line with explicit semicolons or newline escapes.)
</p>
<ul>
<li>
<span id="Nuke - Python - knobChanged-How to Use It-Defining a Callback Function in an External Module"></span><strong id="Defining a Callback Function in an External Module">Defining a Callback Function in an External Module</strong>: A more flexible approach is to define a Python function—say, in your Nuke startup scripts or a separate module—and then set the "knobChanged" knob to call that function. For example:

</ul>
  
<pre python>
# In your module, e.g., myCallbacks.py
def knob_changed_callback():
    n = nuke.thisNode()
    k = nuke.thisKnob()
    # Check which knob changed and act accordingly.
    if k.name() == 'myMode':
        # For instance, adjust other knobs based on the mode:
        if k.value() == 1:
            n['optionA'].setEnabled(True)
            n['optionB'].setEnabled(False)
        else:
            n['optionA'].setEnabled(False)
            n['optionB'].setEnabled(True)

# Then assign this code to the selected node's knobChanged knob:
nuke.selectedNode().knob('knobChanged').setValue("myCallbacks.knob_changed_callback()")
</pre>

<p>
This method keeps your code modular and easier to maintain—if you update the callback function, all nodes referencing it will automatically use the new behavior .
</p>

<div id="Nuke - Python - knobChanged-Best Practices"><h2 id="Best Practices" class="header"><a href="#Nuke - Python - knobChanged-Best Practices">Best Practices</a></h2></div>

<ul>
<li>
<span id="Nuke - Python - knobChanged-Best Practices-Selective Behavior"></span><strong id="Selective Behavior">Selective Behavior</strong>: It’s common to check the name of the knob that caused the change using <code>nuke.thisKnob().name()</code>. This way, your code only does extra work if the knob you care about was adjusted.

<li>
<span id="Nuke - Python - knobChanged-Best Practices-Chaining Calls"></span><strong id="Chaining Calls">Chaining Calls</strong>: For custom operators (Ops) or Gizmos, if you override an existing <code>knobChanged</code> method, it’s good practice to call the parent class’s <code>knobChanged</code> at the end. This ensures that any in‑built functionality remains intact .

<li>
<span id="Nuke - Python - knobChanged-Best Practices-One-Liner Code Strings"></span><strong id="One-Liner Code Strings">One-Liner Code Strings</strong>: Because the value passed to a knob must be a string, your callback code is often written on a single line with semicolons separating statements or with newline characters (<code>\n</code>) if you prefer the code to be more readable when editing in your text editor.

</ul>
<div id="Nuke - Python - knobChanged-Best Practices-Summary"><h3 id="Summary" class="header"><a href="#Nuke - Python - knobChanged-Best Practices-Summary">Summary</a></h3></div>

<p>
<code>nuke.knobChanged()</code> is less a function you call and more a callback mechanism. You “install” your custom code to be triggered each time a knob's value changes on a node. This can be done directly by setting the hidden <code>"knobChanged"</code> knob with a code string or by referencing an externally defined Python function. Both techniques enable dynamic UI behavior in Nuke, like conditionally enabling/disabling or hiding/showing other knobs based on user interaction.
</p>

<div id="Common Usage"><h1 id="Common Usage" class="header"><a href="#Common Usage">Common Usage</a></h1></div>

<p>
It's very common and by design for custom panels or nodes in Nuke to include a method named knobChanged. While this name isn’t a built‑in Python keyword, it is the expected callback that Nuke looks for when a knob’s value changes on a panel or node.
</p>

<p>
This is an example from a media importer script:
</p>
<pre python>
def knobChanged(self, knob):
    if knob is self.openScript:
        nuke.scriptOpen(self.script_path)
    if knob is self.refreshAll:
        refreshScripts = nukeScripts()
        self.scripts.setValues(refreshScripts)
</pre>

<div id="Common Usage-What It Does"><h2 id="What It Does" class="header"><a href="#Common Usage-What It Does">What It Does</a></h2></div>

<ul>
<li>
<span id="Common Usage-What It Does-Callback Mechanism"></span><strong id="Callback Mechanism">Callback Mechanism</strong>: Nuke calls the knobChanged method on your panel or node whenever a knob is modified. In your example:
<pre python>
def knobChanged(self, knob):
    if knob is self.openScript:
        nuke.scriptOpen(self.script_path)
    if knob is self.refreshAll:
        refreshScripts = nukeScripts()
        self.scripts.setValues(refreshScripts)
</pre>

</ul>
<p>
The method receives the specific knob that changed as an argument. You can test which knob fired the event (using, for example, if knob is self.openScript:) and then run your custom logic accordingly.
</p>
<ul>
<li>
<span id="Common Usage-What It Does-Integration with Custom Panels"></span><strong id="Integration with Custom Panels">Integration with Custom Panels</strong>: When you subclass Nuke’s panel classes (like nukescripts.PythonPanel), the framework automatically calls knobChanged on your instance when any knob within the panel is altered by the user. This gives you a central place to handle interactions, update UI states, or trigger additional processing.

</ul>
<div id="Common Usage-Is the Name Special or Required?"><h2 id="Is the Name Special or Required?" class="header"><a href="#Common Usage-Is the Name Special or Required?">Is the Name Special or Required?</a></h2></div>

<ul>
<li>
<span id="Common Usage-Is the Name Special or Required?-Convention in Nuke"></span><strong id="Convention in Nuke">Convention in Nuke</strong>: The name <code>knobChanged</code> is not arbitrary; it’s part of the conventions that Nuke uses. When you create a custom panel or node using Nuke’s Python APIs, defining a <code>knobChanged</code> method tells Nuke, "When a knob changes, please call this method." It’s effectively a hook that the system uses to allow your custom code to respond to UI changes.

<li>
<span id="Common Usage-Is the Name Special or Required?-Built-in vs. Custom Implementation"></span><strong id="Built-in vs. Custom Implementation">Built-in vs. Custom Implementation</strong>: While you could implement other names if you manually attach a callback string to a knob, the advantage of using the method is clarity and integration. For panels, Nuke will automatically route knob changes to your <code>knobChanged</code> method if it exists. Thus, using this method is both common and recommended.

</ul>
<div id="Common Usage-Is the Name Special or Required?-In Summary"><h3 id="In Summary" class="header"><a href="#Common Usage-Is the Name Special or Required?-In Summary">In Summary</a></h3></div>

<ul>
<li>
<span id="Common Usage-Is the Name Special or Required?-In Summary-Common Practice"></span><strong id="Common Practice">Common Practice</strong>: Overriding or defining a <code>knobChanged</code> method in your custom panel class is standard practice—it integrates smoothly with Nuke’s event system.

<li>
<span id="Common Usage-Is the Name Special or Required?-In Summary-Naming Convention"></span><strong id="Naming Convention">Naming Convention</strong>: The name <code>knobChanged</code> isn’t imposed by Python itself, but it’s required by Nuke’s framework for panels and nodes that need to respond to knob modifications.

</ul>
<p>
This approach helps keep your UI behavior modular and maintainable; you simply check which knob changed and take action accordingly.
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="Index.html">Index</a>
</p>

</body>
</html>
