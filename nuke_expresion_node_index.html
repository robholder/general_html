<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_expresion_node_index</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="Nuke - Expression Node"><h1 id="Nuke - Expression Node" class="header"><a href="#Nuke - Expression Node">Nuke - Expression Node</a></h1></div>

<div id="Contents" class="toc"><h1 id="Contents" class="header"><a href="#Contents">Contents</a></h1></div>
<ul>
<li>
<a href="nuke_expresion_node_index.html#Nuke - Expression Node">Nuke - Expression Node</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Node Panel Quick Tip">Node Panel Quick Tip</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#General Syntax">General Syntax</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Nuke expression node: Conditional calculations">Nuke expression node: Conditional calculations</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Syntax">Syntax</a>

<li>
<a href="nuke_expresion_node_index.html#Examples">Examples</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Greater than or Equal &amp; Less than or Equal">Greater than or Equal &amp; Less than or Equal</a>

<li>
<a href="nuke_expresion_node_index.html#What about 'equal or less than'?">What about 'equal or less than'?</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Example for Floor Values">Example for Floor Values</a>

<li>
<a href="nuke_expresion_node_index.html#Divergent notes you might find handy:">Divergent notes you might find handy:</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Luminance">Luminance</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#In the Expression node:">In the Expression node:</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Fixing Single Pixel NaNs with an Expression">Fixing Single Pixel NaNs with an Expression</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Explanation">Explanation</a>

<li>
<a href="nuke_expresion_node_index.html#Applying to Other Channels">Applying to Other Channels</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Green Channel:">Green Channel:</a>

<li>
<a href="nuke_expresion_node_index.html#Blue Channel:">Blue Channel:</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Caveats">Caveats</a>

</ul>
</ul>
<li>
<a href="nuke_expresion_node_index.html#Edge Pixels">Edge Pixels</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Pre-Extend or Clamp the Image Data">Pre-Extend or Clamp the Image Data</a>

<li>
<a href="nuke_expresion_node_index.html#Conditional Sampling Within the Expression">Conditional Sampling Within the Expression</a>

<li>
<a href="nuke_expresion_node_index.html#Using an Upstream Node to Control Border Behavior">Using an Upstream Node to Control Border Behavior</a>

<li>
<a href="nuke_expresion_node_index.html#Final Thoughts">Final Thoughts</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Decimate an Image">Decimate an Image</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Summary">Summary</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Radial Vector Field Generator">Radial Vector Field Generator</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Convert pixel → local coordinates">Convert pixel → local coordinates</a>

<li>
<a href="nuke_expresion_node_index.html#Compute angles with atan">Compute angles with atan</a>

<li>
<a href="nuke_expresion_node_index.html#Extract vector components via sin(θ+π)">Extract vector components via sin(θ+π)</a>

<li>
<a href="nuke_expresion_node_index.html#What you get">What you get</a>

<li>
<a href="nuke_expresion_node_index.html#Variations and next steps">Variations and next steps</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Hooking up Implosion and Vortex in Nuke">Hooking up Implosion and Vortex in Nuke</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Implosion (Radial Inward Pull)">Implosion (Radial Inward Pull)</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Expression Node Setup">Expression Node Setup</a>

<li>
<a href="nuke_expresion_node_index.html#VectorDistort Node">VectorDistort Node</a>

<li>
<a href="nuke_expresion_node_index.html#Vortex (Tangential Swirl)">Vortex (Tangential Swirl)</a>

<li>
<a href="nuke_expresion_node_index.html#Fine-Tuning and Extensions">Fine-Tuning and Extensions</a>

</ul>
</ul>
<li>
<a href="nuke_expresion_node_index.html#Expression Node - Create Alpha from Color Pick">Expression Node - Create Alpha from Color Pick</a>

<li>
<a href="nuke_expresion_node_index.html#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value">Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#EXPLANATION:">EXPLANATION:</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#The Variables (Top half of Expression node's property panel):">The Variables (Top half of Expression node's property panel):</a>

<li>
<a href="nuke_expresion_node_index.html#The Channel Expressions (Bottom half of Expression node's property panel):">The Channel Expressions (Bottom half of Expression node's property panel):</a>

<li>
<a href="nuke_expresion_node_index.html#Pseudo Code in plain English::">Pseudo Code in plain English::</a>

</ul>
</ul>
<li>
<a href="nuke_expresion_node_index.html#Available Functions in Nuke's Expression Node">Available Functions in Nuke's Expression Node</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#What built-in functions are available to Nuke's Expression node?">What built-in functions are available to Nuke's Expression node?</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Built-in functions in Nuke's expression node">Built-in functions in Nuke's expression node</a>

<li>
<a href="nuke_expresion_node_index.html#Mathematical functions">Mathematical functions</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Basic Operations:">Basic Operations:</a>

<li>
<a href="nuke_expresion_node_index.html#Trigonometric Functions:">Trigonometric Functions:</a>

<li>
<a href="nuke_expresion_node_index.html#Hyperbolic Functions:">Hyperbolic Functions:</a>

<li>
<a href="nuke_expresion_node_index.html#Other Mathematical Functions:">Other Mathematical Functions:</a>

<li>
<a href="nuke_expresion_node_index.html#Channel and image-related functions">Channel and image-related functions</a>

<li>
<a href="nuke_expresion_node_index.html#Conditional logic">Conditional logic</a>

<li>
<a href="nuke_expresion_node_index.html#Animation and time">Animation and time</a>

<li>
<a href="nuke_expresion_node_index.html#Noise and randomness">Noise and randomness</a>

<li>
<a href="nuke_expresion_node_index.html#Accessing other knob values">Accessing other knob values</a>

<li>
<a href="nuke_expresion_node_index.html#Working with variables">Working with variables</a>

</ul>
</ul>
<div id="Nuke - Expression Node-Node Panel Quick Tip"><h2 id="Node Panel Quick Tip" class="header"><a href="#Nuke - Expression Node-Node Panel Quick Tip">Node Panel Quick Tip</a></h2></div>

<p>
There is a wrench on each node's property panel: click this to 'save' presets. These presets will appear as pulldown user choices. (Very handy for the Expression node.)
</p>

<div id="General Syntax"><h1 id="General Syntax" class="header"><a href="#General Syntax">General Syntax</a></h1></div>

<div id="General Syntax-Nuke expression node: Conditional calculations"><h2 id="Nuke expression node: Conditional calculations" class="header"><a href="#General Syntax-Nuke expression node: Conditional calculations">Nuke expression node: Conditional calculations</a></h2></div>

<p>
The Nuke Expression node allows you to perform conditional calculations on channels using expressions, which are evaluated for each pixel. 
</p>

<div id="General Syntax-Nuke expression node: Conditional calculations-Syntax"><h4 id="Syntax" class="header"><a href="#General Syntax-Nuke expression node: Conditional calculations-Syntax">Syntax</a></h4></div>

<p>
Nuke expressions use a C-like syntax for conditional calculations, often employing the ternary operator ( ? : ) as an equivalent to if-else statements. 
</p>

<p>
The general structure is:
</p>

<pre text>
condition ? value_if_true : value_if_false
</pre>

<div id="General Syntax-Nuke expression node: Conditional calculations-Examples"><h4 id="Examples" class="header"><a href="#General Syntax-Nuke expression node: Conditional calculations-Examples">Examples</a></h4></div>

<ul>
<li>
<span id="General Syntax-Nuke expression node: Conditional calculations-Examples-Example 1"></span><strong id="Example 1">Example 1</strong>: Simple ConditionalIf a channel's value r is greater than 0.5, set it to 1; otherwise, set it to 0. according to Foundry Community.

</ul>
  
<pre text>
r &gt; 0.5 ? 1 : 0 
</pre>

<ul>
<li>
<span id="General Syntax-Nuke expression node: Conditional calculations-Examples-Example 2"></span><strong id="Example 2">Example 2</strong>: Combining ConditionsIf r is greater than 0.5 AND g is less than 0.2, set b to 1; otherwise, set it to b's original value.

</ul>
  
<pre text>
r &gt; 0.5 &amp;&amp; g &lt; 0.2 ? 1 : b 
</pre>

<ul>
<li>
<span id="General Syntax-Nuke expression node: Conditional calculations-Examples-Example 3"></span><strong id="Example 3">Example 3</strong>: Referencing Other KnobsIf the value of a knob named myKnob on the same node is equal to 1, set r to 1; otherwise, set it to 0.

</ul>
  
<pre text>
myKnob == 1 ? 1 : 0
</pre>

<div id="General Syntax-Greater than or Equal &amp; Less than or Equal"><h2 id="Greater than or Equal &amp; Less than or Equal" class="header"><a href="#General Syntax-Greater than or Equal &amp; Less than or Equal">Greater than or Equal &amp; Less than or Equal</a></h2></div>

<p>
In Nuke’s Expression node you use the standard C‐style comparison operator <code>&gt;=</code> for “greater than or equal to.”
</p>

<p>
For example, to set alpha to 1 whenever R is at least 1 (and leave it unchanged otherwise), you could put in your expr3 (alpha) field:
</p>

<pre text>
(r &gt;= 1) ? 1 : a
</pre>

<p>
Or, combining R, G and B:
</p>

<pre text>
(r &gt;= 1 &amp;&amp; g &gt;= 1 &amp;&amp; b &gt;= 1) ? 1 : a
</pre>

<p>
Here:
</p>

<ul>
<li>
<code>&gt;=</code> tests “greater than or equal to”

<li>
<code>&amp;&amp;</code> is logical AND

<li>
<code>? … : …</code> is the ternary if/else operator

</ul>
<div id="General Syntax-What about 'equal or less than'?"><h2 id="What about 'equal or less than'?" class="header"><a href="#General Syntax-What about 'equal or less than'?">What about 'equal or less than'?</a></h2></div>

<p>
In Nuke expressions you use the C-style operator <code>&lt;=</code> for “less than or equal to.”
</p>

<p>
For example, to clamp alpha to 1 whenever R is at most 1 (and leave it unchanged otherwise), you might use in your expr3 (alpha) field:
</p>

<pre text>
(r &lt;= 1) ? 1 : a
</pre>

<p>
Or to check all three channels:
</p>

<pre text>
(r &lt;= 1 &amp;&amp; g &lt;= 1 &amp;&amp; b &lt;= 1) ? 1 : a
</pre>

<p>
Here:
</p>

<ul>
<li>
<code>&lt;=</code> tests “less than or equal to”

<li>
<code>&amp;&amp;</code> is logical AND

<li>
<code>? … : …</code> is the ternary if/else operator

</ul>
<div id="General Syntax-What about 'equal or less than'?-Example for Floor Values"><h4 id="Example for Floor Values" class="header"><a href="#General Syntax-What about 'equal or less than'?-Example for Floor Values">Example for Floor Values</a></h4></div>

<p>
This expression will lift all RGB channels to 0.003 if none are above, and leave 'as is' if one of the RGB channels is above 0.003:
</p>

<pre>
VARIABLE: thr = 0.003

RED:   (r &gt;= thr || g &gt;= thr  || b &gt;= thr) ? r : thr
GREEN: (r &gt;= thr || g &gt;= thr  || b &gt;= thr) ? r : thr
BLUE:  (r &gt;= thr || g &gt;= thr  || b &gt;= thr) ? r : thr
</pre>



<div id="General Syntax-What about 'equal or less than'?-Divergent notes you might find handy:"><h4 id="Divergent notes you might find handy:" class="header"><a href="#General Syntax-What about 'equal or less than'?-Divergent notes you might find handy:">Divergent notes you might find handy:</a></h4></div>

<ul>
<li>
You can mix these comparisons with other arithmetic and built-in math functions (e.g., min(), max()) for more complex clamping or blending.

<li>
Remember that Nuke’s expressions evaluate per pixel, so referencing x and y lets you build masks or patterns based on screen position.

<li>
If you need branching more complex than a single ternary, you can nest ?...:... constructs or use temporary variables via the temp_name/temp_expr rows in the Expression node’s UI.

</ul>
<div id="General Syntax-Luminance"><h2 id="Luminance" class="header"><a href="#General Syntax-Luminance">Luminance</a></h2></div>

<p>
In compositing and color science, luminance is typically expressed as a weighted sum of the red, green, and blue channels. In Nuke’s Expression node, you can calculate luminance by using one of the common standards.
</p>

<p>
For example, if you want to use the Rec.709 (or sRGB) standard, where the weights are approximately 0.2126 for red, 0.7152 for green, and 0.0722 for blue, your expression would be:
</p>

<pre plaintext>
0.2126*r + 0.7152*g + 0.0722*b
</pre>

<p>
Alternatively, some legacy workflows use the Rec.601 standard, which uses weights close to 0.299 for red, 0.587 for green, and 0.114 for blue:
</p>

<pre plaintext>
0.299*r + 0.587*g + 0.114*b
</pre>

<p>
You can enter either one of these formulas in the Expression field of your Expression node. The chosen weights depend on your project’s color standards, but both formulas will calculate a luminance value that takes into account the perceptual sensitivity of the human eye.
</p>

<p>
There isn't any built-in “luminance” function in Nuke's expression language by default, so writing out the weighted sum is the typical approach. This gives you full control over the conversion and makes the process explicit in your node tree.
</p>

<div id="General Syntax-Luminance-In the Expression node:"><h4 id="In the Expression node:" class="header"><a href="#General Syntax-Luminance-In the Expression node:">In the Expression node:</a></h4></div>

<p>
On the left box - <code>l</code>
On the right box - = <code>(0.2126*r + 0.7152*g + 0.0722*b)</code>
</p>

<div id="General Syntax-Fixing Single Pixel NaNs with an Expression"><h2 id="Fixing Single Pixel NaNs with an Expression" class="header"><a href="#General Syntax-Fixing Single Pixel NaNs with an Expression">Fixing Single Pixel NaNs with an Expression</a></h2></div>

<p>
Below is one way you could handle single‑pixel NaNs with an Expression node by checking if a channel’s value is NaN and, if so, replacing it with an average of its eight immediate neighbors. (You’d want to replicate or modify the expression similarly for each channel as needed.) For example, for the red channel, you could write:
</p>

<pre nuke>
isnan(r) ? (r[-1,0] + r[1,0] + r[0,-1] + r[0,1] + r[-1,-1] + r[1,-1] + r[-1,1] + r[1,1]) / 8 : r
</pre>

<div id="General Syntax-Fixing Single Pixel NaNs with an Expression-Explanation"><h3 id="Explanation" class="header"><a href="#General Syntax-Fixing Single Pixel NaNs with an Expression-Explanation">Explanation</a></h3></div>

<ul>
<li>
<span id="General Syntax-Fixing Single Pixel NaNs with an Expression-Explanation-Detecting NaNs"></span><strong id="Detecting NaNs">Detecting NaNs</strong>: The function <code>isnan(r)</code> checks if the current pixel’s red channel is a NaN value.

<li>
<span id="General Syntax-Fixing Single Pixel NaNs with an Expression-Explanation-Sampling Neighboring Pixels"></span><strong id="Sampling Neighboring Pixels">Sampling Neighboring Pixels</strong>: The notation <code>r[dx, dy]</code> lets you sample the red channel from the pixel offset by <code>dx</code> (horizontal) and <code>dy</code> (vertical) from the current pixel. For example, <code>r[-1,0]</code> samples the pixel one unit to the left, and <code>r[0,1]</code> one unit below.

<li>
Alternately, you can use <code>r(x-1, y)</code> and <code>r(x, y+1)</code> syntax.

<li>
<span id="General Syntax-Fixing Single Pixel NaNs with an Expression-Explanation-Averaging"></span><strong id="Averaging">Averaging</strong>: When the current pixel is NaN, the expression sums the red values of the eight neighboring pixels and divides by 8, thereby replacing the NaN with their average.

<li>
<span id="General Syntax-Fixing Single Pixel NaNs with an Expression-Explanation-Fallback"></span><strong id="Fallback">Fallback</strong>: If the current pixel isn’t NaN, it simply uses the original red value.

</ul>
<div id="General Syntax-Fixing Single Pixel NaNs with an Expression-Applying to Other Channels"><h3 id="Applying to Other Channels" class="header"><a href="#General Syntax-Fixing Single Pixel NaNs with an Expression-Applying to Other Channels">Applying to Other Channels</a></h3></div>

<p>
If you need to do this for the green and blue channels, you can create similar expressions, substituting r with g and b respectively:
</p>

<div id="General Syntax-Fixing Single Pixel NaNs with an Expression-Applying to Other Channels-Green Channel:"><h4 id="Green Channel:" class="header"><a href="#General Syntax-Fixing Single Pixel NaNs with an Expression-Applying to Other Channels-Green Channel:">Green Channel:</a></h4></div>

<pre nuke>
isnan(g) ? (g[-1,0] + g[1,0] + g[0,-1] + g[0,1] + g[-1,-1] + g[1,-1] + g[-1,1] + g[1,1]) / 8 : g
</pre>

<div id="General Syntax-Fixing Single Pixel NaNs with an Expression-Applying to Other Channels-Blue Channel:"><h4 id="Blue Channel:" class="header"><a href="#General Syntax-Fixing Single Pixel NaNs with an Expression-Applying to Other Channels-Blue Channel:">Blue Channel:</a></h4></div>

<pre nuke>
isnan(b) ? (b[-1,0] + b[1,0] + b[0,-1] + b[0,1] + b[-1,-1] + b[1,-1] + b[-1,1] + b[1,1]) / 8 : b
</pre>

<div id="General Syntax-Fixing Single Pixel NaNs with an Expression-Caveats"><h3 id="Caveats" class="header"><a href="#General Syntax-Fixing Single Pixel NaNs with an Expression-Caveats">Caveats</a></h3></div>

<ul>
<li>
<span id="General Syntax-Fixing Single Pixel NaNs with an Expression-Caveats-Edge Pixels"></span><strong id="Edge Pixels">Edge Pixels</strong>: Be aware that at the borders of the image there might not be eight neighbors, so you might need to implement safeguards or pre‑filter the image to avoid artifacts at the edges.

<li>
<span id="General Syntax-Fixing Single Pixel NaNs with an Expression-Caveats-Multiple Pixels"></span><strong id="Multiple Pixels">Multiple Pixels</strong>: This expression only fixes pixels that are NaN on their own. If you have clusters of NaNs, additional logic or a different approach (such as a blur or a more sophisticated neighborhood interpolation) may be needed.

</ul>
<p>
This technique lets you “heal” isolated NaN pixels by blending information from their local area, which is often sufficient for many compositing tasks in Nuke. Enjoy experimenting with your expressions!
</p>

<div id="Edge Pixels"><h1 id="Edge Pixels" class="header"><a href="#Edge Pixels">Edge Pixels</a></h1></div>

<p>
There are a few strategies you can use to safeguard against edge cases (literally!) when sampling neighborhood pixels. The idea is to avoid trying to sample pixels beyond the image's borders. Here are some common techniques:
</p>

<div id="Edge Pixels-Pre-Extend or Clamp the Image Data"><h2 id="Pre-Extend or Clamp the Image Data" class="header"><a href="#Edge Pixels-Pre-Extend or Clamp the Image Data">Pre-Extend or Clamp the Image Data</a></h2></div>

<p>
The easiest and most robust approach is often to modify your node tree upstream so that the image data is effectively “padded” at the edges. For example:
</p>
<ul>
<li>
<span id="Edge Pixels-Pre-Extend or Clamp the Image Data-EdgeExtend or Border Node"></span><strong id="EdgeExtend or Border Node">EdgeExtend or Border Node</strong>: Use an upstream node (like a Border or Copy node set to extend the edges) that replicates or clamps the edge pixels. This way, every lookup—even for pixels outside the original image boundaries—returns a valid value.

<li>
<span id="Edge Pixels-Pre-Extend or Clamp the Image Data-Clamp the Coordinates"></span><strong id="Clamp the Coordinates">Clamp the Coordinates</strong>: In some cases, you may be able to clamp your sample coordinates using an expression. Although Nuke’s expression node might not provide a dedicated <code>clamp()</code> function, you can sometimes simulate it using conditional operators. For example, for the left neighbor you might write:
<pre nuke>
x &gt; 0 ? r[-1,0] : r[0,0]
</pre>

</ul>
<p>
This checks if <code>x &gt; 0</code>; if not, it falls back to the current pixel’s value. You’d need a similar condition for each neighbor so that out-of-bound positions default to the nearest in-bound pixel.
</p>

<div id="Edge Pixels-Conditional Sampling Within the Expression"><h2 id="Conditional Sampling Within the Expression" class="header"><a href="#Edge Pixels-Conditional Sampling Within the Expression">Conditional Sampling Within the Expression</a></h2></div>

<p>
If you want to handle the edge case entirely inside the Expression node, you can manually check the current pixel’s position. For example, assuming you have access to the current coordinates and the image dimensions (via variables like <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code>):
</p>

<pre nuke>
(
  x &gt; 0 ? r[-1,0] : r[0,0]
  + x &lt; width-1 ? r[1,0] : r[0,0]
  + y &gt; 0 ? r[0,-1] : r[0,0]
  + y &lt; height-1 ? r[0,1] : r[0,0]
  + x &gt; 0 &amp;&amp; y &gt; 0 ? r[-1,-1] : r[0,0]
  + x &lt; width-1 &amp;&amp; y &gt; 0 ? r[1,-1] : r[0,0]
  + x &gt; 0 &amp;&amp; y &lt; height-1 ? r[-1,1] : r[0,0]
  + x &lt; width-1 &amp;&amp; y &lt; height-1 ? r[1,1] : r[0,0]
) / 8
</pre>

<p>
This example uses conditional (ternary) expressions so that if an offset would be outside the image dimensions, it substitutes the current pixel’s value (or any other fallback value). This approach can get messy quickly, however, especially if you need to do it for every color channel.
</p>

<p>
In Nuke, you’d typically insert an expression like this into an Expression node’s field for the channel you want to process (for example, the red channel). However, if your expression is very long, it might not be very practical to type or edit it directly in the single‑line text input.
</p>

<p>
Some versions of Nuke allow you to open a larger editor by right-clicking on an Expression field and choosing an “Edit…” option. This lets you work with the expression over multiple lines, making it easier to read and debug.
</p>

<p>
The cleanest solution for edge handling is sometimes not to include all the conditional logic in your expression at all. Instead, you might use an upstream node (like an Edge Extend, Border, or Reformat node configured to clamp values) to pad out the image so that every pixel lookup remains valid.
</p>

<div id="Edge Pixels-Using an Upstream Node to Control Border Behavior"><h2 id="Using an Upstream Node to Control Border Behavior" class="header"><a href="#Edge Pixels-Using an Upstream Node to Control Border Behavior">Using an Upstream Node to Control Border Behavior</a></h2></div>

<p>
Often the cleanest solution is to let Nuke handle the border. For instance, you can add a Reformat node with a setting for edge extension, or use a FrameHold node set to “Extend” mode. This way, your expression doesn’t have to worry about boundaries because Nuke ensures that any lookup beyond the edge returns the clamped border pixel.
</p>

<div id="Edge Pixels-Final Thoughts"><h2 id="Final Thoughts" class="header"><a href="#Edge Pixels-Final Thoughts">Final Thoughts</a></h2></div>

<ul>
<li>
<span id="Edge Pixels-Final Thoughts-Preprocessing the Image"></span><strong id="Preprocessing the Image">Preprocessing the Image</strong>: For many compositing workflows, setting an upstream node (like Border/Extend) to pre-handle edge pixels is both easier and less error-prone.

<li>
<span id="Edge Pixels-Final Thoughts-Manual Safeguards"></span><strong id="Manual Safeguards">Manual Safeguards</strong>: Only if you need the logic within the Expression node itself should you consider adding conditional checks. While it offers precise control, it increases complexity.

</ul>
<p>
By adopting one of these strategies, you can ensure your averages are computed correctly even for pixels near the edge of the image.
</p>

<div id="Decimate an Image"><h1 id="Decimate an Image" class="header"><a href="#Decimate an Image">Decimate an Image</a></h1></div>

<p>
In Nuke's expression language, the expression
</p>

<pre plaintext>
!(x%10)*!(y%10)
</pre>

<p>
...works as follows:
</p>

<ul>
<li>
<code>x%10 and y%10</code>: These calculate the remainder when x (or y) is divided by 10. For any number, if it's a multiple of 10 the remainder is 0; otherwise, the remainder is non-zero.

<li>
<code>!</code> (Not operator): The <code>!</code> operator converts a value into its Boolean opposite. In this context, when a number is 0 (which is considered "false" in a Boolean sense), !0 becomes 1 ("true"). For any non-zero number ("true"), !non-zero results in 0 ("false").

<li>
<span id="Decimate an Image-Multiplication of the Booleans:"></span><strong id="Multiplication of the Booleans:">Multiplication of the Booleans:</strong> The expression multiplies the two Boolean results. It will only return 1 if both <code>!(x%10)</code> and <code>!(y%10)</code> are true (i.e. both equal to 1), which happens when both x and y are exact multiples of 10. If either is not a multiple of 10, one side becomes 0 and the multiplication returns 0.

</ul>
<div id="Decimate an Image-Summary"><h4 id="Summary" class="header"><a href="#Decimate an Image-Summary">Summary</a></h4></div>

<ul>
<li>
<span id="Decimate an Image-Summary-Result is 1:"></span><strong id="Result is 1:">Result is 1:</strong> When x is a multiple of 10 and y is a multiple of 10.

<li>
<span id="Decimate an Image-Summary-Result is 0:"></span><strong id="Result is 0:">Result is 0:</strong> Otherwise.

</ul>
<p>
This type of expression is often used to create a grid-like pattern (for example, a set of points) that only appears at positions where both coordinates are divisible by 10.
</p>

<div id="Radial Vector Field Generator"><h1 id="Radial Vector Field Generator" class="header"><a href="#Radial Vector Field Generator">Radial Vector Field Generator</a></h1></div>

<p>
 In an expression node with a Manage User Knobs... knob added (position knob) at each pixel (x,y), the two formulas
</p>

<pre text>
R = sin( atan(x - center.x, y - center.y) + 3.14 ) / 2.48  
G = sin( atan(y - center.y, x - center.x) + 3.14 ) / 2.48  
</pre>

<p>
...actually build a 2D radial vector field centered on center.x, center.y. Here’s the breakdown:
</p>

<div id="Radial Vector Field Generator-Convert pixel → local coordinates"><h4 id="Convert pixel → local coordinates" class="header"><a href="#Radial Vector Field Generator-Convert pixel → local coordinates">Convert pixel → local coordinates</a></h4></div>

<pre>
dx = x – center.x

dy = y – center.y
</pre>

<p>
These shift your coordinate system so the “origin” is the chosen center point.
</p>

<div id="Radial Vector Field Generator-Compute angles with atan"><h4 id="Compute angles with atan" class="header"><a href="#Radial Vector Field Generator-Compute angles with atan">Compute angles with atan</a></h4></div>

<p>
Nuke’s atan(a,b) is the same as atan2(a,b). So:
</p>

<pre text>
atan(dx, dy) yields an angle φ₁ whose tangent is dx/dy (i.e. angle from the positive Y axis).

atan(dy, dx) yields an angle φ₂ whose tangent is dy/dx (i.e. angle from the positive X axis).
</pre>

<div id="Radial Vector Field Generator-Extract vector components via sin(θ+π)"><h4 id="Extract vector components via sin(θ+π)" class="header"><a href="#Radial Vector Field Generator-Extract vector components via sin(θ+π)">Extract vector components via sin(θ+π)</a></h4></div>

<p>
Recall:
</p>

<pre text>
sin(θ+π) = –sin(θ)
</pre>

<p>
For the two angles you get:
</p>
<ul>
<li>
<code>R = –sin(φ₁)/2.48</code>

<li>
<code>G = –sin(φ₂)/2.48</code>

</ul>
<p>
If you work through the trigonometry, you find:
</p>

<pre text>
R ≈ –(dx / √(dx²+dy²)) / 2.48
G ≈ –(dy / √(dx²+dy²)) / 2.48
</pre>

<p>
That is, R and G become the X and Y components of a unit-length vector pointing into the center, scaled down by 1/2.48.
</p>

<div id="Radial Vector Field Generator-What you get"><h4 id="What you get" class="header"><a href="#Radial Vector Field Generator-What you get">What you get</a></h4></div>

<p>
Every pixel’s R-G pair is a small vector pointing radially inward.
</p>

<p>
The magnitude is constant (1/2.48 ≃ 0.40) so it’s a uniform “pull” toward the center.
</p>

<p>
You can feed these channels into a Displace or VectorDistort node to tug the image inward in a circular fashion.
</p>

<div id="Radial Vector Field Generator-Variations and next steps"><h4 id="Variations and next steps" class="header"><a href="#Radial Vector Field Generator-Variations and next steps">Variations and next steps</a></h4></div>

<ul>
<li>
Change the divisor (2.48) to control pull strength.

<li>
Offset the angle by π/2 instead of π to create a swirl (tangential) vector field.

<li>
Multiply by a ramp or noise to get radial falloff or jitter.

<li>
Combine with a radial mask to confine the effect to a circle.

</ul>
<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke"><h2 id="Hooking up Implosion and Vortex in Nuke" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke">Hooking up Implosion and Vortex in Nuke</a></h2></div>

<table>
<tr>
<td>
UNTESTED
</td>
</tr>
</table>

<p>
Here’s how to take your radial vector expressions and feed them into a distort node for either an implosion (radial pull) or a vortex (swirl).
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)"><h3 id="Implosion (Radial Inward Pull)" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)">Implosion (Radial Inward Pull)</a></h3></div>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Expression Node Setup"><h4 id="Expression Node Setup" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Expression Node Setup">Expression Node Setup</a></h4></div>

<p>
Create an Expression node and hook your plate into it.
</p>

<p>
In the channels tab, add two new output channels:
</p>

<pre text>
forward.u

forward.v
</pre>

<p>
In the forward.u field paste:
</p>

<pre>
sin( atan(x - center.x, y - center.y) + 3.14159 ) / 2.48  
</pre>

<p>
In the forward.v field paste:
</p>

<pre text>
sin( atan(y - center.y, x - center.x) + 3.14159 ) / 2.48  
</pre>

<p>
Tweak center.x and center.y interactively or link them to a Tracker/Roto.
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-VectorDistort Node"><h4 id="VectorDistort Node" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-VectorDistort Node">VectorDistort Node</a></h4></div>

<ul>
<li>
Add a VectorDistort node.

<li>
Connect your original plate into input 1 and the Expression node into input 2.

<li>
In the VectorDistort properties:

<ul>
<li>
UV channels: forward

<li>
Filter: Bicubic (for smooth warping)

</ul>
<li>
Wrap: Off (or On if you need tiling)

</ul>
<p>
You’ll now see the image “pulled” uniformly toward your center point.
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Vortex (Tangential Swirl)"><h4 id="Vortex (Tangential Swirl)" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Vortex (Tangential Swirl)">Vortex (Tangential Swirl)</a></h4></div>

<p>
To spin instead of pull, offset the angle by 90° (π/2 ≃ 1.5708 radians):
</p>

<p>
In your existing Expression node, replace expressions:
</p>

<pre>
forward.u

sin( atan(y - center.y, x - center.x) + 1.5708 ) / 2.48  

forward.v

-sin( atan(x - center.x, y - center.y) + 1.5708 ) / 2.48  
</pre>

<p>
Keep your VectorDistort setup exactly the same.
</p>

<p>
Now each pixel is pushed perpendicular to its radius, creating a swirling vortex.
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Fine-Tuning and Extensions"><h4 id="Fine-Tuning and Extensions" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Fine-Tuning and Extensions">Fine-Tuning and Extensions</a></h4></div>

<ul>
<li>
Change the 2.48 divisor to strengthen or weaken the effect.

<li>
Drive center.x/center.y with animation curves or tracking data.

<li>
Use a Ramp node into the VectorDistort mask to contain the warp inside a circular area.

<li>
Inject noise into the expressions for turbulent distortions.

<li>
Animate the angle offset (1.5708) over time for a dynamic spin speed.

</ul>
<div id="Expression Node - Create Alpha from Color Pick"><h1 id="Expression Node - Create Alpha from Color Pick" class="header"><a href="#Expression Node - Create Alpha from Color Pick">Expression Node - Create Alpha from Color Pick</a></h1></div>

<ul>
<li>
Create a Manage User Knobs...  <code>RGB Color Knob</code> and name as alpha_color (or change and match in the expression).

<li>
Set alpha from <code>None</code> to <code>alpha</code>, and populate with:

</ul>
  
<pre text>
(r == alpha_color.r) &amp;&amp; (g == alpha_color.g) &amp;&amp; (b == alpha_color.b) ? 1: 0
</pre>

<p>
Picking a color in the RGB will create an aliased alpha where the pixels are EXACTLY that color.
</p>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value"><h1 id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value">Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value</a></h1></div>

<p>
This expression node will raise pixel channels (so that at least on channel is at least a value of 0.003 in this case). If the pixel channels are all below 0.003, it will raise them proportionally until at least one is set to the minimum value.
</p>

<pre>
# Top of Expression properties:
minimum = 0.003
maximum = max(r,g,b)
low = (r &lt; minimum) &amp;&amp; (g &lt; minimum) &amp;&amp; (b &lt; minimum)

# Bottom of Expression properties:
low ? (maximum == 0 ? minimum : r * (minimum/maximum)) : r
low ? (maximum == 0 ? minimum : g * (minimum/maximum)) : g
low ? (maximum == 0 ? minimum : b * (minimum/maximum)) : b
</pre>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:"><h3 id="EXPLANATION:" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:">EXPLANATION:</a></h3></div>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Variables (Top half of Expression node's property panel):"><h4 id="The Variables (Top half of Expression node's property panel):" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Variables (Top half of Expression node's property panel):">The Variables (Top half of Expression node's property panel):</a></h4></div>

<p>
The variable 'minimum' holds the hard-coded show's minimum permitted maximum pixel channel value.
(NOTE: For the show, this minimum value can be present in only one channel - other channels can be zero or more provided at least one channel is above the minimum pixel channel requirement value).
</p>

<p>
The variable 'maximum' holds the current pixel’s maximum channel value (of the three channels).
</p>

<p>
The variable 'low' is a Boolean (True/False or 1/0). This becomes True if there is no channel with a value above the minimum permitted pixel channel value.
</p>


<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Channel Expressions (Bottom half of Expression node's property panel):"><h4 id="The Channel Expressions (Bottom half of Expression node's property panel):" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Channel Expressions (Bottom half of Expression node's property panel):">The Channel Expressions (Bottom half of Expression node's property panel):</a></h4></div>

<p>
If the minimum pixel channel value is not present, these channel expressions will raise all three channels proportionally until at least one channel reaches the minimum pixel channel value.
</p>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-Pseudo Code in plain English::"><h4 id="Pseudo Code in plain English::" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-Pseudo Code in plain English::">Pseudo Code in plain English::</a></h4></div>

<p>
RED:
</p>
<ul>
<li>
If all channels are below the minimum:

<ul>
<li>
If RED is zero, remain at zero (to prevent a 'divide by zero' errors in the next step):

<li>
Else, multiply RED by the (minimum allowed pixel value/(maximum of the r,g,b channels))

</ul>
<li>
Else, just use the current value of RED.

</ul>
<p>
GREEN:
</p>
<ul>
<li>
If all channels are below the minimum:

<ul>
<li>
If GREEN is zero, remain at zero (to prevent a 'divide by zero' errors in the next step):

<li>
Else, multiply GREEN by the (minimum allowed pixel value/(maximum of the r,g,b channels))

</ul>
<li>
Else, just use the current value of GREEN.

</ul>
<p>
BLUE:
</p>
<ul>
<li>
If all channels are below the minimum:

<ul>
<li>
If BLUE is zero, remain at zero (to prevent a 'divide by zero' errors in the next step):

<li>
Else, multiply BLUE by the (minimum allowed pixel value/(maximum of the r,g,b channels))

</ul>
<li>
Else, just use the current value of BLUE.

</ul>
<div id="Available Functions in Nuke's Expression Node"><h1 id="Available Functions in Nuke's Expression Node" class="header"><a href="#Available Functions in Nuke's Expression Node">Available Functions in Nuke's Expression Node</a></h1></div>

<div id="Available Functions in Nuke's Expression Node-What built-in functions are available to Nuke's Expression node?"><h4 id="What built-in functions are available to Nuke's Expression node?" class="header"><a href="#Available Functions in Nuke's Expression Node-What built-in functions are available to Nuke's Expression node?">What built-in functions are available to Nuke's Expression node?</a></h4></div>

<div id="Available Functions in Nuke's Expression Node-Built-in functions in Nuke's expression node"><h2 id="Built-in functions in Nuke's expression node" class="header"><a href="#Available Functions in Nuke's Expression Node-Built-in functions in Nuke's expression node">Built-in functions in Nuke's expression node</a></h2></div>

<p>
Nuke's Expression node offers a range of built-in functions, primarily focusing on mathematical and color-related operations that allow you to manipulate individual channels and pixel values. 
</p>

<div id="Available Functions in Nuke's Expression Node-Mathematical functions"><h2 id="Mathematical functions" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions">Mathematical functions</a></h2></div>

<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Basic Operations:"><h4 id="Basic Operations:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Basic Operations:">Basic Operations:</a></h4></div>

<p>
<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (addition, subtraction, multiplication, division).
</p>

<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Trigonometric Functions:"><h4 id="Trigonometric Functions:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Trigonometric Functions:">Trigonometric Functions:</a></h4></div>

<ul>
<li>
<code>sin(x)</code>: Sine of x.

<li>
<code>cos(x)</code>: Cosine of x.

<li>
<code>tan(x)</code>: Tangent of x.

<li>
<code>asin(x)</code>: Arc sine of x.

<li>
<code>acos(x)</code>: Arc cosine of x.

<li>
<code>atan(x)</code>: Arc tangent of x.

<li>
<code>atan2(y, x)</code>: Arc tangent of y/x using the signs of both arguments to determine the quadrant of the return value.

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Hyperbolic Functions:"><h4 id="Hyperbolic Functions:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Hyperbolic Functions:">Hyperbolic Functions:</a></h4></div>

<ul>
<li>
<code>sinh(x)</code>: Hyperbolic sine of x.

<li>
<code>cosh(x)</code>: Hyperbolic cosine of x.

<li>
<code>tanh(x)</code>: Hyperbolic tangent of x.

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Other Mathematical Functions:"><h4 id="Other Mathematical Functions:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Other Mathematical Functions:">Other Mathematical Functions:</a></h4></div>

<ul>
<li>
<code>abs(x)</code>: Absolute value of x.

<li>
<code>ceil(x)</code>: Rounds x up to the nearest integer.

<li>
<code>floor(x)</code>: Rounds x down to the nearest integer.

<li>
<code>round(x)</code>: Rounds x to the nearest integer.

<li>
<code>int(x)</code>: Rounds x to the nearest integer not larger in absolute value.

<li>
<code>max(x, y, ...)</code>: Returns the largest of the provided values.

<li>
<code>min(x, y, ...)</code>: Returns the smallest of the provided values.

<li>
<code>pow(x, y)</code>: x raised to the power of y.

<li>
<code>sqrt(x)</code>: Square root of x.

<li>
<code>exp(x)</code>: e (Euler's number) raised to the power of x.

<li>
<code>log(x)</code>: Natural logarithm of x.

<li>
<code>log10(x)</code>: Base-10 logarithm of x.

<li>
<code>radians(x)</code>: Converts degrees to radians.

<li>
<code>degrees(x)</code>: Converts radians to degrees. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Channel and image-related functions"><h4 id="Channel and image-related functions" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Channel and image-related functions">Channel and image-related functions</a></h4></div>

<ul>
<li>
<code>r, g, b, a</code>: Referencing the Red, Green, Blue, and Alpha channels of the input image respectively.

<li>
<code>x, y</code>: Referencing the current pixel's x and y coordinates.

<li>
<code>w, h</code>: Referencing the width and height of the image format. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Conditional logic"><h4 id="Conditional logic" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Conditional logic">Conditional logic</a></h4></div>

<ul>
<li>
<code>condition ? value_if_true </code>: value_if_false: Ternary operator for if-else statements. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Animation and time"><h4 id="Animation and time" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Animation and time">Animation and time</a></h4></div>

<ul>
<li>
<code>frame</code>: Returns the current frame number.

<li>
<code>curve(frame)</code>: Evaluates the y-value of an animation curve at the given frame.

<li>
<code>value(frame)</code>: Returns the y value for an animation at the given frame.

<li>
<code>inrange(value, min, max)</code>: Checks if a value is within a specified range (useful for conditional logic). 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Noise and randomness"><h4 id="Noise and randomness" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Noise and randomness">Noise and randomness</a></h4></div>

<ul>
<li>
<code>noise(x, y, z)</code>: Generates a noise value based on the provided coordinates.

<li>
<code>fBm(x, y, z, octaves, lacunarity, gain)</code>: Fractal Brownian Motion noise.

<li>
<code>turbulence(x, y, z, octaves, lacunarity, gain)</code>: Similar to fBm, but uses the absolute value of the noise function.

<li>
<code>random(x)</code>: Generates a pseudo-random number based on x. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Accessing other knob values"><h4 id="Accessing other knob values" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Accessing other knob values">Accessing other knob values</a></h4></div>

<p>
You can reference the value of any knob in Nuke using the format: NodeName.KnobName.
</p>
<ul>
<li>
Example: Transform1.translate.x.

<li>
Example: Grade1.blackpoint.

<li>
Example: Noise1.size 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Working with variables"><h4 id="Working with variables" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Working with variables">Working with variables</a></h4></div>

<p>
The Expression node has built-in variable fields (e.g., expr0, expr1, expr2) where you can assign complex expressions and then reference these variables in the channel fields. 
</p>

<p>
By combining these functions with mathematical operations and conditional logic, you can create a wide range of powerful and flexible expressions for manipulating your images in Nuke.
</p>


<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
