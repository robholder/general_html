<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_expresion_node_index</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="Nuke - Expression Node"><h1 id="Nuke - Expression Node" class="header"><a href="#Nuke - Expression Node">Nuke - Expression Node</a></h1></div>

<div id="Contents" class="toc"><h1 id="Contents" class="header"><a href="#Contents">Contents</a></h1></div>
<ul>
<li>
<a href="nuke_expresion_node_index.html#Nuke - Expression Node">Nuke - Expression Node</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Node Panel Quick Tip">Node Panel Quick Tip</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#General Syntax">General Syntax</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Nuke expression node: Conditional calculations">Nuke expression node: Conditional calculations</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Syntax">Syntax</a>

<li>
<a href="nuke_expresion_node_index.html#Examples">Examples</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Greater than or Equal &amp; Less than or Equal">Greater than or Equal &amp; Less than or Equal</a>

<li>
<a href="nuke_expresion_node_index.html#What about 'equal or less than'?">What about 'equal or less than'?</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Referencing Pixels Relative to the Current Pixel">Referencing Pixels Relative to the Current Pixel</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Offsetting Pixel Coordinates">Offsetting Pixel Coordinates</a>

<li>
<a href="nuke_expresion_node_index.html#Common Use Cases">Common Use Cases</a>

<li>
<a href="nuke_expresion_node_index.html#Accessing Other Inputs (MergeExpression Node)">Accessing Other Inputs (MergeExpression Node)</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#The MergeExpression Node">The MergeExpression Node</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Using Expressions as a 'One-Pixel' Gizmo">Using Expressions as a 'One-Pixel' Gizmo</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Example for Floor Values">Example for Floor Values</a>

<li>
<a href="nuke_expresion_node_index.html#Divergent notes you might find handy:">Divergent notes you might find handy:</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Luminance">Luminance</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#In the Expression node:">In the Expression node:</a>

</ul>
</ul>
<li>
<a href="nuke_expresion_node_index.html#Decimate an Image">Decimate an Image</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Summary">Summary</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Radial Vector Field Generator">Radial Vector Field Generator</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Convert pixel → local coordinates">Convert pixel → local coordinates</a>

<li>
<a href="nuke_expresion_node_index.html#Compute angles with atan">Compute angles with atan</a>

<li>
<a href="nuke_expresion_node_index.html#Extract vector components via sin(θ+π)">Extract vector components via sin(θ+π)</a>

<li>
<a href="nuke_expresion_node_index.html#What you get">What you get</a>

<li>
<a href="nuke_expresion_node_index.html#Variations and next steps">Variations and next steps</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Hooking up Implosion and Vortex in Nuke">Hooking up Implosion and Vortex in Nuke</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Implosion (Radial Inward Pull)">Implosion (Radial Inward Pull)</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Expression Node Setup">Expression Node Setup</a>

<li>
<a href="nuke_expresion_node_index.html#VectorDistort Node">VectorDistort Node</a>

<li>
<a href="nuke_expresion_node_index.html#Vortex (Tangential Swirl)">Vortex (Tangential Swirl)</a>

<li>
<a href="nuke_expresion_node_index.html#Fine-Tuning and Extensions">Fine-Tuning and Extensions</a>

</ul>
</ul>
<li>
<a href="nuke_expresion_node_index.html#Expression Node - Create Alpha from Color Pick">Expression Node - Create Alpha from Color Pick</a>

<li>
<a href="nuke_expresion_node_index.html#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value">Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#EXPLANATION:">EXPLANATION:</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#The Variables (Top half of Expression node's property panel):">The Variables (Top half of Expression node's property panel):</a>

<li>
<a href="nuke_expresion_node_index.html#The Channel Expressions (Bottom half of Expression node's property panel):">The Channel Expressions (Bottom half of Expression node's property panel):</a>

<li>
<a href="nuke_expresion_node_index.html#Pseudo Code in plain English::">Pseudo Code in plain English::</a>

</ul>
</ul>
<li>
<a href="nuke_expresion_node_index.html#Available Functions in Nuke's Expression Node">Available Functions in Nuke's Expression Node</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#What built-in functions are available to Nuke's Expression node?">What built-in functions are available to Nuke's Expression node?</a>

</ul>
<li>
<a href="nuke_expresion_node_index.html#Built-in functions in Nuke's expression node">Built-in functions in Nuke's expression node</a>

<li>
<a href="nuke_expresion_node_index.html#Mathematical functions">Mathematical functions</a>

<ul>
<li>
<a href="nuke_expresion_node_index.html#Basic Operations:">Basic Operations:</a>

<li>
<a href="nuke_expresion_node_index.html#Trigonometric Functions:">Trigonometric Functions:</a>

<li>
<a href="nuke_expresion_node_index.html#Hyperbolic Functions:">Hyperbolic Functions:</a>

<li>
<a href="nuke_expresion_node_index.html#Other Mathematical Functions:">Other Mathematical Functions:</a>

<li>
<a href="nuke_expresion_node_index.html#Channel and image-related functions">Channel and image-related functions</a>

<li>
<a href="nuke_expresion_node_index.html#Conditional logic">Conditional logic</a>

<li>
<a href="nuke_expresion_node_index.html#Animation and time">Animation and time</a>

<li>
<a href="nuke_expresion_node_index.html#Noise and randomness">Noise and randomness</a>

<li>
<a href="nuke_expresion_node_index.html#Accessing other knob values">Accessing other knob values</a>

<li>
<a href="nuke_expresion_node_index.html#Working with variables">Working with variables</a>

</ul>
</ul>
<div id="Nuke - Expression Node-Node Panel Quick Tip"><h2 id="Node Panel Quick Tip" class="header"><a href="#Nuke - Expression Node-Node Panel Quick Tip">Node Panel Quick Tip</a></h2></div>

<p>
There is a wrench on each node's property panel: click this to 'save' presets. These presets will appear as pulldown user choices. (Very handy for the Expression node.)
</p>

<div id="General Syntax"><h1 id="General Syntax" class="header"><a href="#General Syntax">General Syntax</a></h1></div>

<div id="General Syntax-Nuke expression node: Conditional calculations"><h2 id="Nuke expression node: Conditional calculations" class="header"><a href="#General Syntax-Nuke expression node: Conditional calculations">Nuke expression node: Conditional calculations</a></h2></div>

<p>
The Nuke Expression node allows you to perform conditional calculations on channels using expressions, which are evaluated for each pixel. 
</p>

<div id="General Syntax-Nuke expression node: Conditional calculations-Syntax"><h4 id="Syntax" class="header"><a href="#General Syntax-Nuke expression node: Conditional calculations-Syntax">Syntax</a></h4></div>

<p>
Nuke expressions use a C-like syntax for conditional calculations, often employing the ternary operator ( ? : ) as an equivalent to if-else statements. 
</p>

<p>
The general structure is:
</p>

<pre text>
condition ? value_if_true : value_if_false
</pre>

<div id="General Syntax-Nuke expression node: Conditional calculations-Examples"><h4 id="Examples" class="header"><a href="#General Syntax-Nuke expression node: Conditional calculations-Examples">Examples</a></h4></div>

<ul>
<li>
<span id="General Syntax-Nuke expression node: Conditional calculations-Examples-Example 1"></span><strong id="Example 1">Example 1</strong>: Simple ConditionalIf a channel's value r is greater than 0.5, set it to 1; otherwise, set it to 0. according to Foundry Community.

</ul>
  
<pre text>
r &gt; 0.5 ? 1 : 0 
</pre>

<ul>
<li>
<span id="General Syntax-Nuke expression node: Conditional calculations-Examples-Example 2"></span><strong id="Example 2">Example 2</strong>: Combining ConditionsIf r is greater than 0.5 AND g is less than 0.2, set b to 1; otherwise, set it to b's original value.

</ul>
  
<pre text>
r &gt; 0.5 &amp;&amp; g &lt; 0.2 ? 1 : b 
</pre>

<ul>
<li>
<span id="General Syntax-Nuke expression node: Conditional calculations-Examples-Example 3"></span><strong id="Example 3">Example 3</strong>: Referencing Other KnobsIf the value of a knob named myKnob on the same node is equal to 1, set r to 1; otherwise, set it to 0.

</ul>
  
<pre text>
myKnob == 1 ? 1 : 0
</pre>

<div id="General Syntax-Greater than or Equal &amp; Less than or Equal"><h2 id="Greater than or Equal &amp; Less than or Equal" class="header"><a href="#General Syntax-Greater than or Equal &amp; Less than or Equal">Greater than or Equal &amp; Less than or Equal</a></h2></div>

<p>
In Nuke’s Expression node you use the standard C‐style comparison operator <code>&gt;=</code> for “greater than or equal to.”
</p>

<p>
For example, to set alpha to 1 whenever R is at least 1 (and leave it unchanged otherwise), you could put in your expr3 (alpha) field:
</p>

<pre text>
(r &gt;= 1) ? 1 : a
</pre>

<p>
Or, combining R, G and B:
</p>

<pre text>
(r &gt;= 1 &amp;&amp; g &gt;= 1 &amp;&amp; b &gt;= 1) ? 1 : a
</pre>

<p>
Here:
</p>

<ul>
<li>
<code>&gt;=</code> tests “greater than or equal to”

<li>
<code>&amp;&amp;</code> is logical AND

<li>
<code>? … : …</code> is the ternary if/else operator

</ul>
<div id="General Syntax-What about 'equal or less than'?"><h2 id="What about 'equal or less than'?" class="header"><a href="#General Syntax-What about 'equal or less than'?">What about 'equal or less than'?</a></h2></div>

<p>
In Nuke expressions you use the C-style operator <code>&lt;=</code> for “less than or equal to.”
</p>

<p>
For example, to clamp alpha to 1 whenever R is at most 1 (and leave it unchanged otherwise), you might use in your expr3 (alpha) field:
</p>

<pre text>
(r &lt;= 1) ? 1 : a
</pre>

<p>
Or to check all three channels:
</p>

<pre text>
(r &lt;= 1 &amp;&amp; g &lt;= 1 &amp;&amp; b &lt;= 1) ? 1 : a
</pre>

<p>
Here:
</p>

<ul>
<li>
<code>&lt;=</code> tests “less than or equal to”

<li>
<code>&amp;&amp;</code> is logical AND

<li>
<code>? … : …</code> is the ternary if/else operator

</ul>
<div id="Referencing Pixels Relative to the Current Pixel"><h1 id="Referencing Pixels Relative to the Current Pixel" class="header"><a href="#Referencing Pixels Relative to the Current Pixel">Referencing Pixels Relative to the Current Pixel</a></h1></div>

<p>
In a Nuke Expression Node, you can reference other pixels by using a combination of the channel name and the altered coordinates in parentheses. The basic syntax is channel(x, y), where channel can be r, g, b, or a for the red, green, blue, and alpha channels, respectively. The x and y values represent the pixel's coordinates.
</p>

<div id="Referencing Pixels Relative to the Current Pixel-Offsetting Pixel Coordinates"><h2 id="Offsetting Pixel Coordinates" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Offsetting Pixel Coordinates">Offsetting Pixel Coordinates</a></h2></div>

<p>
The most common way to use this feature is to offset a pixel's coordinates. This allows you to sample a pixel from a different location relative to the current pixel being processed. For example, r(x+1, y) would sample the red channel from the pixel directly to the right, and b(x, y-5) would sample the blue channel from the pixel five units up. This is incredibly useful for a variety of effects.
</p>

<div id="Referencing Pixels Relative to the Current Pixel-Common Use Cases"><h2 id="Common Use Cases" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Common Use Cases">Common Use Cases</a></h2></div>

<ul>
<li>
<span id="Referencing Pixels Relative to the Current Pixel-Common Use Cases-Blurring and Blending"></span><strong id="Blurring and Blending">Blurring and Blending</strong>: By averaging the values of surrounding pixels, you can create a simple blur. For instance, (r(x-1,y) + r(x+1,y) + r(x,y-1) + r(x,y+1) + r(x,y)) / 5 would average the red channel of the current pixel and its four immediate neighbors.

<li>
<span id="Referencing Pixels Relative to the Current Pixel-Common Use Cases-Edge Detection"></span><strong id="Edge Detection">Edge Detection</strong>: You can highlight edges by subtracting the value of a neighboring pixel from the current one. A simple edge detection expression might look like abs(r - r(x+1, y)) + abs(g - g(x+1, y)) + abs(b - b(x+1, y)).

<li>
<span id="Referencing Pixels Relative to the Current Pixel-Common Use Cases-Motion and Distortion"></span><strong id="Motion and Distortion">Motion and Distortion</strong>: You can create motion blur or distortion effects by sampling pixels along a specific vector. For example, to simulate a smear effect, you could blend the current pixel with a pixel from a past frame or from a displaced position, like r(x+dx, y+dy), where dx and dy are values defining a directional vector.

<li>
<span id="Referencing Pixels Relative to the Current Pixel-Common Use Cases-Generating Procedural Textures"></span><strong id="Generating Procedural Textures">Generating Procedural Textures</strong>: By using mathematical functions like sine or cosine on the x and y coordinates, you can generate patterns. For example, (sin(x) + cos(y)) / 2 would create a unique pattern of repeating gradients.

<li>
<span id="Referencing Pixels Relative to the Current Pixel-Common Use Cases-Channel Manipulation"></span><strong id="Channel Manipulation">Channel Manipulation</strong>: You can use the values from one channel to affect another. For example, g(x+a*50, y) would use the alpha channel's value at the current pixel to offset the sampling of the green channel, leading to a distortion effect based on the alpha mask.

</ul>
<div id="Referencing Pixels Relative to the Current Pixel-Accessing Other Inputs (MergeExpression Node)"><h2 id="Accessing Other Inputs (MergeExpression Node)" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Accessing Other Inputs (MergeExpression Node)">Accessing Other Inputs (MergeExpression Node)</a></h2></div>

<div id="Referencing Pixels Relative to the Current Pixel-Accessing Other Inputs (MergeExpression Node)-The MergeExpression Node"><h3 id="The MergeExpression Node" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Accessing Other Inputs (MergeExpression Node)-The MergeExpression Node">The MergeExpression Node</a></h3></div>

<p>
By using a dedicated <code>MergeExpression</code> node, in addition to referencing other pixels from the current input, you can also access pixels from other connected inputs. This is done by adding the input number before the channel name, like input1.r(x+10, y+10). This is extremely powerful for operations like a difference matte, where you subtract a clean plate from a current image to isolate a specific object or effect.
</p>

<div id="Referencing Pixels Relative to the Current Pixel-Using Expressions as a 'One-Pixel' Gizmo"><h2 id="Using Expressions as a 'One-Pixel' Gizmo" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Using Expressions as a 'One-Pixel' Gizmo">Using Expressions as a 'One-Pixel' Gizmo</a></h2></div>

<p>
The Expression Node is essentially a single-pixel processor that gets executed for every pixel in the image.  This makes it incredibly efficient for creating custom, lightweight operations without the overhead of more complex nodes. It's the "Swiss Army knife" of Nuke for solving small, specific problems and for prototyping custom effects quickly.
</p>

<div id="Referencing Pixels Relative to the Current Pixel-Using Expressions as a 'One-Pixel' Gizmo-Example for Floor Values"><h4 id="Example for Floor Values" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Using Expressions as a 'One-Pixel' Gizmo-Example for Floor Values">Example for Floor Values</a></h4></div>

<p>
This expression will lift all RGB channels to 0.003 if none are above, and leave 'as is' if one of the RGB channels is above 0.003:
</p>

<pre>
VARIABLE: thr = 0.003

RED:   (r &gt;= thr || g &gt;= thr  || b &gt;= thr) ? r : thr
GREEN: (r &gt;= thr || g &gt;= thr  || b &gt;= thr) ? r : thr
BLUE:  (r &gt;= thr || g &gt;= thr  || b &gt;= thr) ? r : thr
</pre>

<div id="Referencing Pixels Relative to the Current Pixel-Using Expressions as a 'One-Pixel' Gizmo-Divergent notes you might find handy:"><h4 id="Divergent notes you might find handy:" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Using Expressions as a 'One-Pixel' Gizmo-Divergent notes you might find handy:">Divergent notes you might find handy:</a></h4></div>

<ul>
<li>
You can mix these comparisons with other arithmetic and built-in math functions (e.g., min(), max()) for more complex clamping or blending.

<li>
Remember that Nuke’s expressions evaluate per pixel, so referencing x and y lets you build masks or patterns based on screen position.

<li>
If you need branching more complex than a single ternary, you can nest ?...:... constructs or use temporary variables via the temp_name/temp_expr rows in the Expression node’s UI.

</ul>
<div id="Referencing Pixels Relative to the Current Pixel-Luminance"><h2 id="Luminance" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Luminance">Luminance</a></h2></div>

<p>
In compositing and color science, luminance is typically expressed as a weighted sum of the red, green, and blue channels. In Nuke’s Expression node, you can calculate luminance by using one of the common standards.
</p>

<p>
For example, if you want to use the Rec.709 (or sRGB) standard, where the weights are approximately 0.2126 for red, 0.7152 for green, and 0.0722 for blue, your expression would be:
</p>

<pre plaintext>
0.2126*r + 0.7152*g + 0.0722*b
</pre>

<p>
Alternatively, some legacy workflows use the Rec.601 standard, which uses weights close to 0.299 for red, 0.587 for green, and 0.114 for blue:
</p>

<pre plaintext>
0.299*r + 0.587*g + 0.114*b
</pre>

<p>
You can enter either one of these formulas in the Expression field of your Expression node. The chosen weights depend on your project’s color standards, but both formulas will calculate a luminance value that takes into account the perceptual sensitivity of the human eye.
</p>

<p>
There isn't any built-in “luminance” function in Nuke's expression language by default, so writing out the weighted sum is the typical approach. This gives you full control over the conversion and makes the process explicit in your node tree.
</p>

<div id="Referencing Pixels Relative to the Current Pixel-Luminance-In the Expression node:"><h4 id="In the Expression node:" class="header"><a href="#Referencing Pixels Relative to the Current Pixel-Luminance-In the Expression node:">In the Expression node:</a></h4></div>

<p>
On the left box - <code>l</code>
On the right box - = <code>(0.2126*r + 0.7152*g + 0.0722*b)</code>
</p>

<div id="Decimate an Image"><h1 id="Decimate an Image" class="header"><a href="#Decimate an Image">Decimate an Image</a></h1></div>

<p>
In Nuke's expression language, the expression
</p>

<pre plaintext>
!(x%10)*!(y%10)
</pre>

<p>
...works as follows:
</p>

<ul>
<li>
<code>x%10 and y%10</code>: These calculate the remainder when x (or y) is divided by 10. For any number, if it's a multiple of 10 the remainder is 0; otherwise, the remainder is non-zero.

<li>
<code>!</code> (Not operator): The <code>!</code> operator converts a value into its Boolean opposite. In this context, when a number is 0 (which is considered "false" in a Boolean sense), !0 becomes 1 ("true"). For any non-zero number ("true"), !non-zero results in 0 ("false").

<li>
<span id="Decimate an Image-Multiplication of the Booleans:"></span><strong id="Multiplication of the Booleans:">Multiplication of the Booleans:</strong> The expression multiplies the two Boolean results. It will only return 1 if both <code>!(x%10)</code> and <code>!(y%10)</code> are true (i.e. both equal to 1), which happens when both x and y are exact multiples of 10. If either is not a multiple of 10, one side becomes 0 and the multiplication returns 0.

</ul>
<div id="Decimate an Image-Summary"><h4 id="Summary" class="header"><a href="#Decimate an Image-Summary">Summary</a></h4></div>

<ul>
<li>
<span id="Decimate an Image-Summary-Result is 1:"></span><strong id="Result is 1:">Result is 1:</strong> When x is a multiple of 10 and y is a multiple of 10.

<li>
<span id="Decimate an Image-Summary-Result is 0:"></span><strong id="Result is 0:">Result is 0:</strong> Otherwise.

</ul>
<p>
This type of expression is often used to create a grid-like pattern (for example, a set of points) that only appears at positions where both coordinates are divisible by 10.
</p>

<div id="Radial Vector Field Generator"><h1 id="Radial Vector Field Generator" class="header"><a href="#Radial Vector Field Generator">Radial Vector Field Generator</a></h1></div>

<p>
 In an expression node with a Manage User Knobs... knob added (position knob) at each pixel (x,y), the two formulas
</p>

<pre text>
R = sin( atan(x - center.x, y - center.y) + 3.14 ) / 2.48  
G = sin( atan(y - center.y, x - center.x) + 3.14 ) / 2.48  
</pre>

<p>
...actually build a 2D radial vector field centered on center.x, center.y. Here’s the breakdown:
</p>

<div id="Radial Vector Field Generator-Convert pixel → local coordinates"><h4 id="Convert pixel → local coordinates" class="header"><a href="#Radial Vector Field Generator-Convert pixel → local coordinates">Convert pixel → local coordinates</a></h4></div>

<pre>
dx = x – center.x

dy = y – center.y
</pre>

<p>
These shift your coordinate system so the “origin” is the chosen center point.
</p>

<div id="Radial Vector Field Generator-Compute angles with atan"><h4 id="Compute angles with atan" class="header"><a href="#Radial Vector Field Generator-Compute angles with atan">Compute angles with atan</a></h4></div>

<p>
Nuke’s atan(a,b) is the same as atan2(a,b). So:
</p>

<pre text>
atan(dx, dy) yields an angle φ₁ whose tangent is dx/dy (i.e. angle from the positive Y axis).

atan(dy, dx) yields an angle φ₂ whose tangent is dy/dx (i.e. angle from the positive X axis).
</pre>

<div id="Radial Vector Field Generator-Extract vector components via sin(θ+π)"><h4 id="Extract vector components via sin(θ+π)" class="header"><a href="#Radial Vector Field Generator-Extract vector components via sin(θ+π)">Extract vector components via sin(θ+π)</a></h4></div>

<p>
Recall:
</p>

<pre text>
sin(θ+π) = –sin(θ)
</pre>

<p>
For the two angles you get:
</p>
<ul>
<li>
<code>R = –sin(φ₁)/2.48</code>

<li>
<code>G = –sin(φ₂)/2.48</code>

</ul>
<p>
If you work through the trigonometry, you find:
</p>

<pre text>
R ≈ –(dx / √(dx²+dy²)) / 2.48
G ≈ –(dy / √(dx²+dy²)) / 2.48
</pre>

<p>
That is, R and G become the X and Y components of a unit-length vector pointing into the center, scaled down by 1/2.48.
</p>

<div id="Radial Vector Field Generator-What you get"><h4 id="What you get" class="header"><a href="#Radial Vector Field Generator-What you get">What you get</a></h4></div>

<p>
Every pixel’s R-G pair is a small vector pointing radially inward.
</p>

<p>
The magnitude is constant (1/2.48 ≃ 0.40) so it’s a uniform “pull” toward the center.
</p>

<p>
You can feed these channels into a Displace or VectorDistort node to tug the image inward in a circular fashion.
</p>

<div id="Radial Vector Field Generator-Variations and next steps"><h4 id="Variations and next steps" class="header"><a href="#Radial Vector Field Generator-Variations and next steps">Variations and next steps</a></h4></div>

<ul>
<li>
Change the divisor (2.48) to control pull strength.

<li>
Offset the angle by π/2 instead of π to create a swirl (tangential) vector field.

<li>
Multiply by a ramp or noise to get radial falloff or jitter.

<li>
Combine with a radial mask to confine the effect to a circle.

</ul>
<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke"><h2 id="Hooking up Implosion and Vortex in Nuke" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke">Hooking up Implosion and Vortex in Nuke</a></h2></div>

<table>
<tr>
<td>
UNTESTED
</td>
</tr>
</table>

<p>
Here’s how to take your radial vector expressions and feed them into a distort node for either an implosion (radial pull) or a vortex (swirl).
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)"><h3 id="Implosion (Radial Inward Pull)" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)">Implosion (Radial Inward Pull)</a></h3></div>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Expression Node Setup"><h4 id="Expression Node Setup" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Expression Node Setup">Expression Node Setup</a></h4></div>

<p>
Create an Expression node and hook your plate into it.
</p>

<p>
In the channels tab, add two new output channels:
</p>

<pre text>
forward.u

forward.v
</pre>

<p>
In the forward.u field paste:
</p>

<pre>
sin( atan(x - center.x, y - center.y) + 3.14159 ) / 2.48  
</pre>

<p>
In the forward.v field paste:
</p>

<pre text>
sin( atan(y - center.y, x - center.x) + 3.14159 ) / 2.48  
</pre>

<p>
Tweak center.x and center.y interactively or link them to a Tracker/Roto.
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-VectorDistort Node"><h4 id="VectorDistort Node" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-VectorDistort Node">VectorDistort Node</a></h4></div>

<ul>
<li>
Add a VectorDistort node.

<li>
Connect your original plate into input 1 and the Expression node into input 2.

<li>
In the VectorDistort properties:

<ul>
<li>
UV channels: forward

<li>
Filter: Bicubic (for smooth warping)

</ul>
<li>
Wrap: Off (or On if you need tiling)

</ul>
<p>
You’ll now see the image “pulled” uniformly toward your center point.
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Vortex (Tangential Swirl)"><h4 id="Vortex (Tangential Swirl)" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Vortex (Tangential Swirl)">Vortex (Tangential Swirl)</a></h4></div>

<p>
To spin instead of pull, offset the angle by 90° (π/2 ≃ 1.5708 radians):
</p>

<p>
In your existing Expression node, replace expressions:
</p>

<pre>
forward.u

sin( atan(y - center.y, x - center.x) + 1.5708 ) / 2.48  

forward.v

-sin( atan(x - center.x, y - center.y) + 1.5708 ) / 2.48  
</pre>

<p>
Keep your VectorDistort setup exactly the same.
</p>

<p>
Now each pixel is pushed perpendicular to its radius, creating a swirling vortex.
</p>

<div id="Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Fine-Tuning and Extensions"><h4 id="Fine-Tuning and Extensions" class="header"><a href="#Radial Vector Field Generator-Hooking up Implosion and Vortex in Nuke-Implosion (Radial Inward Pull)-Fine-Tuning and Extensions">Fine-Tuning and Extensions</a></h4></div>

<ul>
<li>
Change the 2.48 divisor to strengthen or weaken the effect.

<li>
Drive center.x/center.y with animation curves or tracking data.

<li>
Use a Ramp node into the VectorDistort mask to contain the warp inside a circular area.

<li>
Inject noise into the expressions for turbulent distortions.

<li>
Animate the angle offset (1.5708) over time for a dynamic spin speed.

</ul>
<div id="Expression Node - Create Alpha from Color Pick"><h1 id="Expression Node - Create Alpha from Color Pick" class="header"><a href="#Expression Node - Create Alpha from Color Pick">Expression Node - Create Alpha from Color Pick</a></h1></div>

<ul>
<li>
Create a Manage User Knobs...  <code>RGB Color Knob</code> and name as alpha_color (or change and match in the expression).

<li>
Set alpha from <code>None</code> to <code>alpha</code>, and populate with:

</ul>
  
<pre text>
(r == alpha_color.r) &amp;&amp; (g == alpha_color.g) &amp;&amp; (b == alpha_color.b) ? 1: 0
</pre>

<p>
Picking a color in the RGB will create an aliased alpha where the pixels are EXACTLY that color.
</p>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value"><h1 id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value">Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value</a></h1></div>

<p>
This expression node will raise pixel channels (so that at least on channel is at least a value of 0.003 in this case). If the pixel channels are all below 0.003, it will raise them proportionally until at least one is set to the minimum value.
</p>

<pre>
# Top of Expression properties:
minimum = 0.003
maximum = max(r,g,b)
low = (r &lt; minimum) &amp;&amp; (g &lt; minimum) &amp;&amp; (b &lt; minimum)

# Bottom of Expression properties:
low ? (maximum == 0 ? minimum : r * (minimum/maximum)) : r
low ? (maximum == 0 ? minimum : g * (minimum/maximum)) : g
low ? (maximum == 0 ? minimum : b * (minimum/maximum)) : b
</pre>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:"><h3 id="EXPLANATION:" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:">EXPLANATION:</a></h3></div>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Variables (Top half of Expression node's property panel):"><h4 id="The Variables (Top half of Expression node's property panel):" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Variables (Top half of Expression node's property panel):">The Variables (Top half of Expression node's property panel):</a></h4></div>

<p>
The variable 'minimum' holds the hard-coded show's minimum permitted maximum pixel channel value.
(NOTE: For the show, this minimum value can be present in only one channel - other channels can be zero or more provided at least one channel is above the minimum pixel channel requirement value).
</p>

<p>
The variable 'maximum' holds the current pixel’s maximum channel value (of the three channels).
</p>

<p>
The variable 'low' is a Boolean (True/False or 1/0). This becomes True if there is no channel with a value above the minimum permitted pixel channel value.
</p>


<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Channel Expressions (Bottom half of Expression node's property panel):"><h4 id="The Channel Expressions (Bottom half of Expression node's property panel):" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-The Channel Expressions (Bottom half of Expression node's property panel):">The Channel Expressions (Bottom half of Expression node's property panel):</a></h4></div>

<p>
If the minimum pixel channel value is not present, these channel expressions will raise all three channels proportionally until at least one channel reaches the minimum pixel channel value.
</p>

<div id="Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-Pseudo Code in plain English::"><h4 id="Pseudo Code in plain English::" class="header"><a href="#Expression Node - Raise Pixels Proportionately to a Set Minimum Pixel Value-EXPLANATION:-Pseudo Code in plain English::">Pseudo Code in plain English::</a></h4></div>

<p>
RED:
</p>
<ul>
<li>
If all channels are below the minimum:

<ul>
<li>
If RED is zero, remain at zero (to prevent a 'divide by zero' errors in the next step):

<li>
Else, multiply RED by the (minimum allowed pixel value/(maximum of the r,g,b channels))

</ul>
<li>
Else, just use the current value of RED.

</ul>
<p>
GREEN:
</p>
<ul>
<li>
If all channels are below the minimum:

<ul>
<li>
If GREEN is zero, remain at zero (to prevent a 'divide by zero' errors in the next step):

<li>
Else, multiply GREEN by the (minimum allowed pixel value/(maximum of the r,g,b channels))

</ul>
<li>
Else, just use the current value of GREEN.

</ul>
<p>
BLUE:
</p>
<ul>
<li>
If all channels are below the minimum:

<ul>
<li>
If BLUE is zero, remain at zero (to prevent a 'divide by zero' errors in the next step):

<li>
Else, multiply BLUE by the (minimum allowed pixel value/(maximum of the r,g,b channels))

</ul>
<li>
Else, just use the current value of BLUE.

</ul>
<div id="Available Functions in Nuke's Expression Node"><h1 id="Available Functions in Nuke's Expression Node" class="header"><a href="#Available Functions in Nuke's Expression Node">Available Functions in Nuke's Expression Node</a></h1></div>

<div id="Available Functions in Nuke's Expression Node-What built-in functions are available to Nuke's Expression node?"><h4 id="What built-in functions are available to Nuke's Expression node?" class="header"><a href="#Available Functions in Nuke's Expression Node-What built-in functions are available to Nuke's Expression node?">What built-in functions are available to Nuke's Expression node?</a></h4></div>

<div id="Available Functions in Nuke's Expression Node-Built-in functions in Nuke's expression node"><h2 id="Built-in functions in Nuke's expression node" class="header"><a href="#Available Functions in Nuke's Expression Node-Built-in functions in Nuke's expression node">Built-in functions in Nuke's expression node</a></h2></div>

<p>
Nuke's Expression node offers a range of built-in functions, primarily focusing on mathematical and color-related operations that allow you to manipulate individual channels and pixel values. 
</p>

<div id="Available Functions in Nuke's Expression Node-Mathematical functions"><h2 id="Mathematical functions" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions">Mathematical functions</a></h2></div>

<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Basic Operations:"><h4 id="Basic Operations:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Basic Operations:">Basic Operations:</a></h4></div>

<p>
<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (addition, subtraction, multiplication, division).
</p>

<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Trigonometric Functions:"><h4 id="Trigonometric Functions:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Trigonometric Functions:">Trigonometric Functions:</a></h4></div>

<ul>
<li>
<code>sin(x)</code>: Sine of x.

<li>
<code>cos(x)</code>: Cosine of x.

<li>
<code>tan(x)</code>: Tangent of x.

<li>
<code>asin(x)</code>: Arc sine of x.

<li>
<code>acos(x)</code>: Arc cosine of x.

<li>
<code>atan(x)</code>: Arc tangent of x.

<li>
<code>atan2(y, x)</code>: Arc tangent of y/x using the signs of both arguments to determine the quadrant of the return value.

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Hyperbolic Functions:"><h4 id="Hyperbolic Functions:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Hyperbolic Functions:">Hyperbolic Functions:</a></h4></div>

<ul>
<li>
<code>sinh(x)</code>: Hyperbolic sine of x.

<li>
<code>cosh(x)</code>: Hyperbolic cosine of x.

<li>
<code>tanh(x)</code>: Hyperbolic tangent of x.

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Other Mathematical Functions:"><h4 id="Other Mathematical Functions:" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Other Mathematical Functions:">Other Mathematical Functions:</a></h4></div>

<ul>
<li>
<code>abs(x)</code>: Absolute value of x.

<li>
<code>ceil(x)</code>: Rounds x up to the nearest integer.

<li>
<code>floor(x)</code>: Rounds x down to the nearest integer.

<li>
<code>round(x)</code>: Rounds x to the nearest integer.

<li>
<code>int(x)</code>: Rounds x to the nearest integer not larger in absolute value.

<li>
<code>max(x, y, ...)</code>: Returns the largest of the provided values.

<li>
<code>min(x, y, ...)</code>: Returns the smallest of the provided values.

<li>
<code>pow(x, y)</code>: x raised to the power of y.

<li>
<code>sqrt(x)</code>: Square root of x.

<li>
<code>exp(x)</code>: e (Euler's number) raised to the power of x.

<li>
<code>log(x)</code>: Natural logarithm of x.

<li>
<code>log10(x)</code>: Base-10 logarithm of x.

<li>
<code>radians(x)</code>: Converts degrees to radians.

<li>
<code>degrees(x)</code>: Converts radians to degrees. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Channel and image-related functions"><h4 id="Channel and image-related functions" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Channel and image-related functions">Channel and image-related functions</a></h4></div>

<ul>
<li>
<code>r, g, b, a</code>: Referencing the Red, Green, Blue, and Alpha channels of the input image respectively.

<li>
<code>x, y</code>: Referencing the current pixel's x and y coordinates.

<li>
<code>w, h</code>: Referencing the width and height of the image format. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Conditional logic"><h4 id="Conditional logic" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Conditional logic">Conditional logic</a></h4></div>

<ul>
<li>
<code>condition ? value_if_true </code>: value_if_false: Ternary operator for if-else statements. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Animation and time"><h4 id="Animation and time" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Animation and time">Animation and time</a></h4></div>

<ul>
<li>
<code>frame</code>: Returns the current frame number.

<li>
<code>curve(frame)</code>: Evaluates the y-value of an animation curve at the given frame.

<li>
<code>value(frame)</code>: Returns the y value for an animation at the given frame.

<li>
<code>inrange(value, min, max)</code>: Checks if a value is within a specified range (useful for conditional logic). 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Noise and randomness"><h4 id="Noise and randomness" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Noise and randomness">Noise and randomness</a></h4></div>

<ul>
<li>
<code>noise(x, y, z)</code>: Generates a noise value based on the provided coordinates.

<li>
<code>fBm(x, y, z, octaves, lacunarity, gain)</code>: Fractal Brownian Motion noise.

<li>
<code>turbulence(x, y, z, octaves, lacunarity, gain)</code>: Similar to fBm, but uses the absolute value of the noise function.

<li>
<code>random(x)</code>: Generates a pseudo-random number based on x. 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Accessing other knob values"><h4 id="Accessing other knob values" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Accessing other knob values">Accessing other knob values</a></h4></div>

<p>
You can reference the value of any knob in Nuke using the format: NodeName.KnobName.
</p>
<ul>
<li>
Example: Transform1.translate.x.

<li>
Example: Grade1.blackpoint.

<li>
Example: Noise1.size 

</ul>
<div id="Available Functions in Nuke's Expression Node-Mathematical functions-Working with variables"><h4 id="Working with variables" class="header"><a href="#Available Functions in Nuke's Expression Node-Mathematical functions-Working with variables">Working with variables</a></h4></div>

<p>
The Expression node has built-in variable fields (e.g., expr0, expr1, expr2) where you can assign complex expressions and then reference these variables in the channel fields. 
</p>

<p>
By combining these functions with mathematical operations and conditional logic, you can create a wide range of powerful and flexible expressions for manipulating your images in Nuke.
</p>


<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
