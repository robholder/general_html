<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>unix_shell_zsh_scripting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="unix_tools_index.html">Unix Tools</a>
</p>

<div id="Zsh Scripting"><h1 id="Zsh Scripting" class="header"><a href="#Zsh Scripting">Zsh Scripting</a></h1></div>

<div id="Contents" class="toc"><h2 id="Contents">Contents</a></h2></div>
<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Zsh Scripting">Zsh Scripting</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Zsh Basics">Zsh Basics</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Shebang and Script Entry Point">Shebang and Script Entry Point</a>

<li>
<a href="unix_shell_zsh_scripting.html#Defining Functions">Defining Functions</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Conditional Statements">Conditional Statements</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Basic If/Else Syntax">Basic If/Else Syntax</a>

<li>
<a href="unix_shell_zsh_scripting.html#Numeric Tests">Numeric Tests</a>

<li>
<a href="unix_shell_zsh_scripting.html#Using the Traditional Test Command">Using the Traditional Test Command</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Testing Files and Directories">Testing Files and Directories</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Common File Test Operators">Common File Test Operators</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Example: Check if a Directory Exists">Example: Check if a Directory Exists</a>

<li>
<a href="unix_shell_zsh_scripting.html#Example: Check if a file exists and is readable">Example: Check if a file exists and is readable</a>

</ul>
</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Testing Variables and Environment Variables">Testing Variables and Environment Variables</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Testing for Emptiness">Testing for Emptiness</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Example:">Example:</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Setting and Exporting Variables">Setting and Exporting Variables</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Example:">Example:</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Combining Conditions">Combining Conditions</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Case Statement">Case Statement</a>

<li>
<a href="unix_shell_zsh_scripting.html#Putting It All Together: A Sample Script">Putting It All Together: A Sample Script</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Negative Conditionals">Negative Conditionals</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Using the Exclamation Mark Inside Double Brackets">Using the Exclamation Mark Inside Double Brackets</a>

<li>
<a href="unix_shell_zsh_scripting.html#Using the Exclamation Mark with the if Command">Using the Exclamation Mark with the if Command</a>

<li>
<a href="unix_shell_zsh_scripting.html#Using the Test Command with Negation">Using the Test Command with Negation</a>

<li>
<a href="unix_shell_zsh_scripting.html#Combining Multiple Conditions with Negation">Combining Multiple Conditions with Negation</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Summary">Summary</a>

<li>
<a href="unix_shell_zsh_scripting.html#Additional Tips">Additional Tips</a>

<li>
<a href="unix_shell_zsh_scripting.html#Conclusion">Conclusion</a>

<li>
<a href="unix_shell_zsh_scripting.html#Arrays">Arrays</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Arrays in Zsh">Arrays in Zsh</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Declaring Arrays">Declaring Arrays</a>

<li>
<a href="unix_shell_zsh_scripting.html#Iterating Over Array Elements">Iterating Over Array Elements</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Modifying Arrays">Modifying Arrays</a>

<li>
<a href="unix_shell_zsh_scripting.html#Positional Parameters and Shifting Arguments">Positional Parameters and Shifting Arguments</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Understanding Positional Parameters">Understanding Positional Parameters</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Example in a Function:">Example in a Function:</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Capturing All Arguments in an Array">Capturing All Arguments in an Array</a>

<li>
<a href="unix_shell_zsh_scripting.html#Shifting Arguments">Shifting Arguments</a>

<ul>
<li>
<a href="unix_shell_zsh_scripting.html#Example:">Example:</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Common Use Cases and Tips">Common Use Cases and Tips</a>

</ul>
<li>
<a href="unix_shell_zsh_scripting.html#Conclusion">Conclusion</a>

</ul>
</ul>

<p>
Below is a study guide that covers the most common conditional constructs, file and variable tests, and function syntax in zsh. This guide is designed to give you a broad overview of how to write robust zsh scripts with conditionals and functions.
</p>

<div id="Zsh Scripting-Zsh Basics"><h2 id="Zsh Basics" class="header"><a href="#Zsh Scripting-Zsh Basics">Zsh Basics</a></h2></div>

<div id="Zsh Scripting-Zsh Basics-Shebang and Script Entry Point"><h3 id="Shebang and Script Entry Point" class="header"><a href="#Zsh Scripting-Zsh Basics-Shebang and Script Entry Point">Shebang and Script Entry Point</a></h3></div>

<p>
Every script usually begins with a shebang line:
</p>

<pre zsh>
#!/usr/bin/env zsh
</pre>

<p>
This tells the system to use zsh as the interpreter.
</p>

<div id="Zsh Scripting-Zsh Basics-Defining Functions"><h3 id="Defining Functions" class="header"><a href="#Zsh Scripting-Zsh Basics-Defining Functions">Defining Functions</a></h3></div>

<p>
You can define functions in two common ways:
</p>

<pre zsh>
# Using the function keyword:
function my_function {
    echo "Hello from my_function"
}

# Or the shorthand syntax:
my_function2() {
    echo "Hello from my_function2"
}
</pre>

<p>
Functions can take parameters (accessed as <code>Dollar1</code>, <code>Dollar2</code>, …) and can <code>return</code> numbers via the return command (typically 0 for success).
</p>

<div id="Zsh Scripting-Conditional Statements"><h2 id="Conditional Statements" class="header"><a href="#Zsh Scripting-Conditional Statements">Conditional Statements</a></h2></div>

<p>
Zsh offers a few ways to implement conditionals, most notably with <code>if</code>, <code>else</code>, <code>elif</code>, and even <code>case</code> statements.
</p>

<div id="Zsh Scripting-Conditional Statements-Basic If/Else Syntax"><h3 id="Basic If/Else Syntax" class="header"><a href="#Zsh Scripting-Conditional Statements-Basic If/Else Syntax">Basic If/Else Syntax</a></h3></div>

<p>
Using double square brackets (<code>[[ ]]</code>) is recommended because it offers extended test capabilities and more predictable behavior with globbing and regex:
</p>

<pre zsh>
if [[ condition ]]; then
    # commands if condition is true
elif [[ another_condition ]]; then
    # commands if the alternative condition is true
else
    # commands if none matched
fi
</pre>

<p>
Example: Testing a Variable Value
</p>

<pre zsh>
VAR="hello"
if [[ "$VAR" == "hello" ]]; then
    echo "VAR is hello"
else
    echo "VAR is not hello"
fi
</pre>

<div id="Zsh Scripting-Conditional Statements-Numeric Tests"><h3 id="Numeric Tests" class="header"><a href="#Zsh Scripting-Conditional Statements-Numeric Tests">Numeric Tests</a></h3></div>

<p>
For arithmetic comparisons, use the double-parentheses syntax:
</p>

<pre zsh>
num=15
if (( num &gt; 10 )); then
    echo "num is greater than 10"
else
    echo "num is 10 or less"
fi
</pre>

<div id="Zsh Scripting-Conditional Statements-Using the Traditional Test Command"><h3 id="Using the Traditional Test Command" class="header"><a href="#Zsh Scripting-Conditional Statements-Using the Traditional Test Command">Using the Traditional Test Command</a></h3></div>

<p>
You can use the <code>[ ... ]</code> (or its synonym <code>test</code>) but note that it has fewer features than <code>[[ ... ]]</code> and requires careful quoting:
</p>

<pre zsh>
if [ "$VAR" = "hello" ]; then
    echo "VAR is hello"
fi
</pre>

<p>
Modern scripts usually prefer <code>[[ ... ]]</code> to avoid many pitfalls.
</p>

<div id="Zsh Scripting-Testing Files and Directories"><h2 id="Testing Files and Directories" class="header"><a href="#Zsh Scripting-Testing Files and Directories">Testing Files and Directories</a></h2></div>

<p>
Zsh (like other POSIX shells) provides file test operators that work inside [ ] or <a href=" .html"> .html</a>.
</p>

<div id="Zsh Scripting-Testing Files and Directories-Common File Test Operators"><h3 id="Common File Test Operators" class="header"><a href="#Zsh Scripting-Testing Files and Directories-Common File Test Operators">Common File Test Operators</a></h3></div>

<ul>
<li>
<code>-e file</code>: True if the file exists.

<li>
<code>-f file</code>: True if the file exists and is a regular file.

<li>
<code>-d file</code>: True if the file exists and is a directory.

<li>
<code>-r file</code>: True if the file is readable.

<li>
<code>-w file</code>: True if the file is writable.

<li>
<code>-x file</code>: True if the file is executable.

<li>
<code>-s file</code>: True if the file exists and is not empty.

<li>
<code>-L file</code>: True if the file is a symbolic link.

<li>
<code>file1 -nt file2</code>: True if file1 is newer than file2.

<li>
<code>file1 -ot file2</code>: True if file1 is older than file2.

</ul>

<div id="Zsh Scripting-Testing Files and Directories-Common File Test Operators-Example: Check if a Directory Exists"><h4 id="Example: Check if a Directory Exists" class="header"><a href="#Zsh Scripting-Testing Files and Directories-Common File Test Operators-Example: Check if a Directory Exists">Example: Check if a Directory Exists</a></h4></div>

<pre zsh>
DIRECTORY="/path/to/directory"
if [[ -d "$DIRECTORY" ]]; then
    echo "Directory exists."
else
    echo "Directory does not exist."
fi
</pre>

<div id="Zsh Scripting-Testing Files and Directories-Common File Test Operators-Example: Check if a file exists and is readable"><h4 id="Example: Check if a file exists and is readable" class="header"><a href="#Zsh Scripting-Testing Files and Directories-Common File Test Operators-Example: Check if a file exists and is readable">Example: Check if a file exists and is readable</a></h4></div>

<pre zsh>
FILE="/path/to/file"
if [[ -e "$FILE" &amp;&amp; -r "$FILE" ]]; then
    echo "The file exists and is readable."
else
    echo "The file doesn't exist or isn't readable."
fi
</pre>

<div id="Zsh Scripting-Testing Variables and Environment Variables"><h2 id="Testing Variables and Environment Variables" class="header"><a href="#Zsh Scripting-Testing Variables and Environment Variables">Testing Variables and Environment Variables</a></h2></div>

<div id="Zsh Scripting-Testing Variables and Environment Variables-Testing for Emptiness"><h3 id="Testing for Emptiness" class="header"><a href="#Zsh Scripting-Testing Variables and Environment Variables-Testing for Emptiness">Testing for Emptiness</a></h3></div>

<ul>
<li>
<code>-z "$variable"</code>: True if the variable is empty.

<li>
<code>-n "$variable"</code>: True if the variable is non-empty.

</ul>

<div id="Zsh Scripting-Testing Variables and Environment Variables-Testing for Emptiness-Example:"><h4 id="Example:" class="header"><a href="#Zsh Scripting-Testing Variables and Environment Variables-Testing for Emptiness-Example:">Example:</a></h4></div>

<pre zsh>
if [[ -z "$MY_ENV_VAR" ]]; then
    echo "MY_ENV_VAR is empty or not set."
else
    echo "MY_ENV_VAR is: $MY_ENV_VAR"
fi
</pre>

<div id="Zsh Scripting-Testing Variables and Environment Variables-Setting and Exporting Variables"><h3 id="Setting and Exporting Variables" class="header"><a href="#Zsh Scripting-Testing Variables and Environment Variables-Setting and Exporting Variables">Setting and Exporting Variables</a></h3></div>

<ul>
<li>
Local variables: Use <code>local</code> inside functions.

<li>
Environment variables: Use <code>export</code> so they are available to child processes.

</ul>

<div id="Zsh Scripting-Testing Variables and Environment Variables-Setting and Exporting Variables-Example:"><h4 id="Example:" class="header"><a href="#Zsh Scripting-Testing Variables and Environment Variables-Setting and Exporting Variables-Example:">Example:</a></h4></div>

<pre zsh>
# Inside a function:
my_function() {
    local local_var="I am local"
    export GLOBAL_VAR="I am global"
}
</pre>

<div id="Zsh Scripting-Testing Variables and Environment Variables-Combining Conditions"><h3 id="Combining Conditions" class="header"><a href="#Zsh Scripting-Testing Variables and Environment Variables-Combining Conditions">Combining Conditions</a></h3></div>

<p>
You can combine tests using logical operators like <code>&amp;&amp;</code> (and) and <code>||</code> (or):
</p>

<pre zsh>
if [[ -d "$DIRECTORY" &amp;&amp; -w "$DIRECTORY" ]]; then
    echo "Directory exists and is writable."
else
    echo "Directory does not exist or is not writable."
fi
</pre>

<p>
For more complex cases, you might nest conditions or use additional grouping with parentheses inside <code>[[ ... ]]</code>.
</p>

<div id="Zsh Scripting-Case Statement"><h2 id="Case Statement" class="header"><a href="#Zsh Scripting-Case Statement">Case Statement</a></h2></div>

<p>
Sometimes conditionals are simpler with <code>case</code> especially with pattern matching:
</p>

<pre zsh>
read -r choice
case "$choice" in
    [Yy]* )
        echo "User chose yes."
        ;;
    [Nn]* )
        echo "User chose no."
        ;;
    * )
        echo "Please answer yes or no."
        ;;
esac
</pre>

<div id="Zsh Scripting-Putting It All Together: A Sample Script"><h2 id="Putting It All Together: A Sample Script" class="header"><a href="#Zsh Scripting-Putting It All Together: A Sample Script">Putting It All Together: A Sample Script</a></h2></div>

<p>
The following is a sample script that demonstrates several of the above concepts:
</p>

<pre zsh>
#!/usr/bin/env zsh

# Function to check directory and prompt for creation if not exists:
ensure_directory() {
    local dir="$1"   # Get the directory path from the first argument
    
    if [[ -d "$dir" ]]; then
        echo "Directory '$dir' already exists."
        return 0
    fi

    # Ask user for confirmation:
    echo -n "Directory '$dir' does not exist. Create it now? (y/N): "
    read -r user_input
    if [[ "$user_input" != "y" ]]; then
        echo "Operation canceled by user."
        return 1
    fi

    # Create the directory
    mkdir -p "$dir"
    if [[ $? -eq 0 ]]; then
        echo "Directory created successfully."
        return 0
    else
        echo "Failed to create the directory."
        return 1
    fi
}

# Example usage of variable and file tests:
FILE="/tmp/testfile.txt"

if [[ -e "$FILE" ]]; then
    echo "File '$FILE' exists."
else
    echo "File '$FILE' does not exist. Creating file..."
    # Create an empty file:
    touch "$FILE"
fi

# Check an environment variable:
if [[ -z "$MY_ENV_VAR" ]]; then
    echo "MY_ENV_VAR is not set or is empty. Setting it now..."
    export MY_ENV_VAR="default_value"
fi

# Call function to ensure directory exists:
TARGET_DIR="/tmp/my_new_directory"
ensure_directory "$TARGET_DIR" || return 1  # Use 'exit 1' if running as a script, but 'return' when sourcing

echo "Continuing script execution..."
# ... rest of the script ...
</pre>

<div id="Negative Conditionals"><h1 id="Negative Conditionals" class="header"><a href="#Negative Conditionals">Negative Conditionals</a></h1></div>

<p>
Negative conditionals in zsh (and other POSIX shells) let you execute a block of code when a condition is false. There are several ways to write “if not” statements. Here are a few methods along with examples:
</p>

<div id="Negative Conditionals-Using the Exclamation Mark Inside Double Brackets"><h3 id="Using the Exclamation Mark Inside Double Brackets" class="header"><a href="#Negative Conditionals-Using the Exclamation Mark Inside Double Brackets">Using the Exclamation Mark Inside Double Brackets</a></h3></div>

<p>
When using <code>[[ ... ]]</code>, you can prefix your condition with an exclamation mark (<code>!</code>) to negate it:
</p>

<pre zsh>
if [[ ! -f "$myfile" ]]; then
    echo "File does not exist."
fi
</pre>

<p>
In this example, the code inside the <code>if</code> block executes only when <code>$myfile</code> is not a regular file.
</p>

<div id="Negative Conditionals-Using the Exclamation Mark with the if Command"><h3 id="Using the Exclamation Mark with the if Command" class="header"><a href="#Negative Conditionals-Using the Exclamation Mark with the if Command">Using the Exclamation Mark with the if Command</a></h3></div>

<p>
You can also put the exclamation mark directly before a command to test its negation. This is handy with commands that return either a success (0) or failure (non-zero) exit status:
</p>

<pre zsh>
if ! grep -q "pattern" "$file"; then
    echo "Pattern not found in $file."
fi
</pre>

<p>
Here, the <code>grep -q</code> command searches for the pattern silently. The <code>!</code> in front means that if <code>grep</code> does not find the pattern (i.e., returns a non-zero status), the <code>if</code> block will execute.
</p>

<div id="Negative Conditionals-Using the Test Command with Negation"><h3 id="Using the Test Command with Negation" class="header"><a href="#Negative Conditionals-Using the Test Command with Negation">Using the Test Command with Negation</a></h3></div>

<p>
If you use the older test syntax (either with <code>[ ... ]</code> or <code>test</code>), you can also negate conditions:
</p>

<pre zsh>
if [ ! -d "$DIRECTORY" ]; then
    echo "Directory does not exist."
fi
</pre>

<p>
Make sure to put the <code>!</code> immediately after the opening bracket with proper spacing around it.
</p>

<div id="Negative Conditionals-Combining Multiple Conditions with Negation"><h3 id="Combining Multiple Conditions with Negation" class="header"><a href="#Negative Conditionals-Combining Multiple Conditions with Negation">Combining Multiple Conditions with Negation</a></h3></div>

<p>
You can mix and match logical operators as well:
</p>

<pre zsh>
if [[ ! -r "$file" || ! -w "$file" ]]; then
    echo "The file is either not readable or not writable."
fi
</pre>

<p>
This conditional shows that if either the file is not readable or not writable, the block will be executed.
</p>

<div id="Negative Conditionals-Summary"><h2 id="Summary" class="header"><a href="#Negative Conditionals-Summary">Summary</a></h2></div>

<ul>
<li>
Prefix the condition with <code>!</code>: Example: if <code>[[ ! condition ]]; then ...</code>

<li>
Negate a command's exit status: Example: <code>if ! command; then ...</code>

<li>
Use within <code>[ ... ]</code> constructs: Always make sure you have proper spacing when negating with <code>[ ! condition ]</code>.

</ul>

<p>
These patterns allow you to easily check for negative conditions in your zsh script. Experiment with them in your scripts to see which style feels most natural for your use cases.
</p>

<div id="Negative Conditionals-Additional Tips"><h2 id="Additional Tips" class="header"><a href="#Negative Conditionals-Additional Tips">Additional Tips</a></h2></div>

<ul>
<li>
<span id="Negative Conditionals-Additional Tips-Quoting"></span><strong id="Quoting">Quoting</strong>: Always quote your variables (e.g., <code>"$var"</code>) in tests to avoid issues with spaces or empty values.

<li>
<span id="Negative Conditionals-Additional Tips-Double vs. Single Brackets"></span><strong id="Double vs. Single Brackets">Double vs. Single Brackets</strong>: Use <code>[[ ... ]]</code> for conditionals in zsh for advanced features such as pattern matching. The old <code>[ ... ]</code> syntax still works but has more quirks.

<li>
<span id="Negative Conditionals-Additional Tips-Error Checking"></span><strong id="Error Checking">Error Checking</strong>: Check command exit statuses (with <code>$?</code>) if you need to make decisions based on prior commands.

<li>
<span id="Negative Conditionals-Additional Tips-Interactive and Non-interactive Modes"></span><strong id="Interactive and Non-interactive Modes">Interactive and Non-interactive Modes</strong>: When sourcing a script vs executing it, be mindful of using <code>return</code> (for functions or sourced scripts) versus <code>exit</code> (for scripts executed as separate processes).

</ul>

<div id="Conclusion"><h1 id="Conclusion" class="header"><a href="#Conclusion">Conclusion</a></h1></div>

<p>
This study guide has covered:
</p>
<ul>
<li>
Basic syntax of conditionals and functions in zsh.

<li>
File test operators for checking paths and file attributes.

<li>
Variable and environment variable testing.

<li>
Combining conditions and using <code>if/elif/else</code> along with <code>case</code> statements.

<li>
Practical examples that illustrate how to build robust scripts.

</ul>

<p>
Experiment with these examples and tweak them to explore additional features such as arithmetic tests <code>((( ... )))</code> and advanced pattern matching.
</p>

<div id="Arrays"><h1 id="Arrays" class="header"><a href="#Arrays">Arrays</a></h1></div>

<p>
Below is a study guide on using arrays and handling positional parameters (including shifting arguments) in zsh. This guide covers how to declare, access, and iterate over arrays, as well as how to work with function arguments and the differences between using <code>Dollar1</code> and <code>Dollar@</code>.
</p>

<div id="Arrays-Arrays in Zsh"><h2 id="Arrays in Zsh" class="header"><a href="#Arrays-Arrays in Zsh">Arrays in Zsh</a></h2></div>

<div id="Arrays-Arrays in Zsh-Declaring Arrays"><h3 id="Declaring Arrays" class="header"><a href="#Arrays-Arrays in Zsh-Declaring Arrays">Declaring Arrays</a></h3></div>

<p>
Basic Declaration: An array in zsh is declared by listing its elements within parentheses. Example:
</p>

<pre zsh>
fruits=("Apple" "Banana" "Cherry")
</pre>
  
<ul>
<li>
<span id="Arrays-Arrays in Zsh-Declaring Arrays-Accessing the Entire Array"></span><strong id="Accessing the Entire Array">Accessing the Entire Array</strong>: Use the syntax <code>${array_name[@]}</code> to expand to all elements:

</ul>
  
<pre zsh>
echo "${fruits[@]}"
</pre>

<p>
This outputs all the elements separated by the first character of the output field separator, usually a space.
</p>

<ul>
<li>
<span id="Arrays-Arrays in Zsh-Declaring Arrays-Accessing Individual Elements"></span><strong id="Accessing Individual Elements">Accessing Individual Elements</strong>: You can access a particular element via its index. Note that zsh arrays are 1-indexed by default:

</ul>
  
<pre zsh>
echo "${fruits[1]}"  # Outputs: Apple
echo "${fruits[2]}"  # Outputs: Banana
</pre>

<div id="Arrays-Arrays in Zsh-Iterating Over Array Elements"><h3 id="Iterating Over Array Elements" class="header"><a href="#Arrays-Arrays in Zsh-Iterating Over Array Elements">Iterating Over Array Elements</a></h3></div>

<ul>
<li>
<code>Using a Loop</code>: To loop over every element in the array:

</ul>
  
<pre zsh>
for fruit in "${fruits[@]}"; do
    echo "Fruit: $fruit"
done
</pre>

<p>
This ensures each element is handled separately—even if an element contains spaces.
</p>

<ul>
<li>
<code>Getting the Array Length</code>: Use the syntax <code>${#array_name[@]}</code> to get the number of elements:

</ul>
  
<pre zsh>
echo "There are ${#fruits[@]} fruits."
</pre>

<div id="Arrays-Modifying Arrays"><h2 id="Modifying Arrays" class="header"><a href="#Arrays-Modifying Arrays">Modifying Arrays</a></h2></div>

<ul>
<li>
<code>Appending an Element</code>: You can add an element to an array like this:

</ul>
  
<pre zsh>
fruits+=("Durian")
</pre>

<ul>
<li>
<code>Replacing an Element</code>: To change an element:

</ul>
  
<pre zsh>
fruits[2]="Blueberry"
</pre>

<ul>
<li>
<code>Removing an Element</code>: To remove an element, you might unset it:

</ul>
  
<pre zsh>
unset 'fruits[3]'
</pre>

<p>
Keep in mind that this leaves a "hole" in the array indexes. You might need to reindex if order matters.
</p>

<div id="Arrays-Positional Parameters and Shifting Arguments"><h2 id="Positional Parameters and Shifting Arguments" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments">Positional Parameters and Shifting Arguments</a></h2></div>

<div id="Arrays-Positional Parameters and Shifting Arguments-Understanding Positional Parameters"><h3 id="Understanding Positional Parameters" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments-Understanding Positional Parameters">Understanding Positional Parameters</a></h3></div>

<ul>
<li>
<code>Dollar1</code> vs <code>"Dollar@"</code>:

<ul>
<li>
<code>$1</code>: Represents only the first argument passed to a script or function.

<li>
<code>"$@"</code>: Represents all the positional parameters as separate quoted strings.

</ul>
</ul>

<div id="Arrays-Positional Parameters and Shifting Arguments-Understanding Positional Parameters-Example in a Function:"><h4 id="Example in a Function:" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments-Understanding Positional Parameters-Example in a Function:">Example in a Function:</a></h4></div>

<pre zsh>
my_function() {
    echo "First parameter: $1"
    echo "All parameters: $@"
    echo "Iterating over parameters:"
    for arg in "$@"; do
        echo "Arg: $arg"
    done
}
</pre>

<p>
If you call <code>my_function "one" "two three" "four"</code>, then:
</p>
<ul>
<li>
<code>$1</code> will be <code>one</code>.

<li>
<code>"$@"</code> preserves each argument as its own entity (important if an argument has spaces).

</ul>

<div id="Arrays-Positional Parameters and Shifting Arguments-Capturing All Arguments in an Array"><h3 id="Capturing All Arguments in an Array" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments-Capturing All Arguments in an Array">Capturing All Arguments in an Array</a></h3></div>

<ul>
<li>
<span id="Arrays-Positional Parameters and Shifting Arguments-Capturing All Arguments in an Array-Storing Arguments in an Array"></span><strong id="Storing Arguments in an Array">Storing Arguments in an Array</strong>: To capture every argument passed into a function as an array, use the following syntax:

</ul>
  
<pre zsh>
process_args() {
    local args=("$@")
    echo "Number of arguments: ${#args[@]}"
    for arg in "${args[@]}"; do
        echo "Argument: $arg"
    done
}
</pre>

<p>
This tells zsh to create an array <code>args</code> where each element is one positional parameter.
</p>

<div id="Arrays-Positional Parameters and Shifting Arguments-Shifting Arguments"><h3 id="Shifting Arguments" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments-Shifting Arguments">Shifting Arguments</a></h3></div>

<ul>
<li>
<span id="Arrays-Positional Parameters and Shifting Arguments-Shifting Arguments-The shift Command"></span><strong id="The shift Command">The shift Command</strong>: <code>shift</code> removes the first positional parameter and shifts all others one position to the left.

</ul>

<div id="Arrays-Positional Parameters and Shifting Arguments-Shifting Arguments-Example:"><h4 id="Example:" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments-Shifting Arguments-Example:">Example:</a></h4></div>

<pre zsh>
echo "Before shift: $@"
shift
echo "After shift: $@"
</pre>

<p>
In a function, you might use it to process arguments one by one:
</p>

<pre zsh>
process_each() {
    while [[ "$#" -gt 0 ]]; do
        echo "Processing: $1"
        shift
    done
}
</pre>

<p>
If <code>process_each</code> is called with several arguments, the loop processes each argument individually until no arguments remain.
</p>

<div id="Arrays-Positional Parameters and Shifting Arguments-Common Use Cases and Tips"><h3 id="Common Use Cases and Tips" class="header"><a href="#Arrays-Positional Parameters and Shifting Arguments-Common Use Cases and Tips">Common Use Cases and Tips</a></h3></div>

<p>
Looping Through Arguments: Instead of manually shifting, you can also loop over <code>"$@"</code>:
</p>

<pre zsh>
for param in "$@"; do
    echo "Parameter: $param"
done
</pre>

<p>
Combining with Array Declarations: Sometimes you might want to take all parameters as an array for flexible processing. For example, in a function:
</p>

<pre zsh>
handle_dirs() {
    local baseDir="$1"
    shift 1  # Remove the first parameter
    local directories=("$@")
    echo "Base directory: $baseDir"
    echo "Directories to process:"
    for dir in "${directories[@]}"; do
        echo "$dir"
    done
}
</pre>

<p>
Remember to Quote: Always place quotes around <code>"\(@"</code> and array expansions like <code>"\){array[@]}"</code> to avoid issues with spaces or globbing.
</p>

<div id="Arrays-Conclusion"><h2 id="Conclusion" class="header"><a href="#Arrays-Conclusion">Conclusion</a></h2></div>

<p>
This guide covers:
</p>
<ul>
<li>
<span id="Arrays-Conclusion-Arrays in zsh"></span><strong id="Arrays in zsh">Arrays in zsh</strong>: Declaring, accessing, iterating, and modifying arrays.

<li>
Positional Parameters: The difference between <code>Dollar1</code> (the first argument) and <code>"$@"</code> (all arguments as separate entities).

<li>
<span id="Arrays-Conclusion-Shifting Arguments"></span><strong id="Shifting Arguments">Shifting Arguments</strong>: Using <code>shift</code> to process or remove arguments.

</ul>

<p>
By practicing these constructs in sample scripts, you'll gain a solid foundation in zsh scripting. Experiment with variations and combine them with conditionals and functions for more complex automation tasks
</p>


<p>
<a href="unix_tools_index.html">Unix Tools</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
