<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>python_regex_flags</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="Python.html">Python</a>
</p>

<div id="Regex"><h1 id="Regex" class="header"><a href="#Regex">Regex</a></h1></div>

<p>
Below is an overview of common regex "flags" (actually shorthand metacharacters and grouping tools) you can use with Python’s <code>re</code> module. This overview explains what each symbol means and shows how to capture parts of your match using groups.
</p>

<div id="Regex-Basic Shorthand Character Classes"><h3 id="Basic Shorthand Character Classes" class="header"><a href="#Regex-Basic Shorthand Character Classes">Basic Shorthand Character Classes</a></h3></div>

<p>
These are one‑character shortcuts that match specific types of characters:
</p>
<ul>
<li>
<code>\b</code> – Word Boundary It asserts a position between a word character (<code>[A-Za-z0-9_]</code>) and a non‑word character. For example, the pattern <code>\bcat\b</code> will match <code>"cat"</code> as a whole word but not <code>"scatter"</code>.

<li>
<code>\B</code> – Non-Word Boundary The opposite of <code>\b</code>; it asserts that the current position is not a word boundary. For instance, it could be used to match “at” within “cat” (i.e. not at the word edge).

<li>
<code>\d</code> – Digit Matches any decimal digit. It is equivalent to <code>[0-9]</code>. Example:

</ul>
  
<pre python>
import re
re.search(r'\d', 'abc4xyz')  # Will match '4'
</pre>

<ul>
<li>
<code>\D</code> – Non-Digit Matches any character that is not a digit. Equivalent to [^0-9].

<li>
<code>\s</code> – Whitespace Matches any whitespace character (spaces, tabs, newlines, etc.). Example:

</ul>
  
<pre python>
re.search(r'\s', 'Hello World')  # Matches the space between words
</pre>

<ul>
<li>
<code>\S</code> – Non-Whitespace Matches any character that is not a whitespace.

<li>
<code>\w</code> – Word Character Matches letters, digits, and the underscore (equivalent to [A-Za-z0-9_]).

<li>
<code>\W</code> – Non-Word Character Matches any character that is not a word character.

<li>
<code>.</code> – Dot Matches any character except a newline (unless you use the re.DOTALL flag).

<li>
<code>^</code> – Start of line.

<li>
<code>$</code> – End of line.

</ul>
<div id="Regex-Matching Specific Patterns with Quantifiers"><h3 id="Matching Specific Patterns with Quantifiers" class="header"><a href="#Regex-Matching Specific Patterns with Quantifiers">Matching Specific Patterns with Quantifiers</a></h3></div>

<p>
While not “flags” per se, quantifiers help you repeat patterns:
</p>
<ul>
<li>
<code>*</code> – Matches 0 or more repetitions.

<li>
<code>+</code> – Matches 1 or more repetitions.

<li>
<code>?</code> – Matches 0 or 1 occurrence (also used for non-greedy matching when placed after another quantifier).

<li>
<code>{n}</code> – Matches exactly n times.

<li>
<code>{n,}</code> – Matches at least n times.

<li>
<code>{n,m}</code> – Matches between n and m times.

</ul>
<div id="Regex-Grouping and Capturing"><h3 id="Grouping and Capturing" class="header"><a href="#Regex-Grouping and Capturing">Grouping and Capturing</a></h3></div>

<p>
Parentheses in regex do two things: they group parts of the pattern, and they capture the matched text so you can refer to it later.
</p>

<div id="Regex-Capturing Groups"><h2 id="Capturing Groups" class="header"><a href="#Regex-Capturing Groups">Capturing Groups</a></h2></div>

<p>
Basic Grouping: Use parentheses <code>()</code> around a pattern to create a capture group. Example:
</p>

<pre python>
import re
text = "2025-05-02"
match = re.search(r'(\d{4})-(\d{2})-(\d{2})', text)

if match:
    year  = match.group(1)  # '2025'
    month = match.group(2)  # '05'
    day   = match.group(3)  # '02'
    print("Captured date:", year, month, day)
</pre>

<p>
In this case, each pair of parentheses captures a part of the date (year, month, and day respectively).
</p>

<ul>
<li>
<span id="Regex-Capturing Groups-Named Groups"></span><strong id="Named Groups">Named Groups</strong>: You can assign a name to a group using the syntax <code>(?P&lt;name&gt;pattern)</code>. Example:

</ul>
  
<pre python>
match = re.search(r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})', text)
if match:
    print("Year:", match.group('year'))
    print("Month:", match.group('month'))
    print("Day:", match.group('day'))
</pre>

<p>
Named groups make your code more readable than relying solely on numerical indices.
</p>

<ul>
<li>
<span id="Regex-Capturing Groups-Non-Capturing Groups"></span><strong id="Non-Capturing Groups">Non-Capturing Groups</strong>: Use <code>(?:...)</code> to group parts of a pattern without capturing them. This is useful when you need to structure the regex but you're not interested in extracting the matched text. Example:

</ul>
  
<pre python>
# This will match either 'cat' or 'dog' but not create a capture group.
re.search(r'(?:cat|dog)', "I have a dog")
</pre>

<div id="Regex-Capturing Groups-Using Groups for Partial Collections"><h3 id="Using Groups for Partial Collections" class="header"><a href="#Regex-Capturing Groups-Using Groups for Partial Collections">Using Groups for Partial Collections</a></h3></div>

<p>
Once you have groups in your pattern, you can retrieve the captured substrings using the match object’s <code>.group()</code> method:
</p>
<ul>
<li>
<code>match.group(0)</code> returns the entire match.

<li>
<code>match.group(1), match.group(2), ...</code> return the corresponding captured groups in order.

<li>
<code>match.groups()</code> returns a tuple of all the captured groups.

</ul>
<div id="Regex-Flags that Modify Matching Behavior"><h2 id="Flags that Modify Matching Behavior" class="header"><a href="#Regex-Flags that Modify Matching Behavior">Flags that Modify Matching Behavior</a></h2></div>

<p>
While the shorthand options like <code>\b</code>, <code>\d</code>, etc., are built into the pattern itself, the <code>re</code> module also supports various flags that can be passed either to functions like <code>re.search()</code> or when using <code>re.compile()</code>. Some common flags are:
</p>

<ul>
<li>
<code>re.IGNORECASE</code> or <code>re.I</code> Makes the match case-insensitive.

<li>
<code>re.MULTILINE</code> or <code>re.M</code> Changes the behavior of the caret (<code>^</code>) and dollar sign (<code>$</code>) so they match at the beginning and end of each line (not just the beginning and end of the whole string).

<li>
<code>re.DOTALL</code> or <code>re.S</code> When this flag is given, the dot (<code>.</code>) matches every character, including a newline.

<li>
<code>re.VERBOSE</code> or <code>re.X</code> Allows you to write regular expressions that span multiple lines with whitespace and comments; very useful for complex regex patterns.

</ul>
<p>
Example using flags:
</p>

<pre python>
pattern = re.compile(r"""
    ^          # Start of the line
    (\d{4})    # Capture a 4-digit year
    -          # Literal dash
    (\d{2})    # Capture a 2-digit month
    -          # Literal dash
    (\d{2})    # Capture a 2-digit day
    $          # End of line
    """, re.VERBOSE)

match = pattern.search("2025-05-02")
if match:
    print(match.groups())
</pre>

<div id="Regex-Flags that Modify Matching Behavior-Summary"><h3 id="Summary" class="header"><a href="#Regex-Flags that Modify Matching Behavior-Summary">Summary</a></h3></div>

<ul>
<li>
Character Classes (e.g., <code>\b</code>, <code>\d</code>, <code>\s</code>, <code>\S</code>, etc.): Provide shortcuts for matching types of characters.

<li>
Quantifiers (e.g., <code>*</code>, <code>+</code>, <code>?</code>, <code>{n, m}</code>): Control how many times you repeat matches.

<li>
Grouping:

<ul>
<li>
Capturing Groups (<code>(...)</code>): Divide the pattern into parts you can extract later.

<li>
Named Groups (<code>(?P&lt;name&gt;...)</code>): Make extracted parts easier to reference by name.

<li>
Non-Capturing Groups (<code>(?:...)</code>): Group without capturing.

</ul>
<li>
Regex Flags (e.g., <code>re.I</code>, <code>re.M</code>, etc.): Modify how the pattern matches the input.

</ul>
<p>
This breakdown should give you a helpful reference for writing, testing, and understanding regular expressions in Python.
</p>

<p>
<a href="Python.html">Python</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
