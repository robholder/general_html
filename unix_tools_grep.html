<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>unix_tools_grep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="unix_tools_index.html">Unix Tools</a>
</p>

<div id="grep"><h1 id="grep" class="header"><a href="#grep">grep</a></h1></div>

<p>
Below is a comprehensive breakdown of the <code>grep</code> utility—its syntax, options, and many examples to help you master its usage.
</p>

<div id="grep-Basic Syntax"><h2 id="Basic Syntax" class="header"><a href="#grep-Basic Syntax">Basic Syntax</a></h2></div>

<p>
The general usage is:
</p>

<pre sh>
grep [OPTIONS] PATTERN [FILE...]
</pre>

<ul>
<li>
<code>PATTERN</code> is the text or regular expression you want to search for.

<li>
<code>FILE</code>... is a list of one or more files in which to search. If omitted, <code>grep</code> reads from standard input.

</ul>
<div id="grep-Basic Syntax-Example:"><h4 id="Example:" class="header"><a href="#grep-Basic Syntax-Example:">Example:</a></h4></div>

<pre sh>
grep "error" logfile.txt
</pre>

<p>
This searches for the literal string "error" in logfile.txt and prints every line that contains it.
</p>

<div id="grep-Common Options"><h2 id="Common Options" class="header"><a href="#grep-Common Options">Common Options</a></h2></div>

<div id="grep-Common Options-Case Sensitivity"><h3 id="Case Sensitivity" class="header"><a href="#grep-Common Options-Case Sensitivity">Case Sensitivity</a></h3></div>

<ul>
<li>
<code>-i</code>: Ignore case

</ul>
  
<pre sh>
grep -i "Error" logfile.txt
</pre>

<p>
This matches “error”, “Error”, “ERROR”, etc.
</p>

<div id="grep-Common Options-Line Numbers and Filename Output"><h3 id="Line Numbers and Filename Output" class="header"><a href="#grep-Common Options-Line Numbers and Filename Output">Line Numbers and Filename Output</a></h3></div>

<ul>
<li>
<code>-n</code>: Print line numbers

</ul>
  
<pre sh>
grep -n "error" logfile.txt
</pre>

<div id="grep-Common Options-Each matching line is prefixed by its line number."><h3 id="Each matching line is prefixed by its line number." class="header"><a href="#grep-Common Options-Each matching line is prefixed by its line number.">Each matching line is prefixed by its line number.</a></h3></div>

<ul>
<li>
<code>-H</code>: Force filename output (useful when searching a single file among many)

</ul>
  
<pre sh>
grep -H "error" logfile.txt
</pre>

<div id="grep-Common Options-Recursive Search"><h3 id="Recursive Search" class="header"><a href="#grep-Common Options-Recursive Search">Recursive Search</a></h3></div>

<ul>
<li>
<code>-R</code> or <code>-r</code>: Recursively search directories

</ul>
  
<pre sh>
grep -R "error" .
</pre>

<p>
Searches for “error” in all files in the current directory and its subdirectories.
</p>

<div id="grep-Common Options-Counting and Listing"><h3 id="Counting and Listing" class="header"><a href="#grep-Common Options-Counting and Listing">Counting and Listing</a></h3></div>

<ul>
<li>
<code>-c</code>: Count lines

</ul>
  
<pre sh>
grep -c "error" logfile.txt
</pre>

<p>
Instead of printing each matching line, it prints the total count of matching lines.
</p>

<div id="grep-Common Options-List Matching File Names"><h3 id="List Matching File Names" class="header"><a href="#grep-Common Options-List Matching File Names">List Matching File Names</a></h3></div>

<ul>
<li>
<code>-l</code>: List the file names that contain a match

</ul>
  
<pre sh>
grep -l "error" *
</pre>

<div id="grep-Common Options-List Non-Matching File Names"><h3 id="List Non-Matching File Names" class="header"><a href="#grep-Common Options-List Non-Matching File Names">List Non-Matching File Names</a></h3></div>

<ul>
<li>
<code>-L</code>: List files that do NOT contain the match

</ul>
  
<pre sh>
grep -L "error" *
</pre>

<div id="grep-Common Options-Displaying Parts of Lines"><h3 id="Displaying Parts of Lines" class="header"><a href="#grep-Common Options-Displaying Parts of Lines">Displaying Parts of Lines</a></h3></div>

<ul>
<li>
<code>-o</code>: Print only the matching part of the line

</ul>
  
<pre sh>
grep -o "error" logfile.txt
</pre>

<p>
If a line contains multiple matches, every match is printed on its own line.
</p>

<div id="grep-Common Options-Inverting the Match"><h3 id="Inverting the Match" class="header"><a href="#grep-Common Options-Inverting the Match">Inverting the Match</a></h3></div>

<ul>
<li>
<code>-v</code>: Invert match (print lines that do not match the pattern)

</ul>
  
<pre sh>
grep -v "error" logfile.txt
</pre>

<div id="grep-Common Options-Whole Word Matching"><h3 id="Whole Word Matching" class="header"><a href="#grep-Common Options-Whole Word Matching">Whole Word Matching</a></h3></div>

<ul>
<li>
<code>-w</code>: Match whole words only

</ul>
  
<pre sh>
grep -w "error" logfile.txt
</pre>

<p>
This ensures that, for example, matching "error" will not match "terror".
</p>

<div id="grep-Regular Expressions and Extended Patterns"><h2 id="Regular Expressions and Extended Patterns" class="header"><a href="#grep-Regular Expressions and Extended Patterns">Regular Expressions and Extended Patterns</a></h2></div>

<div id="grep-Regular Expressions and Extended Patterns-Basic vs. Extended Regex"><h3 id="Basic vs. Extended Regex" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Basic vs. Extended Regex">Basic vs. Extended Regex</a></h3></div>

<ul>
<li>
Basic RegEx (BRE): By default, <code>grep</code> uses BRE. Some metacharacters (like <code>?</code>, <code>+</code>, <code>{}</code>, and <code>|</code>) must be escaped to be used literally.

<li>
Extended RegEx (ERE): Using the <code>-E</code> option (or invoking <code>egrep</code>), you can use these metacharacters without the need to escape them.

</ul>
<p>
Example using extended regex:
</p>

<pre sh>
grep -E "error|fault" logfile.txt
</pre>

<p>
This matches lines containing either <code>"error"</code> or <code>"fault"</code>.
</p>

<div id="grep-Regular Expressions and Extended Patterns-Some Regex Examples"><h3 id="Some Regex Examples" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Some Regex Examples">Some Regex Examples</a></h3></div>

<ul>
<li>
Dot (<code>.</code>): Matches any single character (except a newline). Pattern: <code>e.r</code> will match <code>"ear"</code>, <code>"err"</code>, etc.

<li>
Asterisk (<code>*</code>): Matches zero or more occurrences of the preceding character. Pattern: <code>lo*king</code> matches <code>"lking"</code>, <code>"looking"</code>, or <code>"looooking"</code>.

<li>
Plus (<code>+</code>) (in ERE mode): Matches one or more occurrences. Pattern: <code>lo+king</code> does not match <code>"lking"</code>, but matches <code>"looking"</code> (and <code>"looooking"</code>).

<li>
Question Mark (<code>?</code>) (in ERE mode): Matches zero or one occurrence. Pattern: <code>colou?r</code> matches both <code>"color"</code> and <code>"colour"</code>.

<li>
Curly Braces (<code>{}</code>): Specifies an exact number or a range of occurrences. Example (in basic regex, you’d need to escape them): Pattern: <code>\d\{3\}</code> (with Vim-style syntax) or in grep with ERE mode:

</ul>
  
<pre sh>
grep -E '[0-9]{3}' file.txt
</pre>

<p>
This matches any three consecutive digits.
</p>

<ul>
<li>
Anchors (<code>^</code> and <code>$</code>):

<ul>
<li>
<code>^</code> asserts the beginning of a line.

<li>
<code>$</code> asserts the end of a line.

</ul>
</ul>
<p>
For example, to match lines that start with "error":
</p>

<pre sh>
grep "^error" logfile.txt
</pre>

<div id="grep-Regular Expressions and Extended Patterns-Context Options"><h3 id="Context Options" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Context Options">Context Options</a></h3></div>

<p>
Sometimes you don’t only want the matching lines, but also some context before or after:
</p>
<ul>
<li>
<code>-A NUM</code>: After context Print NUM lines after each matching line.

</ul>
  
<pre sh>
grep -A 2 "error" logfile.txt
</pre>

<ul>
<li>
<code>-B NUM</code>: Before context Print NUM lines before each matching line.

</ul>
  
<pre sh>
grep -B 2 "error" logfile.txt
</pre>

<ul>
<li>
<code>-C NUM</code>: Context Print NUM lines before and after each matching line.

</ul>
  
<pre sh>
grep -C 2 "error" logfile.txt
</pre>

<div id="grep-Regular Expressions and Extended Patterns-Other Useful Options"><h3 id="Other Useful Options" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Other Useful Options">Other Useful Options</a></h3></div>

<ul>
<li>
<code>-e PATTERN</code>: Specify a pattern. Useful when the pattern begins with a hyphen or when you want multiple patterns.

</ul>
<p>
Example:
</p>

<pre sh>
grep -e "error" -e "warning" logfile.txt
</pre>

<ul>
<li>
<code>-f FILE</code>: Read patterns from a file (one per line). Example:

</ul>
  
<pre sh>
grep -f patterns.txt logfile.txt
</pre>

<ul>
<li>
<code>-q</code>: Quiet mode. No output is produced; grep exits with 0 if a match is found; 1 otherwise. This is useful in scripts.

</ul>
<p>
Example:
</p>

<pre sh>
grep -q "error" logfile.txt &amp;&amp; echo "Error found."
</pre>

<ul>
<li>
<code>--color=auto</code>: Highlights matching strings in color. Most modern versions of grep include this by default.

</ul>
<p>
Example:
</p>

<pre sh>
grep --color=auto "error" logfile.txt
</pre>

<ul>
<li>
<code>-s</code>: Suppress errors about nonexistent or unreadable files.

<li>
<code>-P</code>: Use Perl-compatible regular expressions (PCRE). This can allow even more advanced regex features.

</ul>
<p>
Example:
</p>

<pre sh>
grep -P "\berror\b" logfile.txt
</pre>

<div id="grep-Regular Expressions and Extended Patterns-Real-World Examples"><h3 id="Real-World Examples" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Real-World Examples">Real-World Examples</a></h3></div>

<p>
Search for a phrase in the current directory (recursively), ignoring case:
</p>

<pre sh>
grep -Ri "configuration error" .
</pre>

<p>
Display matching line numbers for a log file:
</p>

<pre sh>
grep -n "fatal" application.log
</pre>

<p>
List only the names of files (without printing the lines) that contain the string “T0DO”:
</p>

<pre sh>
grep -l "T0DO" *
</pre>

<p>
Search through multiple files and highlight matches in color:
</p>

<pre sh>
grep --color=auto -R "function" src/
</pre>

<p>
Print 3 lines of context before and after matches:
</p>

<pre sh>
grep -C 3 "exception" logfile.txt
</pre>

<p>
Using multiple patterns together (match "error" or "failure"):
</p>

<pre sh>
grep -E "error|failure" logfile.txt
</pre>

<p>
Using a pattern file:
</p>

<p>
If you have a file <code>patterns.txt</code> with one pattern per line:
</p>

<p>
{{sh
grep -f patterns.txt logfile.txt
}}}
</p>

<div id="grep-Regular Expressions and Extended Patterns-Tips and Tricks"><h3 id="Tips and Tricks" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Tips and Tricks">Tips and Tricks</a></h3></div>

<p>
Piping and Integration: grep is often used in combination with other commands. For example, to search for active processes containing “python”:
</p>

<pre sh>
ps aux | grep -i python
</pre>

<p>
Searching Compressed Files: While <code>grep</code> does not directly search compressed files, utilities like <code>zgrep</code> (or using uncompressing commands in a pipe) can provide similar functionality.
</p>

<p>
Performance Considerations: When searching large directories, consider limiting the search with specific file name patterns:
</p>

<pre sh>
find . -name "*.log" | xargs grep "error"
</pre>

<div id="grep-Regular Expressions and Extended Patterns-Conclusion"><h3 id="Conclusion" class="header"><a href="#grep-Regular Expressions and Extended Patterns-Conclusion">Conclusion</a></h3></div>

<p>
The <code>grep</code> utility is a powerful, versatile tool for searching through text. By combining its many options and the power of regular expressions, you can tailor your searches to exactly meet your needs. Whether you're debugging code, analyzing logs, or processing large batches of text files, mastering grep is an invaluable skill in your command-line toolkit.
</p>

<p>
<a href="unix_tools_index.html">Unix Tools</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
