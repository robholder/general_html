<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>nuke_issues_read_write_exr_values_differ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<div id="Context"><h3 id="Context" class="header"><a href="#Context">Context</a></h3></div>

<p>
PMount frames had to be limited to a <code>13.6</code> value per channel. Nuke had an expression based clamp to force this limit.
Reading the EXRs back into Nuke (or doing a DI Matte report) gave a max-value error of <code>13.60125</code>.
</p>

<p>
I tried:
<table>
<tr>
<td>
Limit
</td>
<td>
EXR Depth
</td>
<td>
Read
</td>
<td>
Comment
</td>
</tr>
<tr>
<td>
<span id="Context-13.6"></span><strong id="13.6">13.6</strong>
</td>
<td>
<span id="Context-36bit exr"></span><strong id="36bit exr">36bit exr</strong>
</td>
<td>
13.60000
</td>
<td>
Correct (no floating point error)
</td>
</tr>
<tr>
<td>
13.6
</td>
<td>
16bit exr
</td>
<td>
13.60156
</td>
<td>
Original error
</td>
</tr>
<tr>
<td>
13.598
</td>
<td>
16bit exr
</td>
<td>
13.60156
</td>
<td>
Same error as 13.6 limit
</td>
</tr>
<tr>
<td>
<span id="Context-13.597"></span><strong id="13.597">13.597</strong>
</td>
<td>
<span id="Context-16bit exr"></span><strong id="16bit exr">16bit exr</strong>
</td>
<td>
13.59375
</td>
<td>
Sub 13.6
</td>
</tr>
<tr>
<td>
13.595
</td>
<td>
16bit exr
</td>
<td>
13.59375
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
13.59
</td>
<td>
16bit exr
</td>
<td>
13.59375
</td>
<td>
&nbsp;
</td>
</tr>
</table>
</p>

<div id="Context-In Summary: Three possible solutions"><h4 id="In Summary: Three possible solutions" class="header"><a href="#Context-In Summary: Three possible solutions">In Summary: Three possible solutions</a></h4></div>

<ul>
<li>
<span id="Context-In Summary: Three possible solutions-Export 32 bit exrs"></span><strong id="Export 32 bit exrs">Export 32 bit exrs</strong>

<ul>
<li>
Not 100% guaranteed, but very solid.

</ul>
<li>
<span id="Context-In Summary: Three possible solutions-Build in lower limit to Nuke export"></span><strong id="Build in lower limit to Nuke export">Build in lower limit to Nuke export</strong>:

<ul>
<li>
Not guaranteed to always work (see experiment table above).

<li>
Limit will be lower by a tiny fraction as a result.

</ul>
<li>
<span id="Context-In Summary: Three possible solutions-Build Tolerance value into DI ingestion process"></span><strong id="Build Tolerance value into DI ingestion process">Build Tolerance value into DI ingestion process</strong>:

<ul>
<li>
Set error tolerance to 0.001 before warning.

<li>
Clamp acceptable tolerance on import to DI.

</ul>
</ul>
<div id="EXR Values Differ Between Read &amp; Write"><h1 id="EXR Values Differ Between Read &amp; Write" class="header"><a href="#EXR Values Differ Between Read &amp; Write">EXR Values Differ Between Read &amp; Write</a></h1></div>

<p>
If EXR values are not exactly the same after a read-write round trip, it is most likely due to half-float precision, the use of lossy compression, or color space conversions. For most visual purposes, these differences are imperceptible, but they are crucial to understand for high-precision data workflows. 
</p>

<div id="EXR Values Differ Between Read &amp; Write-Half-float (16-bit) precision loss"><h3 id="Half-float (16-bit) precision loss" class="header"><a href="#EXR Values Differ Between Read &amp; Write-Half-float (16-bit) precision loss">Half-float (16-bit) precision loss</a></h3></div>

<p>
This is the most common reason for a slight discrepancy in pixel values.
</p>
<ul>
<li>
<span id="EXR Values Differ Between Read &amp; Write-Half-float (16-bit) precision loss-Reduced precision"></span><strong id="Reduced precision">Reduced precision</strong>: 16-bit half-float format offers a huge dynamic range, but it uses fewer bits for precision compared to a 32-bit float. This means it can't represent every possible decimal value exactly.

<li>
<span id="EXR Values Differ Between Read &amp; Write-Half-float (16-bit) precision loss-Decreased precision in highlights"></span><strong id="Decreased precision in highlights">Decreased precision in highlights</strong>: The precision of a floating-point number is not uniform across its range. It decreases as the value gets brighter, meaning that very bright areas of an image will have fewer possible values and may lose a tiny bit of accuracy when written and re-read.

<li>
<span id="EXR Values Differ Between Read &amp; Write-Half-float (16-bit) precision loss-Example"></span><strong id="Example">Example</strong>: If a pixel's 32-bit value is 12.3456789, it might be rounded to 12.345 when stored as a 16-bit half-float, leading to a small difference on a round trip. 

</ul>
<div id="EXR Values Differ Between Read &amp; Write-Lossy compression"><h3 id="Lossy compression" class="header"><a href="#EXR Values Differ Between Read &amp; Write-Lossy compression">Lossy compression</a></h3></div>

<p>
While most EXR compression methods are lossless, some are not. If you use a lossy compression method, your values will change.
</p>
<ul>
<li>
<span id="EXR Values Differ Between Read &amp; Write-Lossy compression-Lossy options"></span><strong id="Lossy options">Lossy options</strong>: OpenEXR supports several lossy compression methods that sacrifice image data for smaller file sizes. These include:

<li>
<span id="EXR Values Differ Between Read &amp; Write-Lossy compression-DWAA and DWAB"></span><strong id="DWAA and DWAB">DWAA and DWAB</strong>: Very efficient, with an adjustable compression level. A higher level introduces more loss.

<li>
<span id="EXR Values Differ Between Read &amp; Write-Lossy compression-B44 and B44A"></span><strong id="B44 and B44A">B44 and B44A</strong>: Compress blocks of pixels, which causes loss of data and is only available for half-float images.

<li>
<span id="EXR Values Differ Between Read &amp; Write-Lossy compression-PXR24"></span><strong id="PXR24">PXR24</strong>: A lossy format that truncates 32-bit float data to 24 bits. 

</ul>
<div id="EXR Values Differ Between Read &amp; Write-Color space or software conversions"><h3 id="Color space or software conversions" class="header"><a href="#EXR Values Differ Between Read &amp; Write-Color space or software conversions">Color space or software conversions</a></h3></div>

<p>
Unexpected conversions during the read or write process can also alter data.
</p>
<ul>
<li>
<span id="EXR Values Differ Between Read &amp; Write-Color space or software conversions-Software interpretation"></span><strong id="Software interpretation">Software interpretation</strong>: Different software applications may interpret or handle EXR data differently, especially regarding color space conversions or metadata.

<li>
<span id="EXR Values Differ Between Read &amp; Write-Color space or software conversions-Internal conversions"></span><strong id="Internal conversions">Internal conversions</strong>: For example, an application might load a 16-bit EXR, perform some operations using 32-bit floating-point numbers, and then save it back to 16-bit. The internal calculations and subsequent rounding will likely introduce tiny differences. 

</ul>
<div id="EXR Values Differ Between Read &amp; Write-How to ensure identical values (if necessary)"><h3 id="How to ensure identical values (if necessary)" class="header"><a href="#EXR Values Differ Between Read &amp; Write-How to ensure identical values (if necessary)">How to ensure identical values (if necessary)</a></h3></div>

<p>
For applications that require absolute data integrity, like certain technical passes, take these steps:
</p>
<ul>
<li>
<span id="EXR Values Differ Between Read &amp; Write-How to ensure identical values (if necessary)-Use 32-bit (full) floats"></span><strong id="Use 32-bit (full) floats">Use 32-bit (full) floats</strong>: This data type offers much higher precision than 16-bit (half) floats and will prevent any loss of value due to rounding.

<li>
<span id="EXR Values Differ Between Read &amp; Write-How to ensure identical values (if necessary)-Use a lossless compression method"></span><strong id="Use a lossless compression method">Use a lossless compression method</strong>: When writing your EXR, choose a lossless option such as ZIP, ZIPS, PIZ, or RLE. These methods guarantee that the pixel data remains mathematically identical after compression and decompression.

<li>
<span id="EXR Values Differ Between Read &amp; Write-How to ensure identical values (if necessary)-Verify your software"></span><strong id="Verify your software">Verify your software</strong>: Check your image editing, compositing, or rendering software settings to ensure you are not using lossy compression or performing an unnecessary conversion to a different floating-point size during the read/write process. 

</ul>
<div id="Precision Limits"><h1 id="Precision Limits" class="header"><a href="#Precision Limits">Precision Limits</a></h1></div>

<div id="Precision Limits-exr values not exactly the same read write"><h2 id="exr values not exactly the same read write" class="header"><a href="#Precision Limits-exr values not exactly the same read write">exr values not exactly the same read write</a></h2></div>

<p>
Slight differences in EXR values after a read/write cycle are due to the precision limits of floating-point numbers, especially when using the 16-bit half-float format. While EXR is a high-quality format designed for high dynamic range (HDR) images, it cannot store the infinite range of real numbers perfectly. 
</p>

<div id="Precision Limits-exr values not exactly the same read write-Floating-point precision"><h4 id="Floating-point precision" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Floating-point precision">Floating-point precision</a></h4></div>

<p>
This issue is not a bug, but an inherent property of how computers store floating-point data. All floating-point systems, including the ones used by OpenEXR, must round real numbers to the nearest value that can be represented in binary. 
</p>

<ul>
<li>
<span id="Precision Limits-exr values not exactly the same read write-Floating-point precision-16-bit (half) float"></span><strong id="16-bit (half) float">16-bit (half) float</strong>: This format provides a wide dynamic range but with less precision than 32-bit floats. A 16-bit float uses a limited number of bits for the mantissa (significand) to store the value, which means not all decimal numbers can be represented exactly.

<li>
<span id="Precision Limits-exr values not exactly the same read write-Floating-point precision-32-bit (full) float"></span><strong id="32-bit (full) float">32-bit (full) float</strong>: The 32-bit format offers significantly greater precision. However, it is still subject to rounding errors for certain values, just on a much smaller scale. 

</ul>
<p>
The difference in precision between half and full floats is particularly pronounced at higher brightness levels. A 16-bit float becomes less precise as the value gets brighter, while a 32-bit float maintains its accuracy much longer. 
</p>

<div id="Precision Limits-exr values not exactly the same read write-Is this a problem?"><h4 id="Is this a problem?" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Is this a problem?">Is this a problem?</a></h4></div>

<p>
For most applications, the minuscule difference from a read/write cycle is not a concern.
</p>

<ul>
<li>
<span id="Precision Limits-exr values not exactly the same read write-Is this a problem?-Lossless compression"></span><strong id="Lossless compression">Lossless compression</strong>: OpenEXR's compression methods, which are mostly lossless, do not cause the data change. The difference occurs at the level of the floating-point representation itself, before compression.

<li>
<span id="Precision Limits-exr values not exactly the same read write-Is this a problem?-Practical effects"></span><strong id="Practical effects">Practical effects</strong>: The change is typically far too small to be visible in the image. It generally does not cause noticeable color banding or other artifacts. 

</ul>
<div id="Precision Limits-exr values not exactly the same read write-How to manage this"><h4 id="How to manage this" class="header"><a href="#Precision Limits-exr values not exactly the same read write-How to manage this">How to manage this</a></h4></div>

<p>
To minimize or eliminate precision differences, you can take a few steps:
</p>
<ul>
<li>
<span id="Precision Limits-exr values not exactly the same read write-How to manage this-Use 32-bit floats"></span><strong id="Use 32-bit floats">Use 32-bit floats</strong>: If absolute precision is critical for technical passes like motion vectors or normals, use 32-bit floats. This will increase file size but guarantee a higher degree of accuracy.

<li>
<span id="Precision Limits-exr values not exactly the same read write-How to manage this-Use a tolerance when comparing"></span><strong id="Use a tolerance when comparing">Use a tolerance when comparing</strong>: If you are programmatically comparing values from a re-written EXR file, you should not check for exact equality. Instead, check if the values are within a small acceptable range or tolerance level. 

</ul>
<p>
In summary, the floating-point number system is the reason for slight value changes, not a flaw in the EXR format itself. Choosing between 16-bit and 32-bit floats is a trade-off between file size and numerical precision.
</p>
 
<div id="Precision Limits-exr values not exactly the same read write-How can I export to EXR and guarantee that the EXR has a hard limit of 13.9 and not a read value of 13.900001?"><h4 id="How can I export to EXR and guarantee that the EXR has a hard limit of 13.9 and not a read value of 13.900001?" class="header"><a href="#Precision Limits-exr values not exactly the same read write-How can I export to EXR and guarantee that the EXR has a hard limit of 13.9 and not a read value of 13.900001?">How can I export to EXR and guarantee that the EXR has a hard limit of 13.9 and not a read value of 13.900001?</a></h4></div>

<p>
When using floating-point numbers like those in EXR, achieving a "hard limit" that is exactly <code>13.9</code> and not a tiny fraction more is impossible due to rounding errors.
</p>

<p>
Even after clamping, the binary representation of <code>13.9</code> may not be perfectly accurate, and different software can interpret that binary slightly differently. The tiny variations you see <code>13.900001</code> are a fundamental aspect of floating-point arithmetic.
</p>

<p>
To solve this, you must accept that absolute precision for a decimal value like <code>13.9</code> cannot be guaranteed and communicate with the digital intermediate (DI) process to define an acceptable tolerance.
</p>

<div id="Precision Limits-exr values not exactly the same read write-The technical issue explained"><h4 id="The technical issue explained" class="header"><a href="#Precision Limits-exr values not exactly the same read write-The technical issue explained">The technical issue explained</a></h4></div>

<p>
Your clamp node correctly performs a floating-point comparison, but it does so in memory with a high degree of precision (likely 32-bit float).
</p>

<p>
When Nuke's Write node saves this data, it's converted to the file's specified format (e.g., 16-bit half or 32-bit float).
</p>

<p>
This can introduce rounding.
</p>

<ul>
<li>
The number <code>13.9</code> cannot be perfectly represented by the base-2 system used for floating-point numbers. It is an approximation.

<li>
The clamped value in Nuke is a binary value very close to <code>13.9</code>.

<li>
When read by another application, that same binary value might be converted to a decimal string like <code>13.900001</code> because of its own floating-point logic, even though the underlying data is identical.

</ul>
<div id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow"><h3 id="Solutions for your workflow" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Solutions for your workflow">Solutions for your workflow</a></h3></div>

<ul>
<li>
<span id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Method 1"></span><strong id="Method 1">Method 1</strong>: The standard production workflow

<ul>
<li>
The most robust and standard solution is to define a small, acceptable range of tolerance with the DI team.

<li>
<span id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Define tolerance"></span><strong id="Define tolerance">Define tolerance</strong>: Consult with the DI vendor to establish a tolerance level for the maximum value. A tolerance of <code>+/- 0.0001</code> is often used for these checks.

<li>
DI process checks with tolerance: The DI process will check if a pixel value is is_less_than_or_equal_to (13.9 + tolerance), rather than a strict is_less_than_or_equal_to(13.9).

<li>
Validate your clamp: In your Nuke script, ensure you are clamping all required channels correctly. You can test for minor variations by using an Expression node to check for values over <code>13.9</code>.  A quick test expression for the red channel would be r&gt;13.9?1:0.

</ul>
<li>
<span id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Method 2"></span><strong id="Method 2">Method 2</strong>: Re-clamping at the DI stage If the DI process is unwilling to accept a tolerance, the cleanest solution is to have them clamp the values themselves as part of their ingest process.

<ul>
<li>
Export the EXR as is: Write the EXR using your existing clamp node setup.

<li>
DI performs final clamp: The DI studio will apply a final clamp to the images at <code>13.9</code> during their data preparation. This moves the final rounding event into their system and avoids the issue of cross-software interpretation.

<li>
Confirm the strategy: Clearly communicate this plan with the DI team beforehand to ensure they are set up for this workflow.

</ul>
<li>
<span id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Method 3"></span><strong id="Method 3">Method 3</strong>: Using a custom Nuke expression to force-round

</ul>
<p>
While generally not necessary, you could write a custom expression in Nuke to force a rounding down to a certain number of decimal places before the Write node. This is more of a workaround that may introduce other unwanted artifacts.
</p>
<ul>
<li>
Add an Expression node: Insert an Expression node immediately before your Write node.

<li>
Write the rounding expression: Use an expression to round the values down.

</ul>
<p>
For example, to truncate values after six decimal places:floor(r * 1000000) / 1000000
</p>


<ul>
<li>
Be cautious: This is not a foolproof solution and may introduce banding, as it forces data loss. The tiny fluctuations you are seeing are often imperceptible and are a side effect of ensuring the widest possible dynamic range.

</ul>
<div id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Final recommendation"><h4 id="Final recommendation" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Final recommendation">Final recommendation</a></h4></div>

<p>
For a professional pipeline, Method 1 (agreeing on a tolerance) or Method 2 (the DI team clamps on ingest) are the best approaches.
They acknowledge the reality of floating-point math while providing a robust and repeatable process.
In a high-end production, a minimal, non-perceptible difference like <code>13.900001</code> is almost never a problem, as long as it's not a hard-fail for the next stage.
</p>

<div id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Is there a number I could clamp to to ensure a read value of 13.9 or less? (Perhaps 13.89 or something?)"><h4 id="Is there a number I could clamp to to ensure a read value of 13.9 or less? (Perhaps 13.89 or something?)" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Is there a number I could clamp to to ensure a read value of 13.9 or less? (Perhaps 13.89 or something?)">Is there a number I could clamp to to ensure a read value of 13.9 or less? (Perhaps 13.89 or something?)</a></h4></div>

<p>
Unfortunately, clamping to a slightly lower value like 13.89 is not a reliable method to guarantee a read value of exactly 13.9 or less. Floating-point inaccuracies are not a fixed offset; they are a consequence of the binary representation, which means the rounding error is not consistent and can't be perfectly predicted by simply nudging the number.
</p>

<div id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Why clamping to 13.89 doesn't guarantee the result"><h4 id="Why clamping to 13.89 doesn't guarantee the result" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Solutions for your workflow-Why clamping to 13.89 doesn't guarantee the result">Why clamping to 13.89 doesn't guarantee the result</a></h4></div>

<ul>
<li>
Decimal to binary conversion: The decimal value <code>13.9</code> and a pre-adjusted value like <code>13.89</code> are both approximated in the binary floating-point system. Neither can be perfectly represented.

<li>
Rounding error variability: The rounding error is not a fixed number you can simply subtract. The amount of precision lost depends on the number's magnitude and the number of bits available. For half-float (16-bit) EXRs, precision decreases as values get brighter.

<li>
Cross-software interpretation: Even if you manage to clamp in Nuke in a way that your software interprets the result correctly, another application's floating-point math might interpret the same binary data differently, leading to the same problem.

</ul>
<div id="Precision Limits-exr values not exactly the same read write-Solutions for your workflow-The correct solutions for a professional workflow"><h4 id="The correct solutions for a professional workflow" class="header"><a href="#Precision Limits-exr values not exactly the same read write-Solutions for your workflow-The correct solutions for a professional workflow">The correct solutions for a professional workflow</a></h4></div>

<p>
Instead of trying to find a magic number, you should work with the inherent nature of floating-point math through these robust methods:
</p>
<ul>
<li>
Work with the DI facility to define a tolerance. This is the most reliable and standard solution for VFX pipelines.

<ul>
<li>
Agree on a tolerance: Ask the DI facility for the acceptable tolerance. For example, they might accept values up to <code>13.9001</code>.

<li>
They can apply a clamp on their end: The DI studio can implement their own pre-processing that applies a very strict final clamp to exactly <code>13.9</code> as part of their ingest process.

<li>
This is a cooperative effort: This issue affects anyone dealing with floating-point data across different applications. Communicating and agreeing on a standard handling procedure is the professional way to proceed.

</ul>
<li>
Use 32-bit float EXRs. If the file size is manageable and the DI facility supports it, rendering with 32-bit floats will significantly increase the precision. The rounding error will still exist but will be magnitudes smaller and less likely to cause issues with common clamping values.

<li>
Perform a secondary validation pass. In Nuke, you can create a test pass before the Write node to check for values that exceed your target with a small tolerance.

<ul>
<li>
Add an Expression node: Insert an Expression node before your Write node.

<li>
Set the expression: For the rgb channels, use r&gt;13.90001?1:0.

<li>
Inspect the result: If you see any white pixels, it indicates a value that has crossed your threshold. This helps you identify if the issue is with the rounding on write or with a calculation upstream of your clamp. 

</ul>
</ul>
<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
