<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_mount_projects_line_tracing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PMount</a>
</p>

<div id="Line Tracing"><h1 id="Line Tracing" class="header"><a href="#Line Tracing">Line Tracing</a></h1></div>

<table>
<tr>
<td>
Gemini Session
</td>
</tr>
</table>

<div id="QUESTION:"><h1 id="QUESTION:" class="header"><a href="#QUESTION:">QUESTION:</a></h1></div>

<ul>
<li>
I have black and white png images, and I want to autotrace (possibly with Inscape or with a command line alternative if available), then export the svg result as another rasterized png (using the traced paths to generate the image).

<li>
This will need to be done on Linux (Rocky) and MacOS (Terminal) if possible.

</ul>
<p>
A combined approach using a command-line autotracer (like potrace or vtracer) and a tool for rasterization (like ImageMagick or Inkscape) is the most robust way to handle this workflow on both Linux and macOS. This method offers more control and is more script-friendly than Inkscape's batch processing. 
</p>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick"><h2 id="Method 1: Using potrace and ImageMagick" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick">Method 1: Using potrace and ImageMagick</a></h2></div>

<p>
<code>potrace</code> is a popular open-source command-line tool designed for tracing pure black-and-white bitmap images. ImageMagick is an image processing utility that can convert image formats and rasterize SVGs. 
</p>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick-Installation"><h4 id="Installation" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick-Installation">Installation</a></h4></div>

<p>
You will need to install two command-line tools. These commands work on both Rocky Linux and macOS (with Homebrew). 
For Rocky Linux:
</p>

<pre sh>
sudo dnf install potrace ImageMagick
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
For macOS:
</p>

<pre sh>
brew install potrace imagemagick
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick-The combined command"><h3 id="The combined command" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick-The combined command">The combined command</a></h3></div>

<p>
This single line of code chains together all the necessary steps using a pipe |, which is efficient and avoids creating intermediate files.
</p>

<pre sh>
convert input.png pbm:- | potrace --svg - -o output.svg &amp;&amp; convert -density 600 output.svg output.png
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick-How it works"><h3 id="How it works" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick-How it works">How it works</a></h3></div>

<ul>
<li>
<code>convert input.png pbm:-</code>: ImageMagick reads your black-and-white input.png and converts it into a Portable Bitmap (.pbm) format. The :- redirects the output to standard output, making it available for the next command.

<li>
<code>|</code>: The pipe sends the <code>.pbm</code> data directly to <code>potrace</code>.

<li>
<code>potrace --svg - -o output.svg</code>: <code>potrace</code> reads the <code>.pbm</code> data from standard input (-), performs the trace, and outputs the resulting SVG to a new file called <code>output.svg</code>.

<li>
<code>&amp;&amp;</code>: This ensures the second command only runs if the first one succeeds.

<li>
<code>convert -density 600 output.svg output.png</code>: ImageMagick reads the new <code>output.svg</code> file and rasterizes it back to <code>output.png</code>. The <code>-density</code> flag sets the resolution for the output PNG. Use a higher value (e.g., 600) to ensure a high-quality, non-pixelated final image. 

</ul>
<div id="QUESTION:-Method 2: Using vtracer and ImageMagick"><h2 id="Method 2: Using vtracer and ImageMagick" class="header"><a href="#QUESTION:-Method 2: Using vtracer and ImageMagick">Method 2: Using vtracer and ImageMagick</a></h2></div>

<p>
<code>vtracer</code> is a newer, fast, and feature-rich vectorization tool, which can also be used as a command-line utility. 
</p>

<div id="QUESTION:-Method 2: Using vtracer and ImageMagick-Installation"><h4 id="Installation" class="header"><a href="#QUESTION:-Method 2: Using vtracer and ImageMagick-Installation">Installation</a></h4></div>

<p>
<code>vtracer</code> can be installed via pip on both Linux and macOS.
</p>

<p>
On both Rocky Linux and macOS:
</p>

<pre sh>
pip install vtracer
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
You will still need ImageMagick for the final rasterization step. 
</p>

<div id="QUESTION:-Method 2: Using vtracer and ImageMagick-The combined command"><h3 id="The combined command" class="header"><a href="#QUESTION:-Method 2: Using vtracer and ImageMagick-The combined command">The combined command</a></h3></div>

<p>
This command first runs vtracer and then convert to produce the final PNG. 
</p>

<pre sh>
vtracer --input input.png --output output.svg &amp;&amp; convert -density 600 output.svg output.png
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-Method 2: Using vtracer and ImageMagick-How it works"><h3 id="How it works" class="header"><a href="#QUESTION:-Method 2: Using vtracer and ImageMagick-How it works">How it works</a></h3></div>

<ul>
<li>
<code>vtracer --input input.png --output output.svg</code>: vtracer reads your input PNG and produces the SVG output directly.

<li>
<code>&amp;&amp;</code>: Chains the two commands together.

<li>
<code>convert -density 600 output.svg output.png</code>: As with the <code>potrace</code> method, <code>ImageMagick</code> rasterizes the SVG to the final PNG at a high resolution. 

</ul>
<div id="QUESTION:-How to choose your method"><h2 id="How to choose your method" class="header"><a href="#QUESTION:-How to choose your method">How to choose your method</a></h2></div>

<ul>
<li>
For maximum compatibility and stability, use the <code>potrace</code> and <code>ImageMagick</code> approach. Both tools are mature, widely available, and perform this exact task efficiently.

<li>
For slightly better tracing results and speed, particularly on lower-resolution inputs, <code>vtracer</code> may offer an advantage. It is a more modern tool, but <code>potrace</code> is a well-established and reliable standard.

</ul>
<div id="QUESTION:"><h1 id="QUESTION:" class="header"><a href="#QUESTION:">QUESTION:</a></h1></div>

<p>
Would <code>potrace</code> or <code>vtracer</code> produce line quality similar to Inkscape's auto trace tool?
</p>

<div id="QUESTION:-ANSWER:"><h2 id="ANSWER:" class="header"><a href="#QUESTION:-ANSWER:">ANSWER:</a></h2></div>

<p>
The line quality from Potrace, vtracer, and Inkscape's built-in tool will be similar because Inkscape's "Trace Bitmap" feature uses a version of the Potrace algorithm for tracing. However, the exact output can vary due to differences in algorithm versions, default settings, and post-processing. 
</p>

<p>
Here is a comparison of what you can expect from each tool.
</p>

<div id="QUESTION:-ANSWER:-Potrace"><h3 id="Potrace" class="header"><a href="#QUESTION:-ANSWER:-Potrace">Potrace</a></h3></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-Potrace-Engine for Inkscape"></span><strong id="Engine for Inkscape">Engine for Inkscape</strong>: As the core engine for Inkscape's single-scan tracing, Potrace is the standard to which the other tools are compared.

</ul>
<div id="QUESTION:-ANSWER:-Potrace-Strengths:"><h4 id="Strengths:" class="header"><a href="#QUESTION:-ANSWER:-Potrace-Strengths:">Strengths:</a></h4></div>

<ul>
<li>
Excellent for pure black-and-white line art. It produces smooth, clean paths for contours and is very stable and reliable.

</ul>
<div id="QUESTION:-ANSWER:-Potrace-Line quality:"><h4 id="Line quality:" class="header"><a href="#QUESTION:-ANSWER:-Potrace-Line quality:">Line quality:</a></h4></div>

<ul>
<li>
The output from Potrace will closely match Inkscape's "Brightness Cutoff" or "Edge Detection" single-scan modes, especially for simpler black-and-white images.

</ul>
<div id="QUESTION:-ANSWER:-Potrace-Limitations:"><h4 id="Limitations:" class="header"><a href="#QUESTION:-ANSWER:-Potrace-Limitations:">Limitations:</a></h4></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-Potrace-Limitations:-No centerline tracing"></span><strong id="No centerline tracing">No centerline tracing</strong>: Potrace traces the outline of a stroke, not the center. For tracing thin, wispy lines, this may produce two very close, parallel paths instead of a single one.

<li>
<span id="QUESTION:-ANSWER:-Potrace-Limitations:-Requires pre-processing"></span><strong id="Requires pre-processing">Requires pre-processing</strong>: Potrace is designed for strictly black-and-white (binarized) images. You must pre-process your PNG to a binarized format (like PBM) first. 

</ul>
<div id="QUESTION:-ANSWER:-vtracer"><h3 id="vtracer" class="header"><a href="#QUESTION:-ANSWER:-vtracer">vtracer</a></h3></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-vtracer-Modern alternative"></span><strong id="Modern alternative">Modern alternative</strong>: vtracer is a more modern vectorization tool that is often compared to commercial products like Adobe Illustrator's Image Trace.

</ul>
<div id="QUESTION:-ANSWER:-vtracer-Strengths:"><h4 id="Strengths:" class="header"><a href="#QUESTION:-ANSWER:-vtracer-Strengths:">Strengths:</a></h4></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-vtracer-Strengths:-High-fidelity tracing"></span><strong id="High-fidelity tracing">High-fidelity tracing</strong>: vtracer was designed for high-resolution scans and can trace details that might be lost by other tools.

<li>
<span id="QUESTION:-ANSWER:-vtracer-Strengths:-Efficient algorithm"></span><strong id="Efficient algorithm">Efficient algorithm</strong>: It uses a different fitting algorithm than Potrace that can be much faster for complex, high-resolution images.

<li>
<span id="QUESTION:-ANSWER:-vtracer-Strengths:-Built-in pre-processing"></span><strong id="Built-in pre-processing">Built-in pre-processing</strong>: It has a built-in image processing pipeline and can handle color images directly, though you are working with black and white.

</ul>
<div id="QUESTION:-ANSWER:-vtracer-Line quality:"><h4 id="Line quality:" class="header"><a href="#QUESTION:-ANSWER:-vtracer-Line quality:">Line quality:</a></h4></div>

<ul>
<li>
For your black-and-white images, vtracer may produce results that are either more detailed or slightly more simplified than Potrace, depending on its settings. The results are generally excellent.

</ul>
<div id="QUESTION:-ANSWER:-vtracer-Limitations:"><h4 id="Limitations:" class="header"><a href="#QUESTION:-ANSWER:-vtracer-Limitations:">Limitations:</a></h4></div>

<ul>
<li>
While very good, it may not perfectly match the specific output of Inkscape's built-in tool due to its different algorithm. 

</ul>
<div id="QUESTION:-Inkscape's Trace Bitmap (Potrace)"><h2 id="Inkscape's Trace Bitmap (Potrace)" class="header"><a href="#QUESTION:-Inkscape's Trace Bitmap (Potrace)">Inkscape's Trace Bitmap (Potrace)</a></h2></div>

<ul>
<li>
<span id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-User-friendly"></span><strong id="User-friendly">User-friendly</strong>: The main advantage is its interactive graphical interface, which allows you to see a "Live Preview" of the tracing and adjust settings like the brightness threshold.

<li>
<span id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-Hidden steps"></span><strong id="Hidden steps">Hidden steps</strong>: The GUI handles all the necessary pre-processing steps (like binarization for single scans), so you don't have to do it yourself.

<li>
<span id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-Limited CLI control"></span><strong id="Limited CLI control">Limited CLI control</strong>: While Inkscape can be run in batch mode, controlling the specific tracing parameters from the command line is difficult or impossible. This is why command-line tools like Potrace and vtracer are better for scripted, automated workflows. 

</ul>
<div id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-Which tool to choose?"><h3 id="Which tool to choose?" class="header"><a href="#QUESTION:-Inkscape's Trace Bitmap (Potrace)-Which tool to choose?">Which tool to choose?</a></h3></div>

<p>
Given your focus on black-and-white images and a command-line workflow:
</p>
<ul>
<li>
For maximum control and simplicity, use potrace. Since Inkscape uses Potrace, you can be sure the underlying logic is nearly identical. You'll just need to manage the pre-processing step with a tool like ImageMagick. This is a very robust and proven workflow.

<li>
For a potentially more refined and efficient result, use vtracer. If you find Potrace's line quality or speed lacking for your specific images, vtracer is an excellent modern alternative that combines the pre-processing and tracing into a single step.

</ul>
<div id="QUESTION:"><h1 id="QUESTION:" class="header"><a href="#QUESTION:">QUESTION:</a></h1></div>

<p>
If vtracer is installed on the system, can a more robust Python script be written to batch process directories of files? (With parameter setting facilities too?)
</p>

<div id="QUESTION:-ANSWER:"><h2 id="ANSWER:" class="header"><a href="#QUESTION:-ANSWER:">ANSWER:</a></h2></div>

<p>
Yes, a robust Python script can be written to batch process directories of files using vtracer, with command-line arguments to control the tracing parameters. The script will use Python's built-in modules for file system navigation (os), running external commands (subprocess), and parsing command-line parameters (argparse). 
</p>

<div id="QUESTION:-ANSWER:-The complete Python script"><h4 id="The complete Python script" class="header"><a href="#QUESTION:-ANSWER:-The complete Python script">The complete Python script</a></h4></div>

<p>
This script will:
</p>
<ul>
<li>
Use os.walk() to recursively find all .png images in a directory.

<li>
Allow customization of vtracer and convert parameters via command-line arguments.

<li>
Output the new PNG files into a specified output directory, mirroring the input directory structure.

<li>
Print progress to the console. 

</ul>
<p>
Note: You must have both vtracer and ImageMagick installed on your system for this script to work.
</p>

<p>
File: batch_tracer.py
</p>
<pre python>
import os
import subprocess
import argparse
from pathlib import Path

def trace_and_rasterize(input_file, output_svg, output_png, vtracer_args, imagemagick_density):
    """Traces a PNG to SVG with vtracer and then rasterizes the SVG to a new PNG."""
    try:
        # Step 1: Run vtracer to convert PNG to SVG
        print(f"Tracing '{input_file}' to SVG...")
        vtracer_command = [
            "vtracer",
            "--input", str(input_file),
            "--output", str(output_svg),
            "--colormode", "bw" # Ensure binary color mode for black and white
        ]
        # Add any additional vtracer arguments from the user
        vtracer_command.extend(vtracer_args)
        
        subprocess.run(vtracer_command, check=True, capture_output=True, text=True)
        
        # Step 2: Run ImageMagick to convert SVG back to a high-res PNG
        print(f"Rasterizing '{output_svg}' to PNG...")
        imagemagick_command = [
            "convert",
            "-density", str(imagemagick_density),
            str(output_svg),
            str(output_png)
        ]
        subprocess.run(imagemagick_command, check=True, capture_output=True, text=True)
        
        print(f"✅ Successfully processed '{input_file}' -&gt; '{output_png}'")
        
        # Clean up the intermediate SVG file
        os.remove(output_svg)
    
    except subprocess.CalledProcessError as e:
        print(f"❌ Error processing '{input_file}':")
        print(f"  Stdout: {e.stdout}")
        print(f"  Stderr: {e.stderr}")
    except FileNotFoundError:
        print("❌ Error: 'vtracer' or 'convert' command not found. Ensure they are installed and in your PATH.")
    except Exception as e:
        print(f"❌ An unexpected error occurred: {e}")

def main():
    """Main function to parse arguments and process all files in a directory."""
    parser = argparse.ArgumentParser(
        description="Batch process PNG images: trace to SVG with vtracer, then rasterize back to PNG."
    )
    parser.add_argument(
        "input_directory",
        help="Path to the directory containing input PNG files."
    )
    parser.add_argument(
        "output_directory",
        help="Path to the directory for output PNG files."
    )
    parser.add_argument(
        "--density",
        type=int,
        default=600,
        help="Resolution (in DPI) for rasterizing the SVG output. Higher values result in sharper images. (Default: 600)"
    )
    parser.add_argument(
        "--vtracer-args",
        nargs=argparse.REMAINDER,
        default=[],
        help="Additional arguments for the 'vtracer' command. For example: --vtracer-args --mode spline"
    )
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_directory).resolve()
    output_dir = Path(args.output_directory).resolve()
    
    if not input_dir.is_dir():
        print(f"Error: Input directory '{input_dir}' does not exist.")
        return
        
    if not output_dir.exists():
        output_dir.mkdir(parents=True)
        print(f"Created output directory: '{output_dir}'")
    
    for root, _, files in os.walk(input_dir):
        for filename in files:
            if filename.endswith(".png"):
                input_file = Path(root) / filename
                
                # Construct the output file paths, preserving directory structure
                relative_path = input_file.relative_to(input_dir)
                output_svg = output_dir / relative_path.with_suffix(".svg")
                output_png = output_dir / relative_path
                
                # Ensure output subdirectory exists
                output_svg.parent.mkdir(parents=True, exist_ok=True)
                
                trace_and_rasterize(
                    input_file, 
                    output_svg, 
                    output_png, 
                    args.vtracer_args,
                    args.density
                )

if __name__ == "__main__":
    main()
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-ANSWER:-How to use the script"><h3 id="How to use the script" class="header"><a href="#QUESTION:-ANSWER:-How to use the script">How to use the script</a></h3></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-How to use the script-Save the file"></span><strong id="Save the file">Save the file</strong>: Save the code above as batch_tracer.py.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Make it executable"></span><strong id="Make it executable">Make it executable</strong>: On Linux/macOS, open a terminal and run chmod +x batch_tracer.py.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Run the script"></span><strong id="Run the script">Run the script</strong>:

<ul>
<li>
Basic usage: To process all PNGs in a directory called input_images and save the results to output_images, run:

</ul>
</ul>
  
<pre sh>
./batch_tracer.py input_images output_images
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
With vtracer arguments: To use the spline mode for potentially smoother lines, run:

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --vtracer-args --mode spline
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Specify density: To control the output resolution (e.g., 900 DPI), use the --density flag:

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --density 900
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Combine arguments: You can combine all arguments as needed.

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --density 900 --vtracer-args --mode spline --filter-speckle 8
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-ANSWER:-How to use the script-Key features of the script"><h4 id="Key features of the script" class="header"><a href="#QUESTION:-ANSWER:-How to use the script-Key features of the script">Key features of the script</a></h4></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Command-line Interface (argparse)"></span><strong id="Command-line Interface (argparse)">Command-line Interface (argparse)</strong>: The script has a user-friendly interface that explains its usage and options.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-File System Traversal (os.walk)"></span><strong id="File System Traversal (os.walk)">File System Traversal (os.walk)</strong>: It automatically finds all .png files in the input directory and all its subdirectories, making it easy to process large batches.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Directory Management (pathlib)"></span><strong id="Directory Management (pathlib)">Directory Management (pathlib)</strong>: It creates the output directory and subdirectories as needed, preserving the original file structure.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-External Command Execution (subprocess)"></span><strong id="External Command Execution (subprocess)">External Command Execution (subprocess)</strong>: It uses subprocess.run with check=True to ensure that any errors from vtracer or convert are caught and reported, making the process robust.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Error Handling"></span><strong id="Error Handling">Error Handling</strong>: It catches file not found errors for vtracer or convert and provides helpful messages.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Intermediate File Cleanup"></span><strong id="Intermediate File Cleanup">Intermediate File Cleanup</strong>: It automatically deletes the intermediate SVG files, keeping the output directory clean. 

</ul>
<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
If using Nuke on Linux and a companywide administration, is it possible to set up a local or virtual environment for Python, that Nuke can still 'see' or access by 'subprocess'?
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
Yes, Nuke on Linux can absolutely use a local or virtual Python environment through subprocess, which is a robust and common practice in studio pipelines. Since you are in a company-wide administration, this is an excellent approach because it avoids installing packages directly into Nuke's core environment, which could cause instability or version conflicts. 
</p>

<p>
Here is a step-by-step guide on how to set this up.
</p>

<div id="QUESTION-ANSWER-Step 1: Create the virtual environment"><h4 id="Step 1: Create the virtual environment" class="header"><a href="#QUESTION-ANSWER-Step 1: Create the virtual environment">Step 1: Create the virtual environment</a></h4></div>

<p>
The virtual environment should be created in a central, shared location that all artists on the network can access. The company's pipeline administrators will typically manage this.
</p>
<ul>
<li>
<span id="QUESTION-ANSWER-Step 1: Create the virtual environment-Choose a central location"></span><strong id="Choose a central location">Choose a central location</strong>: Pick a shared path on your company network for the virtual environment. Example: /mnt/projects/tools/vtracer_env.

<li>
<span id="QUESTION-ANSWER-Step 1: Create the virtual environment-Use venv or conda"></span><strong id="Use venv or conda">Use venv or conda</strong>: Create the virtual environment using a standard Python installation.

</ul>
  
<pre sh>
python3 -m venv /mnt/projects/tools/vtracer_env
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
<span id="QUESTION-ANSWER-Step 1: Create the virtual environment-Install dependencies"></span><strong id="Install dependencies">Install dependencies</strong>: Install vtracer and any other required Python packages into this environment.

</ul>
  
<pre sh>
# Activate the environment to use its pip
source /mnt/projects/tools/vtracer_env/bin/activate

# Install the packages
pip install vtracer pillow

# Deactivate the environment
deactivate
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Step 2: Write a wrapper script for the subprocess call"><h4 id="Step 2: Write a wrapper script for the subprocess call" class="header"><a href="#QUESTION-ANSWER-Step 2: Write a wrapper script for the subprocess call">Step 2: Write a wrapper script for the subprocess call</a></h4></div>

<p>
Instead of calling <code>vtracer</code> directly from Nuke, you will write a separate Python script that runs within your virtual environment. This script will perform the tracing, and the Nuke script will call this wrapper via subprocess. This is more robust than trying to activate the environment within the subprocess call itself. 
</p>

<p>
File: /mnt/projects/tools/vtracer_wrapper.py
</p>

<pre python>
import argparse
import vtracer
import os

def trace_with_vtracer(input_path, output_path, args):
    """Traces an image using vtracer with customizable arguments."""
    try:
        vtracer_options = {
            "input_path": input_path,
            "output_path": output_path,
            "colormode": "bw", # Enforce binary color mode
        }
        # Add any other arguments passed from the command line
        vtracer_options.update(args)

        vtracer.convert_image_to_svg_py(**vtracer_options)
        return 0 # Success
    except Exception as e:
        print(f"Error during tracing: {e}")
        return 1 # Error

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Wrapper script for vtracer to be called via subprocess."
    )
    parser.add_argument("--input", required=True, help="Input image file.")
    parser.add_argument("--output", required=True, help="Output SVG file.")
    parser.add_argument("--mode", default="spline", help="Tracing mode (e.g., spline, polygon).")
    parser.add_argument("--filter-speckle", type=int, default=4, help="Filter speckles smaller than this size.")
    # Add any other vtracer arguments you want to expose

    parsed_args, _ = parser.parse_known_args()
    
    exit_code = trace_with_vtracer(
        input_path=parsed_args.input,
        output_path=parsed_args.output,
        args=vars(parsed_args)
    )
    exit(exit_code)
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
This script acts as the clean interface between Nuke and the complex vtracer library.
</p>

<div id="QUESTION-ANSWER-Step 3: Call the wrapper script from Nuke via subprocess"><h4 id="Step 3: Call the wrapper script from Nuke via subprocess" class="header"><a href="#QUESTION-ANSWER-Step 3: Call the wrapper script from Nuke via subprocess">Step 3: Call the wrapper script from Nuke via subprocess</a></h4></div>

<p>
Now, the Nuke script simply needs to call the Python interpreter inside the virtual environment and pass the arguments to the wrapper script. 
</p>

<pre python>
import nuke
import subprocess
import os
import tempfile

def trace_from_nuke_with_venv(input_node):
    """
    Traces a black-and-white image from a Nuke node using a venv and a wrapper script.
    """
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    # Paths managed by pipeline administrators
    venv_python = "/mnt/projects/tools/vtracer_env/bin/python"
    wrapper_script = "/mnt/projects/tools/vtracer_wrapper.py"

    with tempfile.TemporaryDirectory() as temp_dir:
        input_png = os.path.join(temp_dir, "temp_input.png")
        output_svg = os.path.join(temp_dir, "temp_output.svg")
        final_png = os.path.join(temp_dir, "final_output.png")

        # Step 1: Render the Nuke node's output to a temporary PNG
        nuke.render(input_node, filename=input_png)
        
        # Step 2: Call the wrapper script via subprocess
        try:
            print(f"Tracing '{input_png}' using venv...")
            subprocess.run(
                [venv_python, wrapper_script, "--input", input_png, "--output", output_svg, "--mode", "spline"],
                check=True,
                capture_output=True,
                text=True
            )
            
            # Step 3: Rasterize the SVG using ImageMagick (assuming it's in the system PATH)
            print(f"Rasterizing '{output_svg}'...")
            subprocess.run(["convert", "-density", "600", output_svg, final_png], check=True)
            
            # Step 4: Create a new Read node in Nuke with the final PNG
            result_node = nuke.createNode("Read")
            result_node["file"].setValue(final_png)
            result_node["label"].setValue("VTraced (Venv)")
            
            print("Successfully created a new node with the traced image.")
        
        except subprocess.CalledProcessError as e:
            nuke.message(f"Error during subprocess call:\nStdout: {e.stdout}\nStderr: {e.stderr}")
        except FileNotFoundError:
            nuke.message(f"Error: '{venv_python}', '{wrapper_script}', or 'convert' not found.")
        except Exception as e:
            nuke.message(f"An unexpected error occurred: {e}")

# Example usage: trace_from_nuke_with_venv(nuke.selectedNode())
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Benefits of this approach"><h3 id="Benefits of this approach" class="header"><a href="#QUESTION-ANSWER-Benefits of this approach">Benefits of this approach</a></h3></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Isolation"></span><strong id="Isolation">Isolation</strong>: Your Nuke installation remains clean and unchanged. The virtual environment contains all the dependencies, preventing conflicts.

<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Version Control"></span><strong id="Version Control">Version Control</strong>: The pipeline team can control the exact versions of vtracer and other libraries used by Nuke scripts simply by managing the virtual environment.

<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Portability"></span><strong id="Portability">Portability</strong>: This setup is highly portable across different Linux workstations, as long as they can access the shared network path.

<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Robustness"></span><strong id="Robustness">Robustness</strong>: By using subprocess with full paths to the virtual environment's Python executable and a well-defined wrapper script, you eliminate the ambiguity that can arise from relative paths or inherited environment variables.

</ul>
<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
But what if I as a user on the company system would like to install the modules in a Virtual Environment that is NOT on the companywide system? Can I make Nuke see my local virtual setup?
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
Yes, as a user, you can install Python modules in a local virtual environment and make them accessible to Nuke. There are two robust methods for achieving this, both of which are independent of the company-wide system. 
</p>

<div id="QUESTION-ANSWER-Method 1: The recommended subprocess approach"><h3 id="Method 1: The recommended subprocess approach" class="header"><a href="#QUESTION-ANSWER-Method 1: The recommended subprocess approach">Method 1: The recommended subprocess approach</a></h3></div>

<p>
This is the safest and most reliable method. It involves creating a local virtual environment and then calling a script within that environment from Nuke using subprocess, just like the company-wide solution but with paths pointing to your local setup.
</p>

<div id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:"><h4 id="Advantages:" class="header"><a href="#QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:">Advantages:</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:-Safety"></span><strong id="Safety">Safety</strong>: It keeps your local environment completely isolated, preventing conflicts with Nuke's internal Python or any shared company tools.

<li>
<span id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:-Portability"></span><strong id="Portability">Portability</strong>: The script can work on any machine with access to your home directory, making it a reliable personal tool.

<li>
<span id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:-No Admin Rights Needed"></span><strong id="No Admin Rights Needed">No Admin Rights Needed</strong>: All installations are contained within your user space. 

</ul>
<div id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-How to set it up"><h4 id="How to set it up" class="header"><a href="#QUESTION-ANSWER-Method 1: The recommended subprocess approach-How to set it up">How to set it up</a></h4></div>

<p>
Create a local virtual environment: In your home directory (e.g., ~/nuke_tools/vtracer_env), create a new virtual environment.
</p>

<pre sh>
mkdir -p ~/nuke_tools
python3 -m venv ~/nuke_tools/vtracer_env
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
Install the packages: Activate your new environment and install vtracer.
</p>

<pre sh>
source ~/nuke_tools/vtracer_env/bin/activate
pip install vtracer pillow
deactivate
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Use the wrapper script: Reuse the same wrapper script from the previous answer, saved to your local tools directory (e.g., ~/nuke_tools/vtracer_wrapper.py).

<li>
Update the Nuke script: In your personal Nuke scripts (e.g., in ~/.nuke/menu.py or your Script Editor), update the paths to point to your local environment.

</ul>
  
<pre python>
import nuke
import subprocess
import os
import tempfile

def trace_local_venv(input_node):
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    # --- User-defined paths ---
    venv_python = os.path.expanduser("~/nuke_tools/vtracer_env/bin/python")
    wrapper_script = os.path.expanduser("~/nuke_tools/vtracer_wrapper.py")
    # --------------------------

    with tempfile.TemporaryDirectory() as temp_dir:
        input_png = os.path.join(temp_dir, "temp_input.png")
        output_svg = os.path.join(temp_dir, "temp_output.svg")
        final_png = os.path.join(temp_dir, "final_output.png")

        nuke.render(input_node, filename=input_png)

        try:
            subprocess.run(
                [venv_python, wrapper_script, "--input", input_png, "--output", output_svg],
                check=True, capture_output=True, text=True
            )
            subprocess.run(["convert", "-density", "600", output_svg, final_png], check=True)

            result_node = nuke.createNode("Read")
            result_node["file"].setValue(final_png)
            result_node["label"].setValue("VTraced (Local)")
            print("Tracing complete.")

        except subprocess.CalledProcessError as e:
            nuke.message(f"Error during tracing:\n{e.stderr}")
        except FileNotFoundError:
            nuke.message("Command not found. Check your paths and installations.")
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach"><h3 id="Method 2: The init.py direct import approach" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach">Method 2: The init.py direct import approach</a></h3></div>

<p>
This method makes the local virtual environment's packages directly importable within Nuke's Script Editor. It's less isolated than the subprocess method but more convenient if you need to use the libraries directly in your Nuke Python code. 
</p>

<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:"><h4 id="Advantages:" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:">Advantages:</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:-Convenience"></span><strong id="Convenience">Convenience</strong>: You can use import vtracer directly within your Nuke session.

<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:-Full Integration"></span><strong id="Full Integration">Full Integration</strong>: Gives you access to all library functionality without the overhead of external processes. 

</ul>
<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Drawbacks:"><h4 id="Drawbacks:" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-Drawbacks:">Drawbacks:</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Drawbacks:-Less Isolation"></span><strong id="Less Isolation">Less Isolation</strong>: It modifies Nuke's sys.path, which has a small risk of causing conflicts, although this is unlikely with a well-contained virtual environment. 

</ul>
<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up"><h4 id="How to set it up" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up">How to set it up</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Create the virtual environment"></span><strong id="Create the virtual environment">Create the virtual environment</strong>: Follow Step 1 from the subprocess method.

<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Add path in init.py"></span><strong id="Add path in init.py">Add path in init.py</strong>: Find or create your personal init.py file. This is typically located in ~/.nuke/.

<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Append site-packages to sys.path"></span><strong id="Append site-packages to sys.path">Append site-packages to sys.path</strong>: In your init.py, add the path to your virtual environment's site-packages folder.

</ul>
  
<pre python>
import sys
import os

# Resolve the path to your local virtual environment's site-packages
venv_path = os.path.expanduser("~/nuke_tools/vtracer_env/lib/python3.x/site-packages")

# Add it to the system path
if os.path.isdir(venv_path):
    sys.path.append(venv_path)
    print(f"Added local virtual environment to Nuke's Python path: {venv_path}")
else:
    print(f"Warning: Local virtual environment not found at {venv_path}")
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
_Note: Replace <code>python3.x</code> with your Python version (e.g., `python3.11)._
</p>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Run Nuke script"></span><strong id="Run Nuke script">Run Nuke script</strong>: Restart Nuke. You can now use import vtracer directly in the Script Editor or any of your Python files that Nuke executes. 

</ul>
<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Which method should you choose?"><h4 id="Which method should you choose?" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-Which method should you choose?">Which method should you choose?</a></h4></div>

<ul>
<li>
Use the <code>subprocess</code> approach (Method 1) for maximum stability. In a production environment with strict rules about software stability, this is the safest path. It ensures that any version changes or dependency conflicts in your local toolchain don't affect Nuke's core functionality.

<li>
Use the <code>init.py</code> import approach (Method 2) for direct scripting convenience. If you prioritize ease of development and want to interact with the libraries more fluidly in your Python scripts, this is a good option. The risks are minimal for well-isolated libraries like vtracer.

</ul>
<div id="Bonus"><h1 id="Bonus" class="header"><a href="#Bonus">Bonus</a></h1></div>

<div id="Bonus-The tempfile module"><h2 id="The tempfile module" class="header"><a href="#Bonus-The tempfile module">The tempfile module</a></h2></div>

<p>
The <code>tempfile</code> part of the script above uses Python's built-in tempfile module to create a temporary directory. The key features of this code block are:
</p>
<ul>
<li>
<span id="Bonus-The tempfile module-Context Manager"></span><strong id="Context Manager">Context Manager</strong>: The with statement creates a context manager. This ensures that the code inside the with block has access to the temporary directory.

<li>
<span id="Bonus-The tempfile module-Automatic Cleanup"></span><strong id="Automatic Cleanup">Automatic Cleanup</strong>: When the program exits the with block (either successfully or due to an error), Python's tempfile.TemporaryDirectory() automatically deletes the temporary directory and all of its contents. This prevents the temporary files from being left on the system and saves you from having to manually clean them up.

<li>
<span id="Bonus-The tempfile module-Variable Assignment"></span><strong id="Variable Assignment">Variable Assignment</strong>: The as temp_dir: part assigns the path of the newly created temporary directory to the variable temp_dir.

<li>
<span id="Bonus-The tempfile module-Creating Paths"></span><strong id="Creating Paths">Creating Paths</strong>: The os.path.join() lines then use this temporary directory path to create full paths for the intermediate files that are needed during processing (input_png, output_svg, and final_png). 

</ul>
<p>
In summary, the code creates a secure, temporary workspace for the script to use. All intermediate files generated during the tracing and rasterization steps are stored here, and everything is automatically removed as soon as the process is complete.
</p>


<p>
<a href="pmount_index.html">PMount</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
