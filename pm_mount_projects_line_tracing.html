<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_mount_projects_line_tracing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PMount</a>
</p>

<div id="Line Tracing"><h1 id="Line Tracing" class="header"><a href="#Line Tracing">Line Tracing</a></h1></div>

<table>
<tr>
<td>
Gemini Session
</td>
</tr>
</table>

<div id="Line Tracing-QUESTION:"><h2 id="QUESTION:" class="header"><a href="#Line Tracing-QUESTION:">QUESTION:</a></h2></div>

<ul>
<li>
I have black and white png images, and I want to autotrace (possibly with Inscape or with a command line alternative if available), then export the svg result as another rasterized png (using the traced paths to generate the image).

<li>
This will need to be done on Linux (Rocky) and MacOS (Terminal) if possible.

</ul>
<p>
A combined approach using a command-line autotracer (like potrace or vtracer) and a tool for rasterization (like ImageMagick or Inkscape) is the most robust way to handle this workflow on both Linux and macOS. This method offers more control and is more script-friendly than Inkscape's batch processing. 
</p>

<div id="Line Tracing-Method 1: Using potrace and ImageMagick"><h2 id="Method 1: Using potrace and ImageMagick" class="header"><a href="#Line Tracing-Method 1: Using potrace and ImageMagick">Method 1: Using potrace and ImageMagick</a></h2></div>

<p>
<code>potrace</code> is a popular open-source command-line tool designed for tracing pure black-and-white bitmap images. ImageMagick is an image processing utility that can convert image formats and rasterize SVGs. 
</p>

<div id="Line Tracing-Method 1: Using potrace and ImageMagick-Installation"><h4 id="Installation" class="header"><a href="#Line Tracing-Method 1: Using potrace and ImageMagick-Installation">Installation</a></h4></div>

<p>
You will need to install two command-line tools. These commands work on both Rocky Linux and macOS (with Homebrew). 
For Rocky Linux:
</p>

<pre sh>
sudo dnf install potrace ImageMagick
</pre>
<p>
Use code with caution.
</p>

<p>
For macOS:
</p>

<pre sh>
brew install potrace imagemagick
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-Method 1: Using potrace and ImageMagick-The combined command"><h3 id="The combined command" class="header"><a href="#Line Tracing-Method 1: Using potrace and ImageMagick-The combined command">The combined command</a></h3></div>

<p>
This single line of code chains together all the necessary steps using a pipe |, which is efficient and avoids creating intermediate files.
</p>

<pre sh>
convert input.png pbm:- | potrace --svg - -o output.svg &amp;&amp; convert -density 600 output.svg output.png
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-Method 1: Using potrace and ImageMagick-How it works"><h3 id="How it works" class="header"><a href="#Line Tracing-Method 1: Using potrace and ImageMagick-How it works">How it works</a></h3></div>

<ul>
<li>
<code>convert input.png pbm:-</code>: ImageMagick reads your black-and-white input.png and converts it into a Portable Bitmap (.pbm) format. The :- redirects the output to standard output, making it available for the next command.

<li>
<code>|</code>: The pipe sends the <code>.pbm</code> data directly to <code>potrace</code>.

<li>
<code>potrace --svg - -o output.svg</code>: <code>potrace</code> reads the <code>.pbm</code> data from standard input (-), performs the trace, and outputs the resulting SVG to a new file called <code>output.svg</code>.

<li>
<code>&amp;&amp;</code>: This ensures the second command only runs if the first one succeeds.

<li>
<code>convert -density 600 output.svg output.png</code>: ImageMagick reads the new <code>output.svg</code> file and rasterizes it back to <code>output.png</code>. The <code>-density</code> flag sets the resolution for the output PNG. Use a higher value (e.g., 600) to ensure a high-quality, non-pixelated final image. 

</ul>
<div id="Line Tracing-Method 2: Using vtracer and ImageMagick"><h2 id="Method 2: Using vtracer and ImageMagick" class="header"><a href="#Line Tracing-Method 2: Using vtracer and ImageMagick">Method 2: Using vtracer and ImageMagick</a></h2></div>

<p>
<code>vtracer</code> is a newer, fast, and feature-rich vectorization tool, which can also be used as a command-line utility. 
</p>

<div id="Line Tracing-Method 2: Using vtracer and ImageMagick-Installation"><h4 id="Installation" class="header"><a href="#Line Tracing-Method 2: Using vtracer and ImageMagick-Installation">Installation</a></h4></div>

<p>
<code>vtracer</code> can be installed via pip on both Linux and macOS.
</p>

<p>
On both Rocky Linux and macOS:
</p>

<pre sh>
pip install vtracer
</pre>
<p>
Use code with caution.
</p>

<p>
You will still need ImageMagick for the final rasterization step. 
</p>

<div id="Line Tracing-Method 2: Using vtracer and ImageMagick-The combined command"><h3 id="The combined command" class="header"><a href="#Line Tracing-Method 2: Using vtracer and ImageMagick-The combined command">The combined command</a></h3></div>

<p>
This command first runs vtracer and then convert to produce the final PNG. 
</p>

<pre sh>
vtracer --input input.png --output output.svg &amp;&amp; convert -density 600 output.svg output.png
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-Method 2: Using vtracer and ImageMagick-How it works"><h3 id="How it works" class="header"><a href="#Line Tracing-Method 2: Using vtracer and ImageMagick-How it works">How it works</a></h3></div>

<ul>
<li>
<code>vtracer --input input.png --output output.svg</code>: vtracer reads your input PNG and produces the SVG output directly.

<li>
<code>&amp;&amp;</code>: Chains the two commands together.

<li>
<code>convert -density 600 output.svg output.png</code>: As with the <code>potrace</code> method, <code>ImageMagick</code> rasterizes the SVG to the final PNG at a high resolution. 

</ul>
<div id="Line Tracing-How to choose your method"><h2 id="How to choose your method" class="header"><a href="#Line Tracing-How to choose your method">How to choose your method</a></h2></div>

<ul>
<li>
For maximum compatibility and stability, use the <code>potrace</code> and <code>ImageMagick</code> approach. Both tools are mature, widely available, and perform this exact task efficiently.

<li>
For slightly better tracing results and speed, particularly on lower-resolution inputs, <code>vtracer</code> may offer an advantage. It is a more modern tool, but <code>potrace</code> is a well-established and reliable standard.

</ul>
<div id="Line Tracing-QUESTION:"><h2 id="QUESTION:" class="header"><a href="#Line Tracing-QUESTION:">QUESTION:</a></h2></div>

<p>
Would <code>potrace</code> or <code>vtracer</code> produce line quality similar to Inkscape's auto trace tool?
</p>

<div id="Line Tracing-ANSWER:"><h2 id="ANSWER:" class="header"><a href="#Line Tracing-ANSWER:">ANSWER:</a></h2></div>

<p>
The line quality from Potrace, vtracer, and Inkscape's built-in tool will be similar because Inkscape's "Trace Bitmap" feature uses a version of the Potrace algorithm for tracing. However, the exact output can vary due to differences in algorithm versions, default settings, and post-processing. 
</p>

<p>
Here is a comparison of what you can expect from each tool.
</p>

<div id="Line Tracing-ANSWER:-Potrace"><h3 id="Potrace" class="header"><a href="#Line Tracing-ANSWER:-Potrace">Potrace</a></h3></div>

<ul>
<li>
<span id="Line Tracing-ANSWER:-Potrace-Engine for Inkscape"></span><strong id="Engine for Inkscape">Engine for Inkscape</strong>: As the core engine for Inkscape's single-scan tracing, Potrace is the standard to which the other tools are compared.

</ul>
<div id="Line Tracing-ANSWER:-Potrace-Strengths:"><h4 id="Strengths:" class="header"><a href="#Line Tracing-ANSWER:-Potrace-Strengths:">Strengths:</a></h4></div>

<ul>
<li>
Excellent for pure black-and-white line art. It produces smooth, clean paths for contours and is very stable and reliable.

</ul>
<div id="Line Tracing-ANSWER:-Potrace-Line quality:"><h4 id="Line quality:" class="header"><a href="#Line Tracing-ANSWER:-Potrace-Line quality:">Line quality:</a></h4></div>

<ul>
<li>
The output from Potrace will closely match Inkscape's "Brightness Cutoff" or "Edge Detection" single-scan modes, especially for simpler black-and-white images.

</ul>
<div id="Line Tracing-ANSWER:-Potrace-Limitations:"><h4 id="Limitations:" class="header"><a href="#Line Tracing-ANSWER:-Potrace-Limitations:">Limitations:</a></h4></div>

<ul>
<li>
<span id="Line Tracing-ANSWER:-Potrace-Limitations:-No centerline tracing"></span><strong id="No centerline tracing">No centerline tracing</strong>: Potrace traces the outline of a stroke, not the center. For tracing thin, wispy lines, this may produce two very close, parallel paths instead of a single one.

<li>
<span id="Line Tracing-ANSWER:-Potrace-Limitations:-Requires pre-processing"></span><strong id="Requires pre-processing">Requires pre-processing</strong>: Potrace is designed for strictly black-and-white (binarized) images. You must pre-process your PNG to a binarized format (like PBM) first. 

</ul>
<div id="Line Tracing-ANSWER:-vtracer"><h3 id="vtracer" class="header"><a href="#Line Tracing-ANSWER:-vtracer">vtracer</a></h3></div>

<ul>
<li>
<span id="Line Tracing-ANSWER:-vtracer-Modern alternative"></span><strong id="Modern alternative">Modern alternative</strong>: vtracer is a more modern vectorization tool that is often compared to commercial products like Adobe Illustrator's Image Trace.

</ul>
<div id="Line Tracing-ANSWER:-vtracer-Strengths:"><h4 id="Strengths:" class="header"><a href="#Line Tracing-ANSWER:-vtracer-Strengths:">Strengths:</a></h4></div>

<ul>
<li>
<span id="Line Tracing-ANSWER:-vtracer-Strengths:-High-fidelity tracing"></span><strong id="High-fidelity tracing">High-fidelity tracing</strong>: vtracer was designed for high-resolution scans and can trace details that might be lost by other tools.

<li>
<span id="Line Tracing-ANSWER:-vtracer-Strengths:-Efficient algorithm"></span><strong id="Efficient algorithm">Efficient algorithm</strong>: It uses a different fitting algorithm than Potrace that can be much faster for complex, high-resolution images.

<li>
<span id="Line Tracing-ANSWER:-vtracer-Strengths:-Built-in pre-processing"></span><strong id="Built-in pre-processing">Built-in pre-processing</strong>: It has a built-in image processing pipeline and can handle color images directly, though you are working with black and white.

</ul>
<div id="Line Tracing-ANSWER:-vtracer-Line quality:"><h4 id="Line quality:" class="header"><a href="#Line Tracing-ANSWER:-vtracer-Line quality:">Line quality:</a></h4></div>

<ul>
<li>
For your black-and-white images, vtracer may produce results that are either more detailed or slightly more simplified than Potrace, depending on its settings. The results are generally excellent.

</ul>
<div id="Line Tracing-ANSWER:-vtracer-Limitations:"><h4 id="Limitations:" class="header"><a href="#Line Tracing-ANSWER:-vtracer-Limitations:">Limitations:</a></h4></div>

<ul>
<li>
While very good, it may not perfectly match the specific output of Inkscape's built-in tool due to its different algorithm. 

</ul>
<div id="Line Tracing-Inkscape's Trace Bitmap (Potrace)"><h2 id="Inkscape's Trace Bitmap (Potrace)" class="header"><a href="#Line Tracing-Inkscape's Trace Bitmap (Potrace)">Inkscape's Trace Bitmap (Potrace)</a></h2></div>

<ul>
<li>
<span id="Line Tracing-Inkscape's Trace Bitmap (Potrace)-User-friendly"></span><strong id="User-friendly">User-friendly</strong>: The main advantage is its interactive graphical interface, which allows you to see a "Live Preview" of the tracing and adjust settings like the brightness threshold.

<li>
<span id="Line Tracing-Inkscape's Trace Bitmap (Potrace)-Hidden steps"></span><strong id="Hidden steps">Hidden steps</strong>: The GUI handles all the necessary pre-processing steps (like binarization for single scans), so you don't have to do it yourself.

<li>
<span id="Line Tracing-Inkscape's Trace Bitmap (Potrace)-Limited CLI control"></span><strong id="Limited CLI control">Limited CLI control</strong>: While Inkscape can be run in batch mode, controlling the specific tracing parameters from the command line is difficult or impossible. This is why command-line tools like Potrace and vtracer are better for scripted, automated workflows. 

</ul>
<div id="Line Tracing-Inkscape's Trace Bitmap (Potrace)-Which tool to choose?"><h3 id="Which tool to choose?" class="header"><a href="#Line Tracing-Inkscape's Trace Bitmap (Potrace)-Which tool to choose?">Which tool to choose?</a></h3></div>

<p>
Given your focus on black-and-white images and a command-line workflow:
</p>
<ul>
<li>
For maximum control and simplicity, use potrace. Since Inkscape uses Potrace, you can be sure the underlying logic is nearly identical. You'll just need to manage the pre-processing step with a tool like ImageMagick. This is a very robust and proven workflow.

<li>
For a potentially more refined and efficient result, use vtracer. If you find Potrace's line quality or speed lacking for your specific images, vtracer is an excellent modern alternative that combines the pre-processing and tracing into a single step.

</ul>
<div id="Line Tracing-QUESTION:"><h2 id="QUESTION:" class="header"><a href="#Line Tracing-QUESTION:">QUESTION:</a></h2></div>

<p>
If vtracer is installed on the system, can a more robust Python script be written to batch process directories of files? (With parameter setting facilities too?)
</p>

<div id="Line Tracing-ANSWER:"><h2 id="ANSWER:" class="header"><a href="#Line Tracing-ANSWER:">ANSWER:</a></h2></div>

<p>
Yes, a robust Python script can be written to batch process directories of files using vtracer, with command-line arguments to control the tracing parameters. The script will use Python's built-in modules for file system navigation (os), running external commands (subprocess), and parsing command-line parameters (argparse). 
</p>

<div id="Line Tracing-ANSWER:-The complete Python script"><h4 id="The complete Python script" class="header"><a href="#Line Tracing-ANSWER:-The complete Python script">The complete Python script</a></h4></div>

<p>
This script will:
</p>
<ul>
<li>
Use os.walk() to recursively find all .png images in a directory.

<li>
Allow customization of vtracer and convert parameters via command-line arguments.

<li>
Output the new PNG files into a specified output directory, mirroring the input directory structure.

<li>
Print progress to the console. 

</ul>
<p>
Note: You must have both vtracer and ImageMagick installed on your system for this script to work.
</p>

<p>
File: batch_tracer.py
</p>
<pre python>
import os
import subprocess
import argparse
from pathlib import Path

def trace_and_rasterize(input_file, output_svg, output_png, vtracer_args, imagemagick_density):
    """Traces a PNG to SVG with vtracer and then rasterizes the SVG to a new PNG."""
    try:
        # Step 1: Run vtracer to convert PNG to SVG
        print(f"Tracing '{input_file}' to SVG...")
        vtracer_command = [
            "vtracer",
            "--input", str(input_file),
            "--output", str(output_svg),
            "--colormode", "bw" # Ensure binary color mode for black and white
        ]
        # Add any additional vtracer arguments from the user
        vtracer_command.extend(vtracer_args)
        
        subprocess.run(vtracer_command, check=True, capture_output=True, text=True)
        
        # Step 2: Run ImageMagick to convert SVG back to a high-res PNG
        print(f"Rasterizing '{output_svg}' to PNG...")
        imagemagick_command = [
            "convert",
            "-density", str(imagemagick_density),
            str(output_svg),
            str(output_png)
        ]
        subprocess.run(imagemagick_command, check=True, capture_output=True, text=True)
        
        print(f"✅ Successfully processed '{input_file}' -&gt; '{output_png}'")
        
        # Clean up the intermediate SVG file
        os.remove(output_svg)
    
    except subprocess.CalledProcessError as e:
        print(f"❌ Error processing '{input_file}':")
        print(f"  Stdout: {e.stdout}")
        print(f"  Stderr: {e.stderr}")
    except FileNotFoundError:
        print("❌ Error: 'vtracer' or 'convert' command not found. Ensure they are installed and in your PATH.")
    except Exception as e:
        print(f"❌ An unexpected error occurred: {e}")

def main():
    """Main function to parse arguments and process all files in a directory."""
    parser = argparse.ArgumentParser(
        description="Batch process PNG images: trace to SVG with vtracer, then rasterize back to PNG."
    )
    parser.add_argument(
        "input_directory",
        help="Path to the directory containing input PNG files."
    )
    parser.add_argument(
        "output_directory",
        help="Path to the directory for output PNG files."
    )
    parser.add_argument(
        "--density",
        type=int,
        default=600,
        help="Resolution (in DPI) for rasterizing the SVG output. Higher values result in sharper images. (Default: 600)"
    )
    parser.add_argument(
        "--vtracer-args",
        nargs=argparse.REMAINDER,
        default=[],
        help="Additional arguments for the 'vtracer' command. For example: --vtracer-args --mode spline"
    )
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_directory).resolve()
    output_dir = Path(args.output_directory).resolve()
    
    if not input_dir.is_dir():
        print(f"Error: Input directory '{input_dir}' does not exist.")
        return
        
    if not output_dir.exists():
        output_dir.mkdir(parents=True)
        print(f"Created output directory: '{output_dir}'")
    
    for root, _, files in os.walk(input_dir):
        for filename in files:
            if filename.endswith(".png"):
                input_file = Path(root) / filename
                
                # Construct the output file paths, preserving directory structure
                relative_path = input_file.relative_to(input_dir)
                output_svg = output_dir / relative_path.with_suffix(".svg")
                output_png = output_dir / relative_path
                
                # Ensure output subdirectory exists
                output_svg.parent.mkdir(parents=True, exist_ok=True)
                
                trace_and_rasterize(
                    input_file, 
                    output_svg, 
                    output_png, 
                    args.vtracer_args,
                    args.density
                )

if __name__ == "__main__":
    main()
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-ANSWER:-How to use the script"><h3 id="How to use the script" class="header"><a href="#Line Tracing-ANSWER:-How to use the script">How to use the script</a></h3></div>

<ul>
<li>
<span id="Line Tracing-ANSWER:-How to use the script-Save the file"></span><strong id="Save the file">Save the file</strong>: Save the code above as batch_tracer.py.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Make it executable"></span><strong id="Make it executable">Make it executable</strong>: On Linux/macOS, open a terminal and run chmod +x batch_tracer.py.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Run the script"></span><strong id="Run the script">Run the script</strong>:

<ul>
<li>
Basic usage: To process all PNGs in a directory called input_images and save the results to output_images, run:

</ul>
</ul>
  
<pre sh>
./batch_tracer.py input_images output_images
</pre>
<p>
Use code with caution.
</p>

<ul>
<li>
With vtracer arguments: To use the spline mode for potentially smoother lines, run:

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --vtracer-args --mode spline
</pre>
<p>
Use code with caution.
</p>

<ul>
<li>
Specify density: To control the output resolution (e.g., 900 DPI), use the --density flag:

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --density 900
</pre>
<p>
Use code with caution.
</p>

<ul>
<li>
Combine arguments: You can combine all arguments as needed.

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --density 900 --vtracer-args --mode spline --filter-speckle 8
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-ANSWER:-How to use the script-Key features of the script"><h4 id="Key features of the script" class="header"><a href="#Line Tracing-ANSWER:-How to use the script-Key features of the script">Key features of the script</a></h4></div>

<ul>
<li>
<span id="Line Tracing-ANSWER:-How to use the script-Key features of the script-Command-line Interface (argparse)"></span><strong id="Command-line Interface (argparse)">Command-line Interface (argparse)</strong>: The script has a user-friendly interface that explains its usage and options.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Key features of the script-File System Traversal (os.walk)"></span><strong id="File System Traversal (os.walk)">File System Traversal (os.walk)</strong>: It automatically finds all .png files in the input directory and all its subdirectories, making it easy to process large batches.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Key features of the script-Directory Management (pathlib)"></span><strong id="Directory Management (pathlib)">Directory Management (pathlib)</strong>: It creates the output directory and subdirectories as needed, preserving the original file structure.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Key features of the script-External Command Execution (subprocess)"></span><strong id="External Command Execution (subprocess)">External Command Execution (subprocess)</strong>: It uses subprocess.run with check=True to ensure that any errors from vtracer or convert are caught and reported, making the process robust.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Key features of the script-Error Handling"></span><strong id="Error Handling">Error Handling</strong>: It catches file not found errors for vtracer or convert and provides helpful messages.

<li>
<span id="Line Tracing-ANSWER:-How to use the script-Key features of the script-Intermediate File Cleanup"></span><strong id="Intermediate File Cleanup">Intermediate File Cleanup</strong>: It automatically deletes the intermediate SVG files, keeping the output directory clean. 

</ul>
<div id="Line Tracing-QUESTION"><h2 id="QUESTION" class="header"><a href="#Line Tracing-QUESTION">QUESTION</a></h2></div>

<p>
If using Nuke on Linux and a companywide administration, is it possible to set up a local or virtual environment for Python, that Nuke can still 'see' or access by 'subprocess'?
</p>

<div id="Line Tracing-ANSWER"><h2 id="ANSWER" class="header"><a href="#Line Tracing-ANSWER">ANSWER</a></h2></div>

<p>
Yes, Nuke on Linux can absolutely use a local or virtual Python environment through subprocess, which is a robust and common practice in studio pipelines. Since you are in a company-wide administration, this is an excellent approach because it avoids installing packages directly into Nuke's core environment, which could cause instability or version conflicts. 
</p>

<p>
Here is a step-by-step guide on how to set this up.
</p>

<div id="Line Tracing-ANSWER-Step 1: Create the virtual environment"><h4 id="Step 1: Create the virtual environment" class="header"><a href="#Line Tracing-ANSWER-Step 1: Create the virtual environment">Step 1: Create the virtual environment</a></h4></div>

<p>
The virtual environment should be created in a central, shared location that all artists on the network can access. The company's pipeline administrators will typically manage this.
</p>
<ul>
<li>
<span id="Line Tracing-ANSWER-Step 1: Create the virtual environment-Choose a central location"></span><strong id="Choose a central location">Choose a central location</strong>: Pick a shared path on your company network for the virtual environment. Example: /mnt/projects/tools/vtracer_env.

<li>
<span id="Line Tracing-ANSWER-Step 1: Create the virtual environment-Use venv or conda"></span><strong id="Use venv or conda">Use venv or conda</strong>: Create the virtual environment using a standard Python installation.

</ul>
  
<pre sh>
python3 -m venv /mnt/projects/tools/vtracer_env
</pre>
<p>
Use code with caution.
</p>

<ul>
<li>
<span id="Line Tracing-ANSWER-Step 1: Create the virtual environment-Install dependencies"></span><strong id="Install dependencies">Install dependencies</strong>: Install vtracer and any other required Python packages into this environment.

</ul>
  
<pre sh>
# Activate the environment to use its pip
source /mnt/projects/tools/vtracer_env/bin/activate

# Install the packages
pip install vtracer pillow

# Deactivate the environment
deactivate
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-ANSWER-Step 2: Write a wrapper script for the subprocess call"><h4 id="Step 2: Write a wrapper script for the subprocess call" class="header"><a href="#Line Tracing-ANSWER-Step 2: Write a wrapper script for the subprocess call">Step 2: Write a wrapper script for the subprocess call</a></h4></div>

<p>
Instead of calling <code>vtracer</code> directly from Nuke, you will write a separate Python script that runs within your virtual environment. This script will perform the tracing, and the Nuke script will call this wrapper via subprocess. This is more robust than trying to activate the environment within the subprocess call itself. 
</p>

<p>
File: /mnt/projects/tools/vtracer_wrapper.py
</p>

<pre python>
import argparse
import vtracer
import os

def trace_with_vtracer(input_path, output_path, args):
    """Traces an image using vtracer with customizable arguments."""
    try:
        vtracer_options = {
            "input_path": input_path,
            "output_path": output_path,
            "colormode": "bw", # Enforce binary color mode
        }
        # Add any other arguments passed from the command line
        vtracer_options.update(args)

        vtracer.convert_image_to_svg_py(**vtracer_options)
        return 0 # Success
    except Exception as e:
        print(f"Error during tracing: {e}")
        return 1 # Error

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Wrapper script for vtracer to be called via subprocess."
    )
    parser.add_argument("--input", required=True, help="Input image file.")
    parser.add_argument("--output", required=True, help="Output SVG file.")
    parser.add_argument("--mode", default="spline", help="Tracing mode (e.g., spline, polygon).")
    parser.add_argument("--filter-speckle", type=int, default=4, help="Filter speckles smaller than this size.")
    # Add any other vtracer arguments you want to expose

    parsed_args, _ = parser.parse_known_args()
    
    exit_code = trace_with_vtracer(
        input_path=parsed_args.input,
        output_path=parsed_args.output,
        args=vars(parsed_args)
    )
    exit(exit_code)
</pre>
<p>
Use code with caution.
</p>

<p>
This script acts as the clean interface between Nuke and the complex vtracer library.
</p>

<div id="Line Tracing-ANSWER-Step 3: Call the wrapper script from Nuke via subprocess"><h4 id="Step 3: Call the wrapper script from Nuke via subprocess" class="header"><a href="#Line Tracing-ANSWER-Step 3: Call the wrapper script from Nuke via subprocess">Step 3: Call the wrapper script from Nuke via subprocess</a></h4></div>

<p>
Now, the Nuke script simply needs to call the Python interpreter inside the virtual environment and pass the arguments to the wrapper script. 
</p>

<pre python>
import nuke
import subprocess
import os
import tempfile

def trace_from_nuke_with_venv(input_node):
    """
    Traces a black-and-white image from a Nuke node using a venv and a wrapper script.
    """
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    # Paths managed by pipeline administrators
    venv_python = "/mnt/projects/tools/vtracer_env/bin/python"
    wrapper_script = "/mnt/projects/tools/vtracer_wrapper.py"

    with tempfile.TemporaryDirectory() as temp_dir:
        input_png = os.path.join(temp_dir, "temp_input.png")
        output_svg = os.path.join(temp_dir, "temp_output.svg")
        final_png = os.path.join(temp_dir, "final_output.png")

        # Step 1: Render the Nuke node's output to a temporary PNG
        nuke.render(input_node, filename=input_png)
        
        # Step 2: Call the wrapper script via subprocess
        try:
            print(f"Tracing '{input_png}' using venv...")
            subprocess.run(
                [venv_python, wrapper_script, "--input", input_png, "--output", output_svg, "--mode", "spline"],
                check=True,
                capture_output=True,
                text=True
            )
            
            # Step 3: Rasterize the SVG using ImageMagick (assuming it's in the system PATH)
            print(f"Rasterizing '{output_svg}'...")
            subprocess.run(["convert", "-density", "600", output_svg, final_png], check=True)
            
            # Step 4: Create a new Read node in Nuke with the final PNG
            result_node = nuke.createNode("Read")
            result_node["file"].setValue(final_png)
            result_node["label"].setValue("VTraced (Venv)")
            
            print("Successfully created a new node with the traced image.")
        
        except subprocess.CalledProcessError as e:
            nuke.message(f"Error during subprocess call:\nStdout: {e.stdout}\nStderr: {e.stderr}")
        except FileNotFoundError:
            nuke.message(f"Error: '{venv_python}', '{wrapper_script}', or 'convert' not found.")
        except Exception as e:
            nuke.message(f"An unexpected error occurred: {e}")

# Example usage: trace_from_nuke_with_venv(nuke.selectedNode())
</pre>
<p>
Use code with caution.
</p>

<div id="Line Tracing-ANSWER-Benefits of this approach"><h3 id="Benefits of this approach" class="header"><a href="#Line Tracing-ANSWER-Benefits of this approach">Benefits of this approach</a></h3></div>

<ul>
<li>
<span id="Line Tracing-ANSWER-Benefits of this approach-Isolation"></span><strong id="Isolation">Isolation</strong>: Your Nuke installation remains clean and unchanged. The virtual environment contains all the dependencies, preventing conflicts.

<li>
<span id="Line Tracing-ANSWER-Benefits of this approach-Version Control"></span><strong id="Version Control">Version Control</strong>: The pipeline team can control the exact versions of vtracer and other libraries used by Nuke scripts simply by managing the virtual environment.

<li>
<span id="Line Tracing-ANSWER-Benefits of this approach-Portability"></span><strong id="Portability">Portability</strong>: This setup is highly portable across different Linux workstations, as long as they can access the shared network path.

<li>
<span id="Line Tracing-ANSWER-Benefits of this approach-Robustness"></span><strong id="Robustness">Robustness</strong>: By using subprocess with full paths to the virtual environment's Python executable and a well-defined wrapper script, you eliminate the ambiguity that can arise from relative paths or inherited environment variables.

</ul>
<p>
<a href="pmount_index.html">PMount</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
