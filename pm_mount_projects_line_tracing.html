<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_mount_projects_line_tracing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PMount</a>
</p>

<div id="Line Tracing"><h1 id="Line Tracing" class="header"><a href="#Line Tracing">Line Tracing</a></h1></div>

<table>
<tr>
<td>
Gemini Session
</td>
</tr>
</table>

<div id="QUESTION:"><h1 id="QUESTION:" class="header"><a href="#QUESTION:">QUESTION:</a></h1></div>

<ul>
<li>
I have black and white png images, and I want to autotrace (possibly with Inscape or with a command line alternative if available), then export the svg result as another rasterized png (using the traced paths to generate the image).

<li>
This will need to be done on Linux (Rocky) and MacOS (Terminal) if possible.

</ul>
<p>
A combined approach using a command-line autotracer (like potrace or vtracer) and a tool for rasterization (like ImageMagick or Inkscape) is the most robust way to handle this workflow on both Linux and macOS. This method offers more control and is more script-friendly than Inkscape's batch processing. 
</p>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick"><h2 id="Method 1: Using potrace and ImageMagick" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick">Method 1: Using potrace and ImageMagick</a></h2></div>
<ul>
<li>
<a href="https://potrace.sourceforge.net/#:~:text=Trademarks-,Description,See%20the%20mkbitmap%20examples%20page.">potrace page</a>

</ul>
<p>
<code>potrace</code> is a popular open-source command-line tool designed for tracing pure black-and-white bitmap images. ImageMagick is an image processing utility that can convert image formats and rasterize SVGs. 
</p>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick-Installation"><h4 id="Installation" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick-Installation">Installation</a></h4></div>

<p>
You will need to install two command-line tools. These commands work on both Rocky Linux and macOS (with Homebrew). 
For Rocky Linux:
</p>

<pre sh>
sudo dnf install potrace ImageMagick
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
For macOS:
</p>

<pre sh>
brew install potrace imagemagick
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick-The combined command"><h3 id="The combined command" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick-The combined command">The combined command</a></h3></div>

<p>
This single line of code chains together all the necessary steps using a pipe |, which is efficient and avoids creating intermediate files.
</p>

<pre sh>
convert input.png pbm:- | potrace --svg - -o output.svg &amp;&amp; convert -density 600 output.svg output.png
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-Method 1: Using potrace and ImageMagick-How it works"><h3 id="How it works" class="header"><a href="#QUESTION:-Method 1: Using potrace and ImageMagick-How it works">How it works</a></h3></div>

<ul>
<li>
<code>convert input.png pbm:-</code>: ImageMagick reads your black-and-white input.png and converts it into a Portable Bitmap (.pbm) format. The :- redirects the output to standard output, making it available for the next command.

<li>
<code>|</code>: The pipe sends the <code>.pbm</code> data directly to <code>potrace</code>.

<li>
<code>potrace --svg - -o output.svg</code>: <code>potrace</code> reads the <code>.pbm</code> data from standard input (-), performs the trace, and outputs the resulting SVG to a new file called <code>output.svg</code>.

<li>
<code>&amp;&amp;</code>: This ensures the second command only runs if the first one succeeds.

<li>
<code>convert -density 600 output.svg output.png</code>: ImageMagick reads the new <code>output.svg</code> file and rasterizes it back to <code>output.png</code>. The <code>-density</code> flag sets the resolution for the output PNG. Use a higher value (e.g., 600) to ensure a high-quality, non-pixelated final image. 

</ul>
<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
What are the possible configurations (arguments) for potrace? I there an online resource describing the options?
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
For potrace, the available configurations and arguments are primarily managed through command-line flags. As it's a command-line utility, the best online resources are its manual pages and the official project website. 
</p>

<div id="QUESTION-ANSWER-Online resource"><h4 id="Online resource" class="header"><a href="#QUESTION-ANSWER-Online resource">Online resource</a></h4></div>

<p>
The definitive online resource for potrace's options is the manual page on the official Potrace website:
Potrace Manual Page: <a href="https://potrace.sourceforge.net/potrace.1.html">https://potrace.sourceforge.net/potrace.1.html</a> 
</p>

<div id="QUESTION-ANSWER-Key potrace arguments"><h4 id="Key potrace arguments" class="header"><a href="#QUESTION-ANSWER-Key potrace arguments">Key potrace arguments</a></h4></div>

<p>
Here are some of the most relevant algorithm and control options for producing cleaner, higher-quality SVG output, especially when called from a script. 
</p>

<div id="QUESTION-ANSWER-Output format"><h3 id="Output format" class="header"><a href="#QUESTION-ANSWER-Output format">Output format</a></h3></div>

<ul>
<li>
<code>-s</code>, <code>--svg</code>: Select the SVG (Scalable Vector Graphics) backend for output. This is essential for your use case.

<li>
<code>-o &lt;filename&gt;</code>, <code>--output &lt;filename&gt;</code>: Write all output to the specified file. By default, potrace creates one output file per input file. 

</ul>
<div id="QUESTION-ANSWER-Algorithm options"><h3 id="Algorithm options" class="header"><a href="#QUESTION-ANSWER-Algorithm options">Algorithm options</a></h3></div>

<ul>
<li>
<code>-t &lt;n&gt;</code>, <code>--turdsize &lt;n&gt;</code>: Suppresses speckles (single, small patches of color) of up to a certain size. The default is 2 pixels. A higher value will clean up more noise, but can also remove fine detail. A lower value preserves more detail.

<li>
<code>-a &lt;n&gt;</code>, <code>--alphamax &lt;n&gt;</code>: The corner threshold parameter.

<ul>
<li>
The default is 1.

<li>
A value closer to 0 produces sharper corners.

<li>
A value between 1 and 1.333 produces smoother curves.

<li>
A value greater than 1.333 forces all corners to be rounded.

</ul>
<li>
<code>-z &lt;policy&gt;</code>, <code>--turnpolicy &lt;policy&gt;</code>: Controls how potrace resolves ambiguities when decomposing a path. Possible policies include minority (default), majority, black, white, left, right, and random. This can affect the shape of internal loops and connections.

<li>
<code>-O &lt;n&gt;</code>, <code>--opttolerance &lt;n&gt;</code>: Curve optimization tolerance.

<ul>
<li>
The default is 0.2.

<li>
A smaller value produces curves that more closely match the original bitmap.

<li>
A higher value simplifies curves more aggressively.

<li>
-n, --longcurve: Turns off curve optimization, resulting in a more complex path with more points. 

</ul>
</ul>
<div id="QUESTION-ANSWER-Frontend options"><h3 id="Frontend options" class="header"><a href="#QUESTION-ANSWER-Frontend options">Frontend options</a></h3></div>

<ul>
<li>
<code>-k &lt;n&gt;</code>, <code>--blacklevel &lt;n&gt;</code>: Sets the black/white cutoff for input files.

<ul>
<li>
The default is 0.5.

<li>
A number between 0 and 1.

<li>
A higher number makes more pixels black. This is useful for adjusting the sensitivity of the trace.

</ul>
<li>
<code>-i</code>, <code>--invert</code>: Inverts the input bitmap before processing. 

</ul>
<div id="QUESTION-ANSWER-Frontend options-Example usage"><h4 id="Example usage" class="header"><a href="#QUESTION-ANSWER-Frontend options-Example usage">Example usage</a></h4></div>

<p>
To use these options in your terminal-based workflow, you might assemble a command like this:
</p>

<pre sh>
potrace --svg -o output.svg -t 4 -a 0.8 -O 0.1 input.pbm
</pre>
<p>
Use code with caution.
</p>

<ul>
<li>
<code>--svg</code>: Sets the output format to SVG.

<li>
<code>-o output.svg</code>: Specifies the output filename.

<li>
<code>-t 4</code>: Removes speckles up to 4 pixels in size.

<li>
<code>-a 0.8</code>: Produces slightly sharper corners than the default.

<li>
<code>-O 0.1</code>: Increases the curve optimization tolerance for more accurate curves.

<li>
<code>input.pbm</code>: The input PBM file.

</ul>
<p>
Example:
</p>

<pre sh>
magick input.png pbm:- | potrace --svg -o output_brew.svg &amp;&amp; magick -density 96 output_brew.svg output.png
</pre>

<div id="QUESTION-RGB"><h2 id="RGB" class="header"><a href="#QUESTION-RGB">RGB</a></h2></div>

<p>
The command above results in single channel grayscale PNGs. To produce RGB files, try the following.
</p>

<p>
By default, when ImageMagick processes a single-channel image (like a PBM or a black-and-white SVG from Potrace), it optimizes the output to a grayscale PNG, which is not what Nuke needs. 
</p>

<p>
To force ImageMagick to output a three-channel RGB PNG, you need to explicitly set the output color space and type.
</p>

<div id="QUESTION-RGB-The solution: Set the output color space and type"><h4 id="The solution: Set the output color space and type" class="header"><a href="#QUESTION-RGB-The solution: Set the output color space and type">The solution: Set the output color space and type</a></h4></div>

<p>
Add the -colorspace RGB and -type TrueColor options to your final convert command.
</p>

<p>
Modified command:
</p>
<pre sh>
convert input.png pbm:- | potrace --svg -o output.svg &amp;&amp; convert -density 96 -colorspace RGB -type TrueColor output.svg output.png
</pre>
<p>
Use code with caution.
</p>

<div id="QUESTION-RGB-Breakdown of the new options"><h4 id="Breakdown of the new options" class="header"><a href="#QUESTION-RGB-Breakdown of the new options">Breakdown of the new options</a></h4></div>

<ul>
<li>
<code>-colorspace RGB</code>: Tells ImageMagick to treat the color information as an RGB color space. Without this, it defaults to grayscale or sRGB based on the input data.

<li>
<code>-type TrueColor</code>: Forces the output image to be an uncompressed, 24-bit (8 bits per channel) RGB image. This prevents any optimizations to grayscale or indexed color that ImageMagick might try to apply. 

</ul>
<div id="QUESTION-RGB-Complete, robust command"><h4 id="Complete, robust command" class="header"><a href="#QUESTION-RGB-Complete, robust command">Complete, robust command</a></h4></div>

<p>
This is a shell script (zsh) to use the commandline above:
</p>
<pre sh>
<table>
<tr>
<td>
TESTED ON MAC OS
</td>
</tr>
</table>
#!/usr/bin/env zsh

# --- Configuration ---
INPUT_DIR="./2850_0025_orig"
OUTPUT_DIR="./2850_0025_done"
INPUT_PREFIX="orig_lines_2speed."
OUTPUT_PREFIX="new_lines_2speed."
INPUT_SUFFIX=".png"
# --- End Configuration ---

# Create the output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Ensure globbing works correctly for the pattern
setopt extended_glob

# Loop through all files that match the padded sequence pattern
for input_file in "$INPUT_DIR"/"$INPUT_PREFIX"[0-9]#"$INPUT_SUFFIX"; do
    # Check if the file actually exists
    if [[ -f "$input_file" ]]; then
        echo "Processing $input_file..."

        # 1. Extract the frame number with padding
        # Removes the prefix and suffix from the filename
        frame_number_padded=${input_file##*.}
        frame_number_padded=${frame_number_padded%%.*}

        # 2. Define output file paths
        output_svg="$OUTPUT_DIR/$OUTPUT_PREFIX$frame_number_padded.svg"
        output_png="$OUTPUT_DIR/$OUTPUT_PREFIX$frame_number_padded.png"

        # 3. Get original dimensions for accurate rasterization
        ORIGINAL_SIZE=$(identify -ping -format '%wx%h' "$input_file")
        if [[ -z "$ORIGINAL_SIZE" ]]; then
            echo "  Error: Could not get dimensions of $input_file. Skipping."
            continue
        fi

        # 4. Invert, trace, and rasterize the image
        convert "$input_file" -negate pbm:- | \
        potrace --svg - -o "$output_svg" &amp;&amp; \
        convert -size "$ORIGINAL_SIZE" -density 300 -background none \
                -colorspace RGB -type TrueColor "$output_svg" "$output_png"

        # 5. Clean up the temporary SVG file
        rm "$output_svg"

        echo "  Done. Saved to $output_png."
    fi
done

echo "Batch processing complete."
</pre>


<p>
This updated command ensures that even though your input is black and white, the final PNG output is a full RGB file, which is what Nuke requires for proper processing.
</p>

<div id="QUESTION-RGB-Inverting the Image"><h3 id="Inverting the Image" class="header"><a href="#QUESTION-RGB-Inverting the Image">Inverting the Image</a></h3></div>

<p>
You can easily invert the images within the command line by using ImageMagick's -negate option. The best way to do this is to add it to your first convert command, right before it pipes the image data to potrace. 
</p>

<div id="QUESTION-RGB-Inverting the Image-Modified command with negation"><h4 id="Modified command with negation" class="header"><a href="#QUESTION-RGB-Inverting the Image-Modified command with negation">Modified command with negation</a></h4></div>

<p>
Here is the updated version of your full command, including the inversion step.
</p>

<pre sh>
convert input.png -negate pbm:- | potrace --svg -o output.svg &amp;&amp; convert -density 96 -colorspace RGB -type TrueColor output.svg output.png
</pre>
<p>
Use code with caution.
</p>

<div id="QUESTION-RGB-Inverting the Image-Breakdown of the change"><h4 id="Breakdown of the change" class="header"><a href="#QUESTION-RGB-Inverting the Image-Breakdown of the change">Breakdown of the change</a></h4></div>

<ul>
<li>
<code>convert input.png -negate pbm:-</code>: The <code>-negate</code> option is placed between the input filename and the output format (<code>pbm:-</code>). ImageMagick applies its operations in sequence, so it will first read input.png, then invert the colors, and then output the PBM data to the pipe.

<li>
<code>pbm:-</code>: The standard output stream (<code>-</code>) is used to pipe the processed PBM data to the potrace command. 

</ul>
<div id="QUESTION-RGB-Inverting the Image-Complete, robust shell script"><h4 id="Complete, robust shell script" class="header"><a href="#QUESTION-RGB-Inverting the Image-Complete, robust shell script">Complete, robust shell script</a></h4></div>

<p>
For a production environment, use a script that retrieves the original image dimensions for accurate rasterization and handles temporary files.
</p>

<pre sh>
#!/usr/bin/env zsh

INPUT_PNG="input.png"
OUTPUT_SVG="output.svg"
OUTPUT_PNG="output.png"

# Get original dimensions for accurate rasterization
ORIGINAL_SIZE=$(identify -ping -format '%wx%h' "$INPUT_PNG")

# Invert the image, trace, then rasterize to a 24-bit RGB PNG
convert "$INPUT_PNG" -negate pbm:- | \
potrace --svg - -o "$OUTPUT_SVG" &amp;&amp; \
convert -density 96 -resize "$ORIGINAL_SIZE" -background none \
        -colorspace RGB -type TrueColor "$OUTPUT_SVG" "$OUTPUT_PNG"

# Clean up temporary SVG
rm "$OUTPUT_SVG"
</pre>

<p>
Use code with caution.
</p>

<div id="QUESTION-RGB-Resize Mismatch"><h3 id="Resize Mismatch" class="header"><a href="#QUESTION-RGB-Resize Mismatch">Resize Mismatch</a></h3></div>

<p>
The -resize option in ImageMagick can be problematic when you need exact dimensions, especially when converting from a vector format (SVG) to a raster format (PNG). ImageMagick often uses the SVG's internal dimensions as a base and then resizes the resulting raster image, which can lead to rounding errors or unexpected behavior. 
</p>

<div id="QUESTION-RGB-Resize Mismatch-Why -resize might be failing"><h4 id="Why -resize might be failing" class="header"><a href="#QUESTION-RGB-Resize Mismatch-Why -resize might be failing">Why -resize might be failing</a></h4></div>

<ul>
<li>
<span id="QUESTION-RGB-Resize Mismatch-Why -resize might be failing-Intermediate rasterization"></span><strong id="Intermediate rasterization">Intermediate rasterization</strong>: When ImageMagick converts an SVG, it first rasterizes it to an internal bitmap at a default density (often 72 DPI) before applying the -resize option. This can introduce inconsistencies.

<li>
<span id="QUESTION-RGB-Resize Mismatch-Why -resize might be failing-Order of operations"></span><strong id="Order of operations">Order of operations</strong>: The order of operations in ImageMagick matters. convert processes arguments in the order they appear, and a -density setting should be applied before the SVG file is read.

<li>
<span id="QUESTION-RGB-Resize Mismatch-Why -resize might be failing-Default viewBox"></span><strong id="Default viewBox">Default viewBox</strong>: If the SVG generated by potrace doesn't have an explicit viewBox attribute that defines its dimensions, ImageMagick might make a poor guess during the initial rasterization. 

</ul>
<div id="QUESTION-RGB-Resize Mismatch-The solution: Set -density and -size"><h4 id="The solution: Set -density and -size" class="header"><a href="#QUESTION-RGB-Resize Mismatch-The solution: Set -density and -size">The solution: Set -density and -size</a></h4></div>

<p>
The most reliable method is to first render the SVG at a high density and then resize it. Even better, you can tell ImageMagick to use the exact output dimensions you want before it even loads the SVG. 
</p>

<p>
Modified command:
</p>

<pre sh>
convert -size "$ORIGINAL_SIZE" -density 96 -colorspace RGB -type TrueColor output.svg output.png
</pre>
<p>
Use code with caution.
</p>

<ul>
<li>
<code>-size "$ORIGINAL_SIZE"</code>: This is the key. You're specifying the final output dimensions before ImageMagick loads the SVG. This forces the initial rasterization to happen on a canvas of the correct size.

<li>
<code>-density 96</code>: You can keep this, but the -size option will override the final output dimensions. A higher density (e.g., 300 or 600) can still produce a sharper image before the final resize, as seen in previous examples. 

</ul>
<div id="QUESTION-RGB-Resize Mismatch-Complete, robust shell script (best practice)"><h4 id="Complete, robust shell script (best practice)" class="header"><a href="#QUESTION-RGB-Resize Mismatch-Complete, robust shell script (best practice)">Complete, robust shell script (best practice)</a></h4></div>

<p>
Here is a full script that incorporates all the best practices: retrieving the dimensions, setting both -size and -density for quality, and ensuring the correct color space.
</p>

<pre sh>
#!/usr/bin/env zsh

INPUT_PNG="input.png"
OUTPUT_SVG="output.svg"
OUTPUT_PNG="output.png"

# Get original dimensions for accurate rasterization
ORIGINAL_SIZE=$(identify -ping -format '%wx%h' "$INPUT_PNG")
if [ -z "$ORIGINAL_SIZE" ]; then
    echo "Error: Could not get dimensions of input image."
    exit 1
fi

# Invert the image, trace, then rasterize to a 24-bit RGB PNG
convert "$INPUT_PNG" -negate pbm:- | \
potrace --svg - -o "$OUTPUT_SVG" &amp;&amp; \
convert -size "$ORIGINAL_SIZE" -density 300 -background none \
        -colorspace RGB -type TrueColor "$OUTPUT_SVG" "$OUTPUT_PNG"

# Clean up temporary SVG
rm "$OUTPUT_SVG"
</pre>
<p>
Use code with caution.
</p>

<p>
Note: The -density 300 here is for quality; it doesn't affect the final dimensions because the -size option will fix them. It tells ImageMagick to render the vector graphics at a higher resolution before resizing to the target canvas, resulting in a cleaner final image.
</p>

<div id="QUESTION-RGB-Resize Mismatch-Example with Nuke (Python)"><h4 id="Example with Nuke (Python)" class="header"><a href="#QUESTION-RGB-Resize Mismatch-Example with Nuke (Python)">Example with Nuke (Python)</a></h4></div>

<p>
Python script example for Nuke
</p>

<p>
This script provides a function that takes a Nuke read node, renders its output to a temporary file, calls potrace, and then creates a new read node with the resulting SVG.
</p>
<pre>
import nuke
import subprocess
import os
import tempfile

def trace_with_potrace(input_node):
    """
    Traces a black-and-white image from a Nuke node using potrace via subprocess.
    Requires potrace and ImageMagick to be installed system-wide.
    """
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    with tempfile.TemporaryDirectory() as temp_dir:
        # Define temporary file paths
        input_file_png = os.path.join(temp_dir, "input_temp.png")
        input_file_pbm = os.path.join(temp_dir, "input_temp.pbm")
        output_file_svg = os.path.join(temp_dir, "output_result.svg")
        
        # 1. Render the Nuke node's output to a temporary PNG file
        nuke.execute(input_node.name(), nuke.frame(), nuke.frame(), file=input_file_png)
        
        # 2. Convert the PNG to PBM format for potrace
        try:
            print("Converting PNG to PBM with ImageMagick...")
            subprocess.run(["convert", input_file_png, input_file_pbm], check=True)
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            nuke.message(f"Error with ImageMagick conversion: {e}\nIs 'convert' installed and in your PATH?")
            return

        # 3. Run potrace with custom arguments
        try:
            print("Tracing PBM to SVG with potrace...")
            subprocess.run(
                [
                    "potrace",
                    "-s",                    # Output as SVG
                    "-o", output_file_svg,   # Specify output file
                    "-t", "4",               # Filter out small speckles
                    "-a", "0.8",             # Adjust corner threshold
                    input_file_pbm,          # Input PBM file
                ],
                check=True
            )
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            nuke.message(f"Error with potrace: {e}\nIs 'potrace' installed and in your PATH?")
            return

        # 4. Create a new Read node for the resulting SVG
        if os.path.exists(output_file_svg):
            result_node = nuke.createNode("Read")
            result_node["file"].setValue(output_file_svg)
            result_node["label"].setValue("Potrace Result")
            print("Successfully created new Read node with traced SVG.")
        else:
            nuke.message("Potrace failed to produce an SVG file.")

# Example usage:
# Select a Read node in Nuke and run this function from the Script Editor
# trace_with_potrace(nuke.selectedNode())
</pre>
<p>
Use code with caution.
</p>

<div id="QUESTION-Method 2: Using vtracer and ImageMagick"><h2 id="Method 2: Using vtracer and ImageMagick" class="header"><a href="#QUESTION-Method 2: Using vtracer and ImageMagick">Method 2: Using vtracer and ImageMagick</a></h2></div>

<p>
<code>vtracer</code> is a newer, fast, and feature-rich vectorization tool, which can also be used as a command-line utility. 
</p>

<div id="QUESTION-Method 2: Using vtracer and ImageMagick-Installation"><h4 id="Installation" class="header"><a href="#QUESTION-Method 2: Using vtracer and ImageMagick-Installation">Installation</a></h4></div>

<p>
<code>vtracer</code> can be installed via pip on both Linux and macOS.
</p>

<p>
On both Rocky Linux and macOS:
</p>

<pre sh>
pip install vtracer
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
You will still need ImageMagick for the final rasterization step. 
</p>

<div id="QUESTION-Method 2: Using vtracer and ImageMagick-The combined command"><h3 id="The combined command" class="header"><a href="#QUESTION-Method 2: Using vtracer and ImageMagick-The combined command">The combined command</a></h3></div>

<p>
This command first runs vtracer and then convert to produce the final PNG. 
</p>

<pre sh>
vtracer --input input.png --output output.svg &amp;&amp; convert -density 600 output.svg output.png
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-Method 2: Using vtracer and ImageMagick-How it works"><h3 id="How it works" class="header"><a href="#QUESTION-Method 2: Using vtracer and ImageMagick-How it works">How it works</a></h3></div>

<ul>
<li>
<code>vtracer --input input.png --output output.svg</code>: vtracer reads your input PNG and produces the SVG output directly.

<li>
<code>&amp;&amp;</code>: Chains the two commands together.

<li>
<code>convert -density 600 output.svg output.png</code>: As with the <code>potrace</code> method, <code>ImageMagick</code> rasterizes the SVG to the final PNG at a high resolution. 

</ul>
<div id="QUESTION-How to choose your method"><h2 id="How to choose your method" class="header"><a href="#QUESTION-How to choose your method">How to choose your method</a></h2></div>

<ul>
<li>
For maximum compatibility and stability, use the <code>potrace</code> and <code>ImageMagick</code> approach. Both tools are mature, widely available, and perform this exact task efficiently.

<li>
For slightly better tracing results and speed, particularly on lower-resolution inputs, <code>vtracer</code> may offer an advantage. It is a more modern tool, but <code>potrace</code> is a well-established and reliable standard.

</ul>
<div id="QUESTION:"><h1 id="QUESTION:" class="header"><a href="#QUESTION:">QUESTION:</a></h1></div>

<p>
Would <code>potrace</code> or <code>vtracer</code> produce line quality similar to Inkscape's auto trace tool?
</p>

<div id="QUESTION:-ANSWER:"><h2 id="ANSWER:" class="header"><a href="#QUESTION:-ANSWER:">ANSWER:</a></h2></div>

<p>
The line quality from Potrace, vtracer, and Inkscape's built-in tool will be similar because Inkscape's "Trace Bitmap" feature uses a version of the Potrace algorithm for tracing. However, the exact output can vary due to differences in algorithm versions, default settings, and post-processing. 
</p>

<p>
Here is a comparison of what you can expect from each tool.
</p>

<div id="QUESTION:-ANSWER:-Potrace"><h3 id="Potrace" class="header"><a href="#QUESTION:-ANSWER:-Potrace">Potrace</a></h3></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-Potrace-Engine for Inkscape"></span><strong id="Engine for Inkscape">Engine for Inkscape</strong>: As the core engine for Inkscape's single-scan tracing, Potrace is the standard to which the other tools are compared.

</ul>
<div id="QUESTION:-ANSWER:-Potrace-Strengths:"><h4 id="Strengths:" class="header"><a href="#QUESTION:-ANSWER:-Potrace-Strengths:">Strengths:</a></h4></div>

<ul>
<li>
Excellent for pure black-and-white line art. It produces smooth, clean paths for contours and is very stable and reliable.

</ul>
<div id="QUESTION:-ANSWER:-Potrace-Line quality:"><h4 id="Line quality:" class="header"><a href="#QUESTION:-ANSWER:-Potrace-Line quality:">Line quality:</a></h4></div>

<ul>
<li>
The output from Potrace will closely match Inkscape's "Brightness Cutoff" or "Edge Detection" single-scan modes, especially for simpler black-and-white images.

</ul>
<div id="QUESTION:-ANSWER:-Potrace-Limitations:"><h4 id="Limitations:" class="header"><a href="#QUESTION:-ANSWER:-Potrace-Limitations:">Limitations:</a></h4></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-Potrace-Limitations:-No centerline tracing"></span><strong id="No centerline tracing">No centerline tracing</strong>: Potrace traces the outline of a stroke, not the center. For tracing thin, wispy lines, this may produce two very close, parallel paths instead of a single one.

<li>
<span id="QUESTION:-ANSWER:-Potrace-Limitations:-Requires pre-processing"></span><strong id="Requires pre-processing">Requires pre-processing</strong>: Potrace is designed for strictly black-and-white (binarized) images. You must pre-process your PNG to a binarized format (like PBM) first. 

</ul>
<div id="QUESTION:-ANSWER:-vtracer"><h3 id="vtracer" class="header"><a href="#QUESTION:-ANSWER:-vtracer">vtracer</a></h3></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-vtracer-Modern alternative"></span><strong id="Modern alternative">Modern alternative</strong>: vtracer is a more modern vectorization tool that is often compared to commercial products like Adobe Illustrator's Image Trace.

</ul>
<div id="QUESTION:-ANSWER:-vtracer-Strengths:"><h4 id="Strengths:" class="header"><a href="#QUESTION:-ANSWER:-vtracer-Strengths:">Strengths:</a></h4></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-vtracer-Strengths:-High-fidelity tracing"></span><strong id="High-fidelity tracing">High-fidelity tracing</strong>: vtracer was designed for high-resolution scans and can trace details that might be lost by other tools.

<li>
<span id="QUESTION:-ANSWER:-vtracer-Strengths:-Efficient algorithm"></span><strong id="Efficient algorithm">Efficient algorithm</strong>: It uses a different fitting algorithm than Potrace that can be much faster for complex, high-resolution images.

<li>
<span id="QUESTION:-ANSWER:-vtracer-Strengths:-Built-in pre-processing"></span><strong id="Built-in pre-processing">Built-in pre-processing</strong>: It has a built-in image processing pipeline and can handle color images directly, though you are working with black and white.

</ul>
<div id="QUESTION:-ANSWER:-vtracer-Line quality:"><h4 id="Line quality:" class="header"><a href="#QUESTION:-ANSWER:-vtracer-Line quality:">Line quality:</a></h4></div>

<ul>
<li>
For your black-and-white images, vtracer may produce results that are either more detailed or slightly more simplified than Potrace, depending on its settings. The results are generally excellent.

</ul>
<div id="QUESTION:-ANSWER:-vtracer-Limitations:"><h4 id="Limitations:" class="header"><a href="#QUESTION:-ANSWER:-vtracer-Limitations:">Limitations:</a></h4></div>

<ul>
<li>
While very good, it may not perfectly match the specific output of Inkscape's built-in tool due to its different algorithm. 

</ul>
<div id="QUESTION:-Inkscape's Trace Bitmap (Potrace)"><h2 id="Inkscape's Trace Bitmap (Potrace)" class="header"><a href="#QUESTION:-Inkscape's Trace Bitmap (Potrace)">Inkscape's Trace Bitmap (Potrace)</a></h2></div>

<ul>
<li>
<span id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-User-friendly"></span><strong id="User-friendly">User-friendly</strong>: The main advantage is its interactive graphical interface, which allows you to see a "Live Preview" of the tracing and adjust settings like the brightness threshold.

<li>
<span id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-Hidden steps"></span><strong id="Hidden steps">Hidden steps</strong>: The GUI handles all the necessary pre-processing steps (like binarization for single scans), so you don't have to do it yourself.

<li>
<span id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-Limited CLI control"></span><strong id="Limited CLI control">Limited CLI control</strong>: While Inkscape can be run in batch mode, controlling the specific tracing parameters from the command line is difficult or impossible. This is why command-line tools like Potrace and vtracer are better for scripted, automated workflows. 

</ul>
<div id="QUESTION:-Inkscape's Trace Bitmap (Potrace)-Which tool to choose?"><h3 id="Which tool to choose?" class="header"><a href="#QUESTION:-Inkscape's Trace Bitmap (Potrace)-Which tool to choose?">Which tool to choose?</a></h3></div>

<p>
Given your focus on black-and-white images and a command-line workflow:
</p>
<ul>
<li>
For maximum control and simplicity, use potrace. Since Inkscape uses Potrace, you can be sure the underlying logic is nearly identical. You'll just need to manage the pre-processing step with a tool like ImageMagick. This is a very robust and proven workflow.

<li>
For a potentially more refined and efficient result, use vtracer. If you find Potrace's line quality or speed lacking for your specific images, vtracer is an excellent modern alternative that combines the pre-processing and tracing into a single step.

</ul>
<div id="QUESTION:"><h1 id="QUESTION:" class="header"><a href="#QUESTION:">QUESTION:</a></h1></div>

<p>
If vtracer is installed on the system, can a more robust Python script be written to batch process directories of files? (With parameter setting facilities too?)
</p>

<div id="QUESTION:-ANSWER:"><h2 id="ANSWER:" class="header"><a href="#QUESTION:-ANSWER:">ANSWER:</a></h2></div>

<p>
Yes, a robust Python script can be written to batch process directories of files using vtracer, with command-line arguments to control the tracing parameters. The script will use Python's built-in modules for file system navigation (os), running external commands (subprocess), and parsing command-line parameters (argparse). 
</p>

<div id="QUESTION:-ANSWER:-The complete Python script"><h4 id="The complete Python script" class="header"><a href="#QUESTION:-ANSWER:-The complete Python script">The complete Python script</a></h4></div>

<p>
This script will:
</p>
<ul>
<li>
Use os.walk() to recursively find all .png images in a directory.

<li>
Allow customization of vtracer and convert parameters via command-line arguments.

<li>
Output the new PNG files into a specified output directory, mirroring the input directory structure.

<li>
Print progress to the console. 

</ul>
<p>
Note: You must have both vtracer and ImageMagick installed on your system for this script to work.
</p>

<p>
File: batch_tracer.py
</p>
<pre python>
import os
import subprocess
import argparse
from pathlib import Path

def trace_and_rasterize(input_file, output_svg, output_png, vtracer_args, imagemagick_density):
    """Traces a PNG to SVG with vtracer and then rasterizes the SVG to a new PNG."""
    try:
        # Step 1: Run vtracer to convert PNG to SVG
        print(f"Tracing '{input_file}' to SVG...")
        vtracer_command = [
            "vtracer",
            "--input", str(input_file),
            "--output", str(output_svg),
            "--colormode", "bw" # Ensure binary color mode for black and white
        ]
        # Add any additional vtracer arguments from the user
        vtracer_command.extend(vtracer_args)
        
        subprocess.run(vtracer_command, check=True, capture_output=True, text=True)
        
        # Step 2: Run ImageMagick to convert SVG back to a high-res PNG
        print(f"Rasterizing '{output_svg}' to PNG...")
        imagemagick_command = [
            "convert",
            "-density", str(imagemagick_density),
            str(output_svg),
            str(output_png)
        ]
        subprocess.run(imagemagick_command, check=True, capture_output=True, text=True)
        
        print(f"✅ Successfully processed '{input_file}' -&gt; '{output_png}'")
        
        # Clean up the intermediate SVG file
        os.remove(output_svg)
    
    except subprocess.CalledProcessError as e:
        print(f"❌ Error processing '{input_file}':")
        print(f"  Stdout: {e.stdout}")
        print(f"  Stderr: {e.stderr}")
    except FileNotFoundError:
        print("❌ Error: 'vtracer' or 'convert' command not found. Ensure they are installed and in your PATH.")
    except Exception as e:
        print(f"❌ An unexpected error occurred: {e}")

def main():
    """Main function to parse arguments and process all files in a directory."""
    parser = argparse.ArgumentParser(
        description="Batch process PNG images: trace to SVG with vtracer, then rasterize back to PNG."
    )
    parser.add_argument(
        "input_directory",
        help="Path to the directory containing input PNG files."
    )
    parser.add_argument(
        "output_directory",
        help="Path to the directory for output PNG files."
    )
    parser.add_argument(
        "--density",
        type=int,
        default=600,
        help="Resolution (in DPI) for rasterizing the SVG output. Higher values result in sharper images. (Default: 600)"
    )
    parser.add_argument(
        "--vtracer-args",
        nargs=argparse.REMAINDER,
        default=[],
        help="Additional arguments for the 'vtracer' command. For example: --vtracer-args --mode spline"
    )
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_directory).resolve()
    output_dir = Path(args.output_directory).resolve()
    
    if not input_dir.is_dir():
        print(f"Error: Input directory '{input_dir}' does not exist.")
        return
        
    if not output_dir.exists():
        output_dir.mkdir(parents=True)
        print(f"Created output directory: '{output_dir}'")
    
    for root, _, files in os.walk(input_dir):
        for filename in files:
            if filename.endswith(".png"):
                input_file = Path(root) / filename
                
                # Construct the output file paths, preserving directory structure
                relative_path = input_file.relative_to(input_dir)
                output_svg = output_dir / relative_path.with_suffix(".svg")
                output_png = output_dir / relative_path
                
                # Ensure output subdirectory exists
                output_svg.parent.mkdir(parents=True, exist_ok=True)
                
                trace_and_rasterize(
                    input_file, 
                    output_svg, 
                    output_png, 
                    args.vtracer_args,
                    args.density
                )

if __name__ == "__main__":
    main()
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-ANSWER:-How to use the script"><h3 id="How to use the script" class="header"><a href="#QUESTION:-ANSWER:-How to use the script">How to use the script</a></h3></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-How to use the script-Save the file"></span><strong id="Save the file">Save the file</strong>: Save the code above as batch_tracer.py.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Make it executable"></span><strong id="Make it executable">Make it executable</strong>: On Linux/macOS, open a terminal and run chmod +x batch_tracer.py.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Run the script"></span><strong id="Run the script">Run the script</strong>:

<ul>
<li>
Basic usage: To process all PNGs in a directory called input_images and save the results to output_images, run:

</ul>
</ul>
  
<pre sh>
./batch_tracer.py input_images output_images
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
With vtracer arguments: To use the spline mode for potentially smoother lines, run:

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --vtracer-args --mode spline
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Specify density: To control the output resolution (e.g., 900 DPI), use the --density flag:

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --density 900
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Combine arguments: You can combine all arguments as needed.

</ul>
  
<pre sh>
./batch_tracer.py input_images output_images --density 900 --vtracer-args --mode spline --filter-speckle 8
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION:-ANSWER:-How to use the script-Key features of the script"><h4 id="Key features of the script" class="header"><a href="#QUESTION:-ANSWER:-How to use the script-Key features of the script">Key features of the script</a></h4></div>

<ul>
<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Command-line Interface (argparse)"></span><strong id="Command-line Interface (argparse)">Command-line Interface (argparse)</strong>: The script has a user-friendly interface that explains its usage and options.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-File System Traversal (os.walk)"></span><strong id="File System Traversal (os.walk)">File System Traversal (os.walk)</strong>: It automatically finds all .png files in the input directory and all its subdirectories, making it easy to process large batches.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Directory Management (pathlib)"></span><strong id="Directory Management (pathlib)">Directory Management (pathlib)</strong>: It creates the output directory and subdirectories as needed, preserving the original file structure.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-External Command Execution (subprocess)"></span><strong id="External Command Execution (subprocess)">External Command Execution (subprocess)</strong>: It uses subprocess.run with check=True to ensure that any errors from vtracer or convert are caught and reported, making the process robust.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Error Handling"></span><strong id="Error Handling">Error Handling</strong>: It catches file not found errors for vtracer or convert and provides helpful messages.

<li>
<span id="QUESTION:-ANSWER:-How to use the script-Key features of the script-Intermediate File Cleanup"></span><strong id="Intermediate File Cleanup">Intermediate File Cleanup</strong>: It automatically deletes the intermediate SVG files, keeping the output directory clean. 

</ul>
<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
If using Nuke on Linux and a companywide administration, is it possible to set up a local or virtual environment for Python, that Nuke can still 'see' or access by 'subprocess'?
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
Yes, Nuke on Linux can absolutely use a local or virtual Python environment through subprocess, which is a robust and common practice in studio pipelines. Since you are in a company-wide administration, this is an excellent approach because it avoids installing packages directly into Nuke's core environment, which could cause instability or version conflicts. 
</p>

<p>
Here is a step-by-step guide on how to set this up.
</p>

<div id="QUESTION-ANSWER-Step 1: Create the virtual environment"><h4 id="Step 1: Create the virtual environment" class="header"><a href="#QUESTION-ANSWER-Step 1: Create the virtual environment">Step 1: Create the virtual environment</a></h4></div>

<p>
The virtual environment should be created in a central, shared location that all artists on the network can access. The company's pipeline administrators will typically manage this.
</p>
<ul>
<li>
<span id="QUESTION-ANSWER-Step 1: Create the virtual environment-Choose a central location"></span><strong id="Choose a central location">Choose a central location</strong>: Pick a shared path on your company network for the virtual environment. Example: /mnt/projects/tools/vtracer_env.

<li>
<span id="QUESTION-ANSWER-Step 1: Create the virtual environment-Use venv or conda"></span><strong id="Use venv or conda">Use venv or conda</strong>: Create the virtual environment using a standard Python installation.

</ul>
  
<pre sh>
python3 -m venv /mnt/projects/tools/vtracer_env
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
<span id="QUESTION-ANSWER-Step 1: Create the virtual environment-Install dependencies"></span><strong id="Install dependencies">Install dependencies</strong>: Install vtracer and any other required Python packages into this environment.

</ul>
  
<pre sh>
# Activate the environment to use its pip
source /mnt/projects/tools/vtracer_env/bin/activate

# Install the packages
pip install vtracer pillow

# Deactivate the environment
deactivate
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Step 2: Write a wrapper script for the subprocess call"><h4 id="Step 2: Write a wrapper script for the subprocess call" class="header"><a href="#QUESTION-ANSWER-Step 2: Write a wrapper script for the subprocess call">Step 2: Write a wrapper script for the subprocess call</a></h4></div>

<p>
Instead of calling <code>vtracer</code> directly from Nuke, you will write a separate Python script that runs within your virtual environment. This script will perform the tracing, and the Nuke script will call this wrapper via subprocess. This is more robust than trying to activate the environment within the subprocess call itself. 
</p>

<p>
File: /mnt/projects/tools/vtracer_wrapper.py
</p>

<pre python>
import argparse
import vtracer
import os

def trace_with_vtracer(input_path, output_path, args):
    """Traces an image using vtracer with customizable arguments."""
    try:
        vtracer_options = {
            "input_path": input_path,
            "output_path": output_path,
            "colormode": "bw", # Enforce binary color mode
        }
        # Add any other arguments passed from the command line
        vtracer_options.update(args)

        vtracer.convert_image_to_svg_py(**vtracer_options)
        return 0 # Success
    except Exception as e:
        print(f"Error during tracing: {e}")
        return 1 # Error

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Wrapper script for vtracer to be called via subprocess."
    )
    parser.add_argument("--input", required=True, help="Input image file.")
    parser.add_argument("--output", required=True, help="Output SVG file.")
    parser.add_argument("--mode", default="spline", help="Tracing mode (e.g., spline, polygon).")
    parser.add_argument("--filter-speckle", type=int, default=4, help="Filter speckles smaller than this size.")
    # Add any other vtracer arguments you want to expose

    parsed_args, _ = parser.parse_known_args()
    
    exit_code = trace_with_vtracer(
        input_path=parsed_args.input,
        output_path=parsed_args.output,
        args=vars(parsed_args)
    )
    exit(exit_code)
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
This script acts as the clean interface between Nuke and the complex vtracer library.
</p>

<div id="QUESTION-ANSWER-Step 3: Call the wrapper script from Nuke via subprocess"><h4 id="Step 3: Call the wrapper script from Nuke via subprocess" class="header"><a href="#QUESTION-ANSWER-Step 3: Call the wrapper script from Nuke via subprocess">Step 3: Call the wrapper script from Nuke via subprocess</a></h4></div>

<p>
Now, the Nuke script simply needs to call the Python interpreter inside the virtual environment and pass the arguments to the wrapper script. 
</p>

<pre python>
import nuke
import subprocess
import os
import tempfile

def trace_from_nuke_with_venv(input_node):
    """
    Traces a black-and-white image from a Nuke node using a venv and a wrapper script.
    """
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    # Paths managed by pipeline administrators
    venv_python = "/mnt/projects/tools/vtracer_env/bin/python"
    wrapper_script = "/mnt/projects/tools/vtracer_wrapper.py"

    with tempfile.TemporaryDirectory() as temp_dir:
        input_png = os.path.join(temp_dir, "temp_input.png")
        output_svg = os.path.join(temp_dir, "temp_output.svg")
        final_png = os.path.join(temp_dir, "final_output.png")

        # Step 1: Render the Nuke node's output to a temporary PNG
        nuke.render(input_node, filename=input_png)
        
        # Step 2: Call the wrapper script via subprocess
        try:
            print(f"Tracing '{input_png}' using venv...")
            subprocess.run(
                [venv_python, wrapper_script, "--input", input_png, "--output", output_svg, "--mode", "spline"],
                check=True,
                capture_output=True,
                text=True
            )
            
            # Step 3: Rasterize the SVG using ImageMagick (assuming it's in the system PATH)
            print(f"Rasterizing '{output_svg}'...")
            subprocess.run(["convert", "-density", "600", output_svg, final_png], check=True)
            
            # Step 4: Create a new Read node in Nuke with the final PNG
            result_node = nuke.createNode("Read")
            result_node["file"].setValue(final_png)
            result_node["label"].setValue("VTraced (Venv)")
            
            print("Successfully created a new node with the traced image.")
        
        except subprocess.CalledProcessError as e:
            nuke.message(f"Error during subprocess call:\nStdout: {e.stdout}\nStderr: {e.stderr}")
        except FileNotFoundError:
            nuke.message(f"Error: '{venv_python}', '{wrapper_script}', or 'convert' not found.")
        except Exception as e:
            nuke.message(f"An unexpected error occurred: {e}")

# Example usage: trace_from_nuke_with_venv(nuke.selectedNode())
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Benefits of this approach"><h3 id="Benefits of this approach" class="header"><a href="#QUESTION-ANSWER-Benefits of this approach">Benefits of this approach</a></h3></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Isolation"></span><strong id="Isolation">Isolation</strong>: Your Nuke installation remains clean and unchanged. The virtual environment contains all the dependencies, preventing conflicts.

<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Version Control"></span><strong id="Version Control">Version Control</strong>: The pipeline team can control the exact versions of vtracer and other libraries used by Nuke scripts simply by managing the virtual environment.

<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Portability"></span><strong id="Portability">Portability</strong>: This setup is highly portable across different Linux workstations, as long as they can access the shared network path.

<li>
<span id="QUESTION-ANSWER-Benefits of this approach-Robustness"></span><strong id="Robustness">Robustness</strong>: By using subprocess with full paths to the virtual environment's Python executable and a well-defined wrapper script, you eliminate the ambiguity that can arise from relative paths or inherited environment variables.

</ul>
<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
But what if I as a user on the company system would like to install the modules in a Virtual Environment that is NOT on the companywide system? Can I make Nuke see my local virtual setup?
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
Yes, as a user, you can install Python modules in a local virtual environment and make them accessible to Nuke. There are two robust methods for achieving this, both of which are independent of the company-wide system. 
</p>

<div id="QUESTION-ANSWER-Method 1: The recommended subprocess approach"><h3 id="Method 1: The recommended subprocess approach" class="header"><a href="#QUESTION-ANSWER-Method 1: The recommended subprocess approach">Method 1: The recommended subprocess approach</a></h3></div>

<p>
This is the safest and most reliable method. It involves creating a local virtual environment and then calling a script within that environment from Nuke using subprocess, just like the company-wide solution but with paths pointing to your local setup.
</p>

<div id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:"><h4 id="Advantages:" class="header"><a href="#QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:">Advantages:</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:-Safety"></span><strong id="Safety">Safety</strong>: It keeps your local environment completely isolated, preventing conflicts with Nuke's internal Python or any shared company tools.

<li>
<span id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:-Portability"></span><strong id="Portability">Portability</strong>: The script can work on any machine with access to your home directory, making it a reliable personal tool.

<li>
<span id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-Advantages:-No Admin Rights Needed"></span><strong id="No Admin Rights Needed">No Admin Rights Needed</strong>: All installations are contained within your user space. 

</ul>
<div id="QUESTION-ANSWER-Method 1: The recommended subprocess approach-How to set it up"><h4 id="How to set it up" class="header"><a href="#QUESTION-ANSWER-Method 1: The recommended subprocess approach-How to set it up">How to set it up</a></h4></div>

<p>
Create a local virtual environment: In your home directory (e.g., ~/nuke_tools/vtracer_env), create a new virtual environment.
</p>

<pre sh>
mkdir -p ~/nuke_tools
python3 -m venv ~/nuke_tools/vtracer_env
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
Install the packages: Activate your new environment and install vtracer.
</p>

<pre sh>
source ~/nuke_tools/vtracer_env/bin/activate
pip install vtracer pillow
deactivate
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Use the wrapper script: Reuse the same wrapper script from the previous answer, saved to your local tools directory (e.g., ~/nuke_tools/vtracer_wrapper.py).

<li>
Update the Nuke script: In your personal Nuke scripts (e.g., in ~/.nuke/menu.py or your Script Editor), update the paths to point to your local environment.

</ul>
  
<pre python>
import nuke
import subprocess
import os
import tempfile

def trace_local_venv(input_node):
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    # --- User-defined paths ---
    venv_python = os.path.expanduser("~/nuke_tools/vtracer_env/bin/python")
    wrapper_script = os.path.expanduser("~/nuke_tools/vtracer_wrapper.py")
    # --------------------------

    with tempfile.TemporaryDirectory() as temp_dir:
        input_png = os.path.join(temp_dir, "temp_input.png")
        output_svg = os.path.join(temp_dir, "temp_output.svg")
        final_png = os.path.join(temp_dir, "final_output.png")

        nuke.render(input_node, filename=input_png)

        try:
            subprocess.run(
                [venv_python, wrapper_script, "--input", input_png, "--output", output_svg],
                check=True, capture_output=True, text=True
            )
            subprocess.run(["convert", "-density", "600", output_svg, final_png], check=True)

            result_node = nuke.createNode("Read")
            result_node["file"].setValue(final_png)
            result_node["label"].setValue("VTraced (Local)")
            print("Tracing complete.")

        except subprocess.CalledProcessError as e:
            nuke.message(f"Error during tracing:\n{e.stderr}")
        except FileNotFoundError:
            nuke.message("Command not found. Check your paths and installations.")
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach"><h3 id="Method 2: The init.py direct import approach" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach">Method 2: The init.py direct import approach</a></h3></div>

<p>
This method makes the local virtual environment's packages directly importable within Nuke's Script Editor. It's less isolated than the subprocess method but more convenient if you need to use the libraries directly in your Nuke Python code. 
</p>

<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:"><h4 id="Advantages:" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:">Advantages:</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:-Convenience"></span><strong id="Convenience">Convenience</strong>: You can use import vtracer directly within your Nuke session.

<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Advantages:-Full Integration"></span><strong id="Full Integration">Full Integration</strong>: Gives you access to all library functionality without the overhead of external processes. 

</ul>
<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Drawbacks:"><h4 id="Drawbacks:" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-Drawbacks:">Drawbacks:</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Drawbacks:-Less Isolation"></span><strong id="Less Isolation">Less Isolation</strong>: It modifies Nuke's sys.path, which has a small risk of causing conflicts, although this is unlikely with a well-contained virtual environment. 

</ul>
<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up"><h4 id="How to set it up" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up">How to set it up</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Create the virtual environment"></span><strong id="Create the virtual environment">Create the virtual environment</strong>: Follow Step 1 from the subprocess method.

<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Add path in init.py"></span><strong id="Add path in init.py">Add path in init.py</strong>: Find or create your personal init.py file. This is typically located in ~/.nuke/.

<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Append site-packages to sys.path"></span><strong id="Append site-packages to sys.path">Append site-packages to sys.path</strong>: In your init.py, add the path to your virtual environment's site-packages folder.

</ul>
  
<pre python>
import sys
import os

# Resolve the path to your local virtual environment's site-packages
venv_path = os.path.expanduser("~/nuke_tools/vtracer_env/lib/python3.x/site-packages")

# Add it to the system path
if os.path.isdir(venv_path):
    sys.path.append(venv_path)
    print(f"Added local virtual environment to Nuke's Python path: {venv_path}")
else:
    print(f"Warning: Local virtual environment not found at {venv_path}")
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
_Note: Replace <code>python3.x</code> with your Python version (e.g., `python3.11)._
</p>

<ul>
<li>
<span id="QUESTION-ANSWER-Method 2: The init.py direct import approach-How to set it up-Run Nuke script"></span><strong id="Run Nuke script">Run Nuke script</strong>: Restart Nuke. You can now use import vtracer directly in the Script Editor or any of your Python files that Nuke executes. 

</ul>
<div id="QUESTION-ANSWER-Method 2: The init.py direct import approach-Which method should you choose?"><h4 id="Which method should you choose?" class="header"><a href="#QUESTION-ANSWER-Method 2: The init.py direct import approach-Which method should you choose?">Which method should you choose?</a></h4></div>

<ul>
<li>
Use the <code>subprocess</code> approach (Method 1) for maximum stability. In a production environment with strict rules about software stability, this is the safest path. It ensures that any version changes or dependency conflicts in your local toolchain don't affect Nuke's core functionality.

<li>
Use the <code>init.py</code> import approach (Method 2) for direct scripting convenience. If you prioritize ease of development and want to interact with the libraries more fluidly in your Python scripts, this is a good option. The risks are minimal for well-isolated libraries like vtracer.

</ul>
<div id="Bonus"><h1 id="Bonus" class="header"><a href="#Bonus">Bonus</a></h1></div>

<div id="Bonus-The tempfile module"><h2 id="The tempfile module" class="header"><a href="#Bonus-The tempfile module">The tempfile module</a></h2></div>

<p>
The <code>tempfile</code> part of the script above uses Python's built-in tempfile module to create a temporary directory. The key features of this code block are:
</p>
<ul>
<li>
<span id="Bonus-The tempfile module-Context Manager"></span><strong id="Context Manager">Context Manager</strong>: The with statement creates a context manager. This ensures that the code inside the with block has access to the temporary directory.

<li>
<span id="Bonus-The tempfile module-Automatic Cleanup"></span><strong id="Automatic Cleanup">Automatic Cleanup</strong>: When the program exits the with block (either successfully or due to an error), Python's tempfile.TemporaryDirectory() automatically deletes the temporary directory and all of its contents. This prevents the temporary files from being left on the system and saves you from having to manually clean them up.

<li>
<span id="Bonus-The tempfile module-Variable Assignment"></span><strong id="Variable Assignment">Variable Assignment</strong>: The as temp_dir: part assigns the path of the newly created temporary directory to the variable temp_dir.

<li>
<span id="Bonus-The tempfile module-Creating Paths"></span><strong id="Creating Paths">Creating Paths</strong>: The os.path.join() lines then use this temporary directory path to create full paths for the intermediate files that are needed during processing (input_png, output_svg, and final_png). 

</ul>
<p>
In summary, the code creates a secure, temporary workspace for the script to use. All intermediate files generated during the tracing and rasterization steps are stored here, and everything is automatically removed as soon as the process is complete.
</p>

<div id="ImageMagick Installation"><h1 id="ImageMagick Installation" class="header"><a href="#ImageMagick Installation">ImageMagick Installation</a></h1></div>

<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
Can ImageMagick be installed via pip? (My concern is that if it's not an available module on my company's system, and I want to install if into my local venv, how can I install as a non-admin user?)
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
No, you cannot install the ImageMagick command-line tool directly via pip. pip is a package manager for Python libraries, while ImageMagick is a separate application that is typically installed using a system's package manager (like apt or dnf) or compiled from source. 
</p>

<p>
For your scenario as a non-admin user on a company system, you have two primary options for obtaining and using the ImageMagick tool.
</p>

<div id="QUESTION-ANSWER-Option 1: Install ImageMagick from source"><h3 id="Option 1: Install ImageMagick from source" class="header"><a href="#QUESTION-ANSWER-Option 1: Install ImageMagick from source">Option 1: Install ImageMagick from source</a></h3></div>

<p>
This is the most direct method and gives you complete control over the installation location. It does not require administrator privileges, but it does require that the necessary build tools (like gcc and make) are available on your system. 
</p>

<div id="QUESTION-ANSWER-Option 1: Install ImageMagick from source-How to do it:"><h4 id="How to do it:" class="header"><a href="#QUESTION-ANSWER-Option 1: Install ImageMagick from source-How to do it:">How to do it:</a></h4></div>

<ul>
<li>
Download the source code. Get the .tar.gz file for the latest version of ImageMagick from the official website.

<li>
Unpack the source.

</ul>
  
<pre sh>
tar -xzf ImageMagick-*.tar.gz
cd ImageMagick-*/
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Configure for a local install. When running ./configure, specify a local install path using the --prefix flag. This directs the installation to a directory in your home folder.

</ul>
  
<pre sh>
./configure --prefix=$HOME/imagemagick-local
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Compile and install.

</ul>
  
<pre sh>
make
make install
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Add to your shell's PATH. To ensure your system can find the convert command, you need to add the installation's bin directory to your PATH environment variable. You can add this line to your ~/.bashrc or ~/.zshrc file:

</ul>
  
<pre sh>
export PATH="$HOME/imagemagick-local/bin:$PATH"
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Add to library path (if necessary). You may also need to add the library directory to your LD_LIBRARY_PATH for ImageMagick to find its own components correctly.

</ul>
  
<pre sh>
export LD_LIBRARY_PATH="$HOME/imagemagick-local/lib:$LD_LIBRARY_PATH"
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<ul>
<li>
Reload your shell configuration. Either open a new terminal or run source ~/.bashrc (or ~/.zshrc). 

</ul>
<div id="QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment"><h3 id="Option 2: Use Python bindings via a virtual environment" class="header"><a href="#QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment">Option 2: Use Python bindings via a virtual environment</a></h3></div>

<p>
This method is an alternative that uses a Python library that wraps around the ImageMagick API. This removes the need for you to manage the ImageMagick installation manually. 
</p>

<p>
The two most common Python libraries for this are wand and PythonMagick. 
</p>

<div id="QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-Using wand"><h4 id="Using wand" class="header"><a href="#QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-Using wand">Using wand</a></h4></div>

<p>
<code>wand</code> is a Python binding for the ImageMagick library (MagickWand). While you can install wand via pip, it still requires the underlying ImageMagick library to be available on your system. This means if the company has not already installed it, wand won't work out-of-the-box. 
</p>

<div id="QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-Using a Conda environment"><h4 id="Using a Conda environment" class="header"><a href="#QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-Using a Conda environment">Using a Conda environment</a></h4></div>

<p>
If your company provides or allows the use of Conda, it's an excellent way to handle this. You can install ImageMagick directly into your virtual environment. 
</p>

<div id="QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-How to do it:"><h4 id="How to do it:" class="header"><a href="#QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-How to do it:">How to do it:</a></h4></div>

<p>
Create a Conda environment.
</p>

<pre sh>
conda create -n my-imagemagick-env
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
Install ImageMagick via conda-forge.
</p>

<pre sh>
conda activate my-imagemagick-env
conda install -c conda-forge imagemagick
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
Use the script. In your Nuke script, you can activate this Conda environment within your subprocess call to access the ImageMagick tools. 
</p>

<div id="QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-Which option should you choose?"><h4 id="Which option should you choose?" class="header"><a href="#QUESTION-ANSWER-Option 2: Use Python bindings via a virtual environment-Which option should you choose?">Which option should you choose?</a></h4></div>

<ul>
<li>
For maximum independence, use Option 1 (installing from source). This is the classic "non-admin" method for installing any Linux application. It puts you in complete control and ensures the tool is available regardless of what's installed on the system.

<li>
For simplicity, inquire about Conda. If your company supports Conda, it's often the simplest way for a user to install complex, non-Python dependencies into their own environment.

<li>
For minimal effort, check for existing dependencies. Before doing any of the above, it's worth checking if ImageMagick is already available. Open a terminal and run:

</ul>
  
<pre sh>
convert --version.
</pre>
<p>
If it shows up, you can simply use the <code>subprocess</code> approach without any special installation. 
</p>


<div id="Note on Potrace"><h1 id="Note on Potrace" class="header"><a href="#Note on Potrace">Note on Potrace</a></h1></div>

<div id="QUESTION"><h1 id="QUESTION" class="header"><a href="#QUESTION">QUESTION</a></h1></div>

<p>
Can potrace be installed via pip in Python3?
</p>

<div id="QUESTION-ANSWER"><h2 id="ANSWER" class="header"><a href="#QUESTION-ANSWER">ANSWER</a></h2></div>

<p>
You cannot install the original, command-line potrace program directly via pip. However, a Python port of the Potrace algorithm called potracer is available on PyPI and can be installed with pip. This pure Python version allows you to use the Potrace functionality within a Python script without relying on the external command-line tool. 
</p>

<div id="QUESTION-ANSWER-Using the Python port: potracer"><h4 id="Using the Python port: potracer" class="header"><a href="#QUESTION-ANSWER-Using the Python port: potracer">Using the Python port: potracer</a></h4></div>

<p>
Install potracer into your virtual environment:
</p>

<pre sh>
pip install potracer
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<p>
Use it directly in your Python code within Nuke, eliminating the need for subprocess. The workflow would involve using the Pillow library (which you can also install via pip) to handle image input and then passing the data to potracer. 
</p>

<div id="QUESTION-ANSWER-Here is an updated Nuke script using the potracer library directly."><h4 id="Here is an updated Nuke script using the potracer library directly." class="header"><a href="#QUESTION-ANSWER-Here is an updated Nuke script using the potracer library directly.">Here is an updated Nuke script using the potracer library directly.</a></h4></div>

<p>
Updated Nuke script using the potracer library
</p>
<pre python>
import nuke
import os
import tempfile
from PIL import Image
from potracer import Bitmap

def trace_local_potracer(input_node):
    """
    Traces a black-and-white image from a Nuke node using the potracer library.
    """
    if not isinstance(input_node, nuke.Read):
        nuke.message("Please select a Read node.")
        return

    with tempfile.TemporaryDirectory() as temp_dir:
        input_png = os.path.join(temp_dir, "temp_input.png")
        output_svg = os.path.join(temp_dir, "temp_output.svg")

        # Step 1: Render the Nuke node's output to a temporary PNG
        nuke.render(input_node, filename=input_png)
        
        try:
            # Step 2: Use the potracer library to convert PNG to SVG
            print(f"Tracing '{input_png}' using potracer library...")
            image = Image.open(input_png)
            bm = Bitmap(image)
            plist = bm.trace()
            plist.svg(output_svg)
            
            # Step 3: Create a new Read node in Nuke with the resulting SVG
            result_node = nuke.createNode("Read")
            result_node["file"].setValue(output_svg)
            result_node["label"].setValue("Potracer (Lib)")
            
            print("Successfully created a new node with the traced SVG.")

        except Exception as e:
            nuke.message(f"An error occurred during tracing: {e}")

# Example usage: trace_local_potracer(nuke.selectedNode())
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="QUESTION-ANSWER-Comparing potracer to the command-line version"><h4 id="Comparing potracer to the command-line version" class="header"><a href="#QUESTION-ANSWER-Comparing potracer to the command-line version">Comparing potracer to the command-line version</a></h4></div>

<ul>
<li>
<span id="QUESTION-ANSWER-Comparing potracer to the command-line version-Performance"></span><strong id="Performance">Performance</strong>: The pure Python potracer library can be significantly slower (up to 500x slower) than the original potrace C program for very complex, large images. For typical usage with logos or line art, the speed difference may not be a major issue.

<li>
<span id="QUESTION-ANSWER-Comparing potracer to the command-line version-Convenience"></span><strong id="Convenience">Convenience</strong>: Installing potracer via pip is much simpler than compiling the original potrace from source, especially for a non-admin user on a company system. It also removes the dependency on an external executable.

</ul>
<p>
<a href="pmount_index.html">PMount</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
