<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_project_char_ink_paint_template</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PMount</a>
</p>

<div id="Custom Ink/Paint Template"><h1 id="Custom Ink/Paint Template" class="header"><a href="#Custom Ink/Paint Template">Custom Ink/Paint Template</a></h1></div>

<div id="Custom Ink/Paint Template-QUESTION"><h2 id="QUESTION" class="header"><a href="#Custom Ink/Paint Template-QUESTION">QUESTION</a></h2></div>

<table>
<tr>
<td>
I want to create a template consisting of a collection of Nuke nodes - a network with connections and backdrops. What's the best way of scripting a creation of this sort? Would you construct each node with positions and connections, or have a separate template that is referenced and modified to satisfy the scripts parameters? I need to set the names of nodes and create writes and postagestamps with the user's chosen prefix.
</td>
</tr>
</table>


<p>
The best and most maintainable way to script the creation of a complex Nuke node network (a template) is to use a separate template file (.nk) and then use Python to load it and modify the nodes. Constructing every node from scratch using nuke.createNode() is extremely verbose, error-prone, and difficult to update.
</p>

<p>
Here is the step-by-step approach using a template file, which is often referred to as a ToolSet in Nuke.
</p>

<div id="Custom Ink/Paint Template-Create the Template (.nk) File"><h2 id="Create the Template (.nk) File" class="header"><a href="#Custom Ink/Paint Template-Create the Template (.nk) File">Create the Template (.nk) File</a></h2></div>

<p>
First, you'll need to create the template itself:
</p>

<ul>
<li>
<span id="Custom Ink/Paint Template-Create the Template (.nk) File-Build the Network"></span><strong id="Build the Network">Build the Network</strong>: In a new Nuke script, build your entire network (including nodes, connections, and backdrops).

<li>
<span id="Custom Ink/Paint Template-Create the Template (.nk) File-Add Placeholders"></span><strong id="Add Placeholders">Add Placeholders</strong>: Use placeholder nodes that your script will find and modify. For example, use a NoOp node named USER_PREFIX_INPUT where the user's input will attach, and a NoOp node named USER_PREFIX_OUTPUT to easily locate the downstream end of the template.

<li>
<span id="Custom Ink/Paint Template-Create the Template (.nk) File-Save as a ToolSet"></span><strong id="Save as a ToolSet">Save as a ToolSet</strong>: Select all the nodes and go to File &gt; Export Selected Nodes... and save the file with a descriptive name (e.g., my_processing_template.nk). This creates a clean, minimal Nuke script containing only the selected network.

</ul>
<div id="Custom Ink/Paint Template-Script the Template Instantiation"><h2 id="Script the Template Instantiation" class="header"><a href="#Custom Ink/Paint Template-Script the Template Instantiation">Script the Template Instantiation</a></h2></div>

<p>
Your Python script will load the template, find the placeholder nodes, and apply the user's settings.
</p>

<pre python>
<table>
<tr>
<td>
UNTESTED
</td>
</tr>
</table>
import nuke

def create_templated_network(template_path, user_prefix, input_node=None):
    """
    Loads a Nuke node network from a template file and customizes it.

    :param template_path: Full path to the .nk template file.
    :param user_prefix: Prefix to apply to all relevant node names.
    :param input_node: Optional node to connect the template's input to.
    :return: List of all nodes created by loading the template.
    """
    
    # --- 1. Load the Template (.nk) ---
    
    # Get the names of the currently selected nodes to find the newly pasted nodes later
    initial_selection = set(nuke.selectedNodes())
    
    # Load the template (ToolSet). This pastes the nodes into the current script.
    # The nodes will automatically be selected after being pasted.
    nuke.nodePaste(template_path)
    
    # Get all nodes that are NOW selected (i.e., the nodes that were just pasted)
    newly_pasted_nodes = nuke.selectedNodes()
    
    # Deselect all the newly pasted nodes
    for node in newly_pasted_nodes:
        node.setSelected(False) 
        
    # --- 2. Iterate and Customize Nodes ---
    
    write_nodes = []
    
    for node in newly_pasted_nodes:
        
        # 2a. Set Node Names
        # Rename ALL nodes with the user's prefix for organization
        new_name = f"{user_prefix}_{node.name()}"
        node.setName(new_name)
        
        # 2b. Customize Write Nodes
        # We look for nodes whose class is 'Write'
        if node.Class() == 'Write':
            # Store it for connection later if needed
            write_nodes.append(node)
            
            # Example: Set file path to include the prefix and a standard output name
            # NOTE: You'll need to define a proper file path logic here.
            # node['file'].setValue(f"/path/to/renders/{user_prefix}_Final.exr")
            
        # 2c. Set Postage Stamp
        # Enable postage stamp on the new write nodes
        if node.Class() == 'Write':
            try:
                node['postage_stamp'].setValue(True)
            except NameError:
                # Handle cases where the knob might not exist (e.g., not all nodes have it)
                pass

        # 2d. Find and Handle Placeholders (Connections)
        # Find the node that acts as the network's input
        if 'INPUT_PLACEHOLDER' in node.name().upper() and input_node is not None:
             # Connect the template's placeholder input (node) to the user's node (input_node)
             node.setInput(0, input_node)
             print(f"Connected template input to {input_node.name()}")

    # --- 3. Finalize and Return ---
    
    print(f"Successfully created network with prefix: {user_prefix}")
    return newly_pasted_nodes

# --- EXAMPLE USAGE ---

# 1. Define the path to your saved .nk template
TEMPLATE_FILE = "/path/to/your/my_processing_template.nk" 

# 2. Define the user's chosen prefix
USER_CHOSEN_PREFIX = "AssetA_V01"

# 3. Get the node the user wants to plug the template into (e.g., the last Grade node)
USER_INPUT_NODE = nuke.toNode('Grade1') # Replace 'Grade1' with a function to get the actual node

# 4. Create the network
created_nodes = create_templated_network(TEMPLATE_FILE, USER_CHOSEN_PREFIX, USER_INPUT_NODE)
</pre>

<div id="Custom Ink/Paint Template-Script the Template Instantiation-Why the Template Approach is Superior ✨"><h3 id="Why the Template Approach is Superior ✨" class="header"><a href="#Custom Ink/Paint Template-Script the Template Instantiation-Why the Template Approach is Superior ✨">Why the Template Approach is Superior ✨</a></h3></div>

<table>
<tr>
<td>
Feature
</td>
<td>
Template (.nk) Approach
</td>
<td>
Manual nuke.createNode() Approach
</td>
</tr>
<tr>
<td>
Complexity
</td>
<td>
Handles complex connections, curves, and backdrops easily.
</td>
<td>
Requires hundreds of lines of code to define positions, curve data, and connections.
</td>
</tr>
<tr>
<td>
Maintenance
</td>
<td>
Update the template in the GUI and save; the Python script remains the same.
</td>
<td>
Any network change requires updating dozens of Python lines.
</td>
</tr>
<tr>
<td>
Connections
</td>
<td>
All internal connections are preserved automatically on paste.
</td>
<td>
Every connection must be manually coded using node.setInput(index, other_node).
</td>
</tr>
<tr>
<td>
Positioning
</td>
<td>
Nodes retain their relative positions automatically.
</td>
<td>
Every node needs hardcoded node.setXpos() and node.setYpos() calls.
</td>
</tr>
</table>

<div id="Custom Ink/Paint Template-QUESTION"><h2 id="QUESTION" class="header"><a href="#Custom Ink/Paint Template-QUESTION">QUESTION</a></h2></div>
<table>
<tr>
<td>
I'm looking into creating a script based mechanism to import a template into Nuke, whereby the template has a placeholder string in some nodes' parameters and names. I'm wondering if rather than searching for and assigning values to knobs, whether I could import the template and parse the template as a string and search/replace a placeholder string before importing/pasting the contents of the template.
</td>
</tr>
</table>

<p>
Yes, performing a string search and replace on the raw .nk template file is a more flexible and robust approach than iterating over knobs after pasting. This method allows you to: 
</p>

<ul>
<li>
Rename nodes and replace text within knob values simultaneously.

<li>
Handle placeholders in multiple knobs, even if you don't know their names in advance.

<li>
Process parts of the file that aren't exposed through the standard Python API. 

</ul>
<p>
The Nuke .nk file format is a plain text script, which makes it well-suited for this kind of manipulation. 
</p>

<p>
Here is an updated version of your script that reads the template file, performs a string replacement, and then pastes the modified script. 
</p>

<div id="Custom Ink/Paint Template-QUESTION-Updated code with string replacement"><h3 id="Updated code with string replacement" class="header"><a href="#Custom Ink/Paint Template-QUESTION-Updated code with string replacement">Updated code with string replacement</a></h3></div>

<pre python>
<table>
<tr>
<td>
UNTESTED
</td>
</tr>
</table>
import nuke
import tempfile
import os
import uuid

def create_templated_network_string_replace(template_path, replace_map, input_node=None):
    """
    Loads a Nuke node network from a template file, performs string replacements,
    and then pastes the modified script.

    :param template_path: Full path to the .nk template file.
    :param replace_map: A dictionary where keys are the placeholder strings
                        and values are the replacement strings.
    :param input_node: Optional node to connect the template's input to.
    :return: List of all nodes created by loading the template.
    """
    
    # 1. Read the template file as a string
    try:
        with open(template_path, 'r') as f:
            template_content = f.read()
    except FileNotFoundError:
        nuke.message(f"Error: Template file not found at {template_path}")
        return []

    # 2. Perform string replacements
    modified_content = template_content
    for placeholder, replacement in replace_map.items():
        modified_content = modified_content.replace(placeholder, replacement)
        
    # 3. Write the modified content to a temporary file
    temp_file = os.path.join(tempfile.gettempdir(), f"nuke_temp_{uuid.uuid4().hex}.nk")
    try:
        with open(temp_file, 'w') as f:
            f.write(modified_content)
    except IOError:
        nuke.message(f"Error: Failed to write to temporary file {temp_file}")
        return []
    
    # --- 4. Load the Template (.nk) from the temp file ---
    
    initial_selection = set(nuke.selectedNodes())
    
    # The actual nuke.nodePaste happens here
    nuke.nodePaste(temp_file)
    
    # Get all nodes that are NOW selected (i.e., the nodes that were just pasted)
    newly_pasted_nodes = nuke.selectedNodes()
    
    # Deselect all the newly pasted nodes
    for node in newly_pasted_nodes:
        node.setSelected(False) 
    
    # 5. Handle Connections and Cleanup (if necessary)
    
    # Find the node that acts as the network's input
    if input_node is not None:
        for node in newly_pasted_nodes:
            # You will still need to identify the placeholder node for connection.
            # This is done by searching its new, replaced name.
            if 'INPUT_PLACEHOLDER' in node.name().upper():
                node.setInput(0, input_node)
                print(f"Connected template input to {input_node.name()}")
    
    # 6. Cleanup the temporary file
    if os.path.exists(temp_file):
        os.remove(temp_file)
        
    print(f"Successfully created network from template: {template_path}")
    return newly_pasted_nodes

# --- EXAMPLE USAGE ---

# 1. Define the path to your saved .nk template
TEMPLATE_FILE = "/path/to/your/my_processing_template.nk" 

# 2. Define the user's chosen prefix and other replacements
USER_CHOSEN_PREFIX = "AssetA_V01"

# The replacement mapping for the script.
# Use unique strings like '!!!PREFIX!!!' to avoid accidental replacements.
# Also good for readability.
REPLACEMENT_MAP = {
    '!!!PREFIX!!!': USER_CHOSEN_PREFIX,
    '!!!RENDER_PATH!!!': f"/path/to/renders/{USER_CHOSEN_PREFIX}",
    '!!!VERSION!!!': "v01"
}

# 3. Get the node the user wants to plug the template into
USER_INPUT_NODE = nuke.toNode('Grade1') # Replace 'Grade1' with the correct node

# 4. Create the network
created_nodes = create_templated_network_string_replace(
    TEMPLATE_FILE,
    REPLACEMENT_MAP,
    USER_INPUT_NODE
)
</pre>
<table>
<tr>
<td>
Use code with caution.
</td>
</tr>
</table>

<div id="Custom Ink/Paint Template-QUESTION-How to create your template file"><h3 id="How to create your template file" class="header"><a href="#Custom Ink/Paint Template-QUESTION-How to create your template file">How to create your template file</a></h3></div>

<ul>
<li>
Build the template network in Nuke with dummy nodes.

<li>
Use unique placeholder text for any names or knob values you want to replace. For example:

<ul>
<li>
Node Name: !!!PREFIX!!!_Merge

<li>
Write Node file Knob: /path/to/renders/!!!PREFIX!!!_Final.exr

<li>
Any other knob, like a Text node's message knob: Project: !!!PREFIX!!!

</ul>
<li>
Select all nodes in the template.

<li>
Go to File &gt; Export ToolSet and save the template with a .nk extension. This saves the selected nodes and their connections as a plain text file, ready for your script to modify.

</ul>
<div id="COMPLETED PROJECT"><h1 id="COMPLETED PROJECT" class="header"><a href="#COMPLETED PROJECT">COMPLETED PROJECT</a></h1></div>

<div id="COMPLETED PROJECT-NUKE TEMPLATE"><h2 id="NUKE TEMPLATE" class="header"><a href="#COMPLETED PROJECT-NUKE TEMPLATE">NUKE TEMPLATE</a></h2></div>

<p>
This is called from the python script:
</p>

<pre nuke>
set cut_paste_input [stack 0]
version 15.0 v7
BackdropNode {
 inputs 0
 name BackdropNode119
 tile_color 0x616d77ff
 label "CHARPREFIXTITLE\nInk&amp;Paint v4"
 note_font "Bitstream Vera Sans Bold"
 note_font_size 100
 selected true
 xpos -437
 ypos -770
 bdwidth 938
 bdheight 1571
 z_order 2
}
BackdropNode {
 inputs 0
 name BackdropNode120
 label "CHARPREFIXUPPER\nINK &amp; PAINT EXTRACTION\n(MIR)"
 note_font "Bitstream Vera Sans Bold"
 note_font_size 44
 selected true
 xpos -170
 ypos -520
 bdwidth 624
 bdheight 879
 z_order 3
}
push $cut_paste_input
Dot {
 name Dot
 label "CHARPREFIXUPPER INPUT"
 note_font "Bitstream Vera Sans Bold"
 note_font_size 30
 selected true
 xpos 136
 ypos -398
}
Expression {
 temp_name0 epsilon
 temp_expr0 0.001
 temp_name1 pick_color_from
 temp_name2 user_tab
 channel3 alpha
 expr3 "(abs(r - clr.r) &lt;= epsilon) &amp;&amp; (abs(g - clr.g) &lt;= epsilon ) &amp;&amp; (abs(b -clr.b) &lt;= epsilon) ? 0 : 1"
 name Expression_alphapicker_inverted
 selected true
 xpos 102
 ypos -330
 addUserKnob {20 User}
 addUserKnob {18 clr l "Color pick"}
 clr {1.000000596 1.000001311 0.9999998212}
 addUserKnob {6 clr_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 alpha_color_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {26 type l Type: T Inverted}
 addUserKnob {26 version l Version T 2.0.0}
 addUserKnob {26 version_history l "" +STARTLINE +INVISIBLE T "1.0.0 - initial\n2.0.0 - epsilon and epsilon logic"}
}
Dot {
 name Dot452
 selected true
 xpos 136
 ypos -278
}
set Nf1d3f80 [stack 0]
Dot {
 name Dot453
 selected true
 xpos 26
 ypos -278
}
set Nf272a60 [stack 0]
Dot {
 name Dot_01
 selected true
 xpos -84
 ypos -278
}
Expression {
 temp_name0 epsilon
 temp_expr0 0.001
 temp_name1 pick_color_from
 temp_name2 user_tab
 channel3 alpha
 expr3 "(abs(r - clr.r) &lt;= epsilon) &amp;&amp; (abs(g - clr.g) &lt;= epsilon ) &amp;&amp; (abs(b -clr.b) &lt;= epsilon) ? 1 : 0"
 name Expression_alphapicker
 selected true
 xpos -118
 ypos -234
 addUserKnob {20 User}
 addUserKnob {18 clr l "Color pick"}
 clr {0.0009105816134 0.0009105823119 0.0009105809731}
 addUserKnob {6 clr_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 alpha_color_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {26 type l Type: T Regular}
 addUserKnob {26 version l Version: T 2.0.0}
 addUserKnob {26 version_history l "" +STARTLINE +INVISIBLE T "1.0.0 - initial\n2.0.0 - added epsilon and error logic"}
}
Dot {
 name Dot455
 selected true
 xpos -84
 ypos -206
}
set Nf2177d0 [stack 0]
Dot {
 name Dot456
 selected true
 xpos -304
 ypos -206
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 black -1 -1 rgba.red 0 0 black -1 -1 rgba.green 0 1 black -1 -1 rgba.blue 0 2 rgba.alpha 0 3 rgba.alpha 0 3"
 name Shuffle_ink
 selected true
 xpos -338
 ypos -42
}
Clamp {
 name Clamp_ink
 selected true
 xpos -338
 ypos -16
}
Dot {
 name Dot457
 selected true
 xpos -304
 ypos 394
}
set N103ba450 [stack 0]
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.red 0 0 rgba.alpha 0 3 rgba.green 0 1 rgba.alpha 0 3 rgba.blue 0 2 rgba.alpha 0 3 rgba.alpha 0 3"
 name Line_Alpha
 selected true
 xpos -118
 ypos 390
}
push $Nf1d3f80
Dot {
 name Dot458
 selected true
 xpos 246
 ypos -278
}
Premult {
 name Premult
 selected true
 xpos 212
 ypos -210
}
Dot {
 name Dot459
 selected true
 xpos 246
 ypos 130
}
set N104581c0 [stack 0]
push $Nf272a60
push $Nf2177d0
Invert {
 name Invert
 selected true
 xpos -118
 ypos -144
}
Merge2 {
 inputs 2
 operation min
 Achannels {-rgba.red -rgba.green -rgba.blue rgba.alpha}
 name Merge
 selected true
 xpos -8
 ypos -138
}
push $Nf1d3f80
Shuffle2 {
 inputs 2
 fromInput1 {{0} B A}
 fromInput2 {{1} B A}
 in2 rgba
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 rgba.alpha 1 3 rgba.alpha 0 3"
 name Shuffle
 label "SANS\nINK LINES"
 selected true
 xpos 102
 ypos -150
}
Premult {
 name Premult_paint
 selected true
 xpos 102
 ypos -66
}
BlinkScript {
 recompileCount 69
 ProgramGroup 1
 KernelDescription "3 \"FillCellsKernel\" iterate pixelWise 7896b1c4ed6beadcdfb1b779f8a3c2a89eecd2742604757d1a8dd3fa19a10f14 2 \"src\" Read Ranged2D \"dst\" Write Point 1 \"Spread\" Float 1 AAAgQQ== 1 \"spreadSlider\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"spread\" Int 1 1 AAAAAA=="
 kernelSource "// BlinkScript FillCells\n//\n//   - Robert Holder\n//\n// version 1.0.0 - 250807\n//   - initial release.\n// version 1.0.1 - 250807\n//   - reduced MAX_UNIQUE_COLORS constant to 64;\n//   - omit colors with a black alpha from color candidates.\n// version 1.0.2 - 250820 - Default to GPU 'on'\n\nkernel FillCellsKernel : ImageComputationKernel&lt;ePixelWise&gt;\n\{\n  Image&lt;eRead, eAccessRanged2D, eEdgeClamped&gt; src;\n  Image&lt;eWrite&gt; dst;\n  \n  param:\n    //int spread;\n    float spreadSlider;\n  \n  local:\n    int spread;\n\n  void define() \{\n    defineParam(spreadSlider, \"Spread\", 10.0f);\n  \}\n  \n  void init() \{\n      src.setRange(-spread, spread, -spread, spread);\n  \}\n  \nvoid process(int2 pos) \{\n    int spread = int(spreadSlider); //Cast slider to integer\n    spread = max(1, spread); //Ensure minimum value is 1\n\n\n    float4 output = 0;\n    float alpha = src(0,0).w; // Get the alpha of the current pixel\n\n    // Using a constant for array size, consider if this is always sufficient\n    const int MAX_UNIQUE_COLORS = 64;\n    float4 uniqueColors\[MAX_UNIQUE_COLORS];\n    int colorCounts\[MAX_UNIQUE_COLORS];\n    int numUniqueColors = 0;\n\n    const float EPSILON = 0.001f; // For floating-point comparisons\n\n    if (spread &gt; 0) \{\n        // Iterate through the neighborhood\n        for(int Y = -spread; Y &lt;= spread; Y++) \{\n            for(int X = -spread; X &lt;= spread; X++) \{\n\n                // Only examine surrounding pixels IF the current pixel's alpha is 0\n                if (fabs(alpha) &lt; EPSILON) \{ // Using epsilon for alpha check\n\n                    // Access the pixel within the neighborhood at offset (X, Y)\n                    float4 neighborhoodPixel = src(X,Y);\n\n                    if (neighborhoodPixel.w &gt; EPSILON) \{\n\n                        // Check if this neighborhood pixel has already been recorded\n                        bool found = false;\n                        for (int i = 0; i &lt; numUniqueColors; ++i) \{\n                            if (fabs(uniqueColors\[i].x - neighborhoodPixel.x) &lt; EPSILON &amp;&amp;\n                                fabs(uniqueColors\[i].y - neighborhoodPixel.y) &lt; EPSILON &amp;&amp;\n                                fabs(uniqueColors\[i].z - neighborhoodPixel.z) &lt; EPSILON &amp;&amp;\n                                fabs(uniqueColors\[i].w - neighborhoodPixel.w) &lt; EPSILON) \{\n\n                                colorCounts\[i]++;\n                                found = true;\n                                break;\n                            \}\n                        \}\n                   \n\n                        // If it's a new unique color, add it to our list\n                        if (!found &amp;&amp; numUniqueColors &lt; MAX_UNIQUE_COLORS) \{\n                            uniqueColors\[numUniqueColors] = neighborhoodPixel; // Assign all components at once\n                            colorCounts\[numUniqueColors] = 1;\n                            numUniqueColors++;\n                        \}\n                    \}\n                \}\n            \}\n        \}\n    \} else \{\n        // If spread is 0, just pass through the current pixel\n        output = src(0,0);\n    \}\n\n    // Find the most frequent color among the unique colors found\n    float4 mostFrequentColor = src(0,0); // Initialize with current pixel, to handle cases with no surrounding colors\n    int maxCount = -1;\n\n    // Handle case where no unique colors were found in the neighborhood\n    // (e.g., if the alpha was not 0 or spread was 0)\n    if (numUniqueColors &gt; 0) \{\n        for (int i = 0; i &lt; numUniqueColors; ++i) \{\n            if (colorCounts\[i] &gt; maxCount) \{\n                maxCount = colorCounts\[i];\n                mostFrequentColor = uniqueColors\[i];\n            \}\n        \}\n    \}\n\n    dst() = mostFrequentColor;\n  \}\n\};\n\n"
 rebuild ""
 FillCellsKernel_Spread 3.2
 rebuild_finalise ""
 name BlinkScript_FillCells
 selected true
 xpos 102
 ypos 24
 addUserKnob {20 tab_tech l Tech}
 addUserKnob {26 version_node l "" +STARTLINE T "Version: 2.0.1 (Node)"}
 addUserKnob {26 version_blinkscript l "" +STARTLINE T "Version: 1.0.2 (BlinkScript)"}
 addUserKnob {26 version_blinkscript_history l "" +STARTLINE +INVISIBLE T "// BlinkScript FillCells\n//\n//   - Robert Holder\n//\n// version 1.0.0 - 250807\n//   - initial release.\n// version 1.0.1 - 250807\n//   - reduced MAX_UNIQUE_COLORS constant to 64;\n//   - omit colors with a black alpha from color candidates.\n// version 1.0.2 - 250820 - Default to GPU 'on'"}
}
Shuffle2 {
 inputs 2
 fromInput1 {{0} B A}
 fromInput2 {{1} B A}
 in2 alpha
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 rgba.alpha 1 0 rgba.alpha 0 3"
 name Shuffle_original_alpha
 label "ORIGINAL\nALPHA"
 note_font "DejaVu Sans"
 selected true
 xpos 102
 ypos 114
}
Dilate {
 channels alpha
 size -0.5
 name Dilate
 selected true
 xpos 102
 ypos 168
}
Premult {
 name Premult_original_alpha
 label "VIEW HERE"
 selected true
 xpos 102
 ypos 240
}
add_layer {Line Line.red Line.green Line.blue Line.alpha}
Shuffle2 {
 inputs 2
 fromInput1 {{0} B A}
 fromInput2 {{1} B A}
 in2 rgb
 out2 Line
 mappings "8 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 1 0 Line.red 1 0 rgba.green 1 1 Line.green 1 1 rgba.blue 1 2 Line.blue 1 2 rgba.alpha 0 3 Line.alpha 1 3"
 name MultiPass_Line
 selected true
 xpos 102
 ypos 390
}
Dot {
 name Dot460
 selected true
 xpos 136
 ypos 470
}
set N104e5380 [stack 0]
Write {
 channels rgba
 file /media/avoa/None/None/comp/frames/INK_and_PAINT/default/default.%04d.exr
 file_type exr
 datatype "32 bit float"
 first_part rgba
 colorspace rendering
 create_directories true
 in_colorspace scene_linear
 out_colorspace scene_linear
 ocioColorspace scene_linear
 display ACES
 view Rec.709
 name PAWrite_PAINT
 label PAINT
 selected true
 xpos 205
 ypos 448
 addUserKnob {20 User}
 addUserKnob {1 layer_name l "Layer Name"}
 layer_name default
 addUserKnob {1 file_format l "File format string"}
 file_format "/media/\{show\}/\{seq\}/\{shot\}/\{discipline\}/frames/INK_and_PAINT/\{layer_name\}/\{layer_name\}.%04d.exr"
 addUserKnob {1 file_resolved l "File resolved path"}
 file_resolved /media/avoa/None/None/comp/frames/INK_and_PAINT/default/default.%04d.exr
}
push $N104581c0
Dot {
 name Dot_all
 label CHARPREFIXUPPER_ALL
 note_font "Bitstream Vera Sans Bold"
 note_font_size 18
 selected true
 xpos 246
 ypos 178
}
Read {
 inputs 0
 file_type exr
 file "\[value PAWrite_INK.file]"
 first 1001
 last 1029
 origset true
 colorspace rendering
 name Read_from_PAWrite_INK
 label INK
 selected true
 xpos -116
 ypos 425
 disable true
 addUserKnob {20 User}
 addUserKnob {1 smartFilePath l "File Path"}
 smartFilePath "\[value PAWrite_INK.file]"
 addUserKnob {22 buttonLaunchSmartFileBrowser l "Launch Smart File Dialog" T "exec('from pa_nuke import PASmartFileDialogApp; PASmartFileDialogApp.App(createReadNode=False).execute()')" +STARTLINE}
 addUserKnob {1 customFilepath l "File Path"}
 customFilepath "\[value PAWrite_INK.file]"
 addUserKnob {22 buttonGetLatest l "Get Latest Version" T "exec('from pa_nuke import readNodeCustomize;readNodeCustomize.CustomizedReadNode().updateToLatestVersionCB()')" +STARTLINE}
 addUserKnob {22 latestVersionText l unknown -STARTLINE +DISABLED +INVISIBLE}
 addUserKnob {1 smartFilePath l "File Path"}
 smartFilePath "\[value PAWrite_INK.file]"
 addUserKnob {22 buttonLaunchSmartFileBrowser l "Launch Smart File Dialog" T "exec('from pa_nuke import PASmartFileDialogApp; PASmartFileDialogApp.App(createReadNode=False).execute()')" +STARTLINE}
}
Dot {
 name Dot462
 selected true
 xpos -82
 ypos 542
}
push $N103ba450
Dot {
 name Dot463
 selected true
 xpos -304
 ypos 470
}
set N1051fb00 [stack 0]
Switch {
 inputs 2
 name Switch_ink
 label "\[if \{\[value which]==0\} \{return \"LIVE\"\} \{return \"CACHED\"\}]"
 selected true
 xpos -338
 ypos 532
}
Dot {
 name Dot_ink
 label CHARPREFIXUPPER_INK
 note_font "Bitstream Vera Sans Bold"
 note_font_size 18
 selected true
 xpos -304
 ypos 629
}
Read {
 inputs 0
 file_type exr
 file "\[value PAWrite_PAINT.file]"
 first 1001
 last 1029
 origset true
 colorspace rendering
 name Read_from_PAWrite_PAINT
 label PAINT
 selected true
 xpos 352
 ypos 425
 disable true
 addUserKnob {20 User}
 addUserKnob {1 smartFilePath l "File Path"}
 smartFilePath "\[value PAWrite_PAINT.file]"
 addUserKnob {22 buttonLaunchSmartFileBrowser l "Launch Smart File Dialog" T "exec('from pa_nuke import PASmartFileDialogApp; PASmartFileDialogApp.App(createReadNode=False).execute()')" +STARTLINE}
 addUserKnob {1 customFilepath l "File Path"}
 customFilepath "\[value PAWrite_PAINT.file]"
 addUserKnob {22 buttonGetLatest l "Get Latest Version" T "exec('from pa_nuke import readNodeCustomize;readNodeCustomize.CustomizedReadNode().updateToLatestVersionCB()')" +STARTLINE}
 addUserKnob {22 latestVersionText l unknown -STARTLINE +DISABLED +INVISIBLE}
 addUserKnob {1 smartFilePath l "File Path"}
 smartFilePath "\[value PAWrite_PAINT.file]"
 addUserKnob {22 buttonLaunchSmartFileBrowser l "Launch Smart File Dialog" T "exec('from pa_nuke import PASmartFileDialogApp; PASmartFileDialogApp.App(createReadNode=False).execute()')" +STARTLINE}
}
Dot {
 name Dot450
 selected true
 xpos 386
 ypos 542
}
push $N104e5380
Switch {
 inputs 2
 name Switch_paint
 label "\[if \{\[value which]==0\} \{return \"LIVE\"\} \{return \"CACHED\"\}]"
 selected true
 xpos 102
 ypos 532
}
Dot {
 name Dot_paint
 label CHARPREFIXUPPER_PAINT
 note_font "Bitstream Vera Sans Bold"
 note_font_size 18
 selected true
 xpos 136
 ypos 629
}
push $N1051fb00
Write {
 channels rgba
 file /media/avoa/None/None/comp/frames/INK_and_PAINT/default/default.%04d.exr
 file_type exr
 first_part rgba
 colorspace rendering
 create_directories true
 ocioColorspace scene_linear
 display ACES
 view Rec.709
 name PAWrite_INK
 label INK
 selected true
 xpos -233
 ypos 448
 addUserKnob {20 User}
 addUserKnob {1 layer_name l "Layer Name"}
 layer_name default
 addUserKnob {1 file_format l "File format string"}
 file_format "/media/\{show\}/\{seq\}/\{shot\}/\{discipline\}/frames/INK_and_PAINT/\{layer_name\}/\{layer_name\}.%04d.exr"
 addUserKnob {1 file_resolved l "File resolved path"}
 file_resolved /media/avoa/None/None/comp/frames/INK_and_PAINT/default/default.%04d.exr
}
</pre>

<div id="COMPLETED PROJECT-PYTHON SCRIPT TO CALL TEMPLATE"><h2 id="PYTHON SCRIPT TO CALL TEMPLATE" class="header"><a href="#COMPLETED PROJECT-PYTHON SCRIPT TO CALL TEMPLATE">PYTHON SCRIPT TO CALL TEMPLATE</a></h2></div>

<pre python>
#####################################################################################
# Description:
#
# Dialog panel to allow for the import of the ink &amp; paint separation template, creating
# an instance for each of the selected characters or provided strings.
#
# This script should be saved here (and subsequently appears in the pmount tools as the file name):
# /shows/avoa/general/data/nuke/nukeToolsManager/Templates/
# Ink_and_Paint_Template.py
#
# The Nuke template should be here:
# /shows/avoa/general/templates/nuke/Tools/
# Ink_Paint_Extraction.nk
#
#
# __author__ = "Rob Holder"
# __date__ = "25/10/10"
# __version__ = "1.0.0"
#
# Version History
# 0.0.1 - 251009 - Initial
# 1.0.0 - 251010 - Sourcing server based Nuke Template
#

import nuke
import contextlib
import io
import os
import re
import stamps
import sys
import tempfile
import uuid
from PySide2.QtWidgets import (QApplication, QDialog, QVBoxLayout,
                               QGridLayout, QPushButton, QLineEdit,
                               QLabel, QHBoxLayout, QSpacerItem, QSizePolicy)
from PySide2.QtCore import Slot, Qt


#---------------------------------- GLOBALS -----------------------------------#

# Path to saved .nk template file:
TEMPLATE_FILE = "/shows/avoa/general/templates/nuke/Tools/Ink_Paint_Extraction.nk"

# List of characters (any additional characters added will appear as additional buttons):
CHARACTERS = [
    "Aang",
    "Katara",
    "Toph",
    "Sokka",
    "Zuko",
    "Tagah",
    "Denied",
    "Sonam",
    "Jie",
    "Kallik",
    "Hong",
    "Yuddah",
    "Appa",
]

CREATED_NODES = []


#------------------------------- PySide2 Dialog -------------------------------#

class CharacterSelectorDialog(QDialog):
    def __init__(self, character_list, parent=None):
        super(CharacterSelectorDialog, self).__init__(parent)
        self.setWindowTitle("Select Characters for Ink &amp; Paint Templates")
        # if using set
        #self.selected_characters = set()
        # if using list (list can remember order of choice)
        self.selected_characters = {}
        self.character_list = character_list

        self.initUI()
        self.apply_styles()

    def initUI(self):
        # Main layout
        main_layout = QVBoxLayout()

        # 1. Character Buttons Layout (Grid)
        main_layout.addWidget(QLabel("Select Characters:"))
        button_layout = QGridLayout()

        self.character_buttons = []
        row, col = 0, 0
        for char_name in self.character_list:
            btn = QPushButton(char_name)
            btn.setCheckable(True)
            btn.setMinimumSize(120, 60)

            # FIX: Prevent character buttons from being default candidates
            btn.setAutoDefault(False)
            btn.setDefault(False)

            btn.toggled.connect(lambda checked, name=char_name: self.on_button_toggled(name, checked))

            button_layout.addWidget(btn, row, col)
            self.character_buttons.append(btn)

            col += 1
            if col &gt; 3:
                col = 0
                row += 1

        main_layout.addLayout(button_layout)

        # 2. Custom Character Input
        main_layout.addWidget(QLabel("\nOr enter custom character names (comma-separated):"))
        self.custom_input = QLineEdit()
        main_layout.addWidget(self.custom_input)

        # 3. Custom OK and Cancel Buttons Layout (Swapped Order)
        button_hbox = QHBoxLayout()
        button_hbox.addItem(QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum))

        # Cancel Button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        self.cancel_button.setAutoDefault(False)
        button_hbox.addWidget(self.cancel_button)

        # OK Button ('Import')
        self.ok_button = QPushButton("Import")
        self.ok_button.clicked.connect(self.accept)
        self.ok_button.setDefault(True)        # Set as the default button
        self.ok_button.setAutoDefault(True)
        button_hbox.addWidget(self.ok_button)

        main_layout.addLayout(button_hbox)
        self.setLayout(main_layout)

        self.custom_input.setFocus() # Set initial focus

    def apply_styles(self):
        """
        Applies QSS styles using a Nuke-like gray theme.
        """
        style_sheet = """
            /* Nuke Default Gray Background */
            QDialog {
                background-color: #303030;
                font-family: sans-serif;
            }

            /* General Button Style */
            QPushButton {
                font-weight: bold; font-size: 14px; padding: 10px;
                border: 1px solid #8f8f8f; border-radius: 4px;
                background-color: #505050;
                color: #FFFFFF;
            }

            /* Checked Character Button Style */
            QPushButton:checked {
                background-color: #4A90D9; /* A distinct blue for selection */
                border: 1px solid #1C3A5A;
            }

            /* Default Button Highlight (Outline) */
            QPushButton:default {
                border: 2px solid #e8901c; /* Gold/Yellow highlight */
                outline: 1px solid #e8901c;
            }

            /* Labels: White text for contrast on gray background */
            QLabel {
                font-weight: bold; font-size: 12px; color: #FFFFFF;
            }

            /* LineEdit Input Field */
            QLineEdit {
                background-color: #3C3C3C;
                color: #FFFFFF;
                border: 1px solid #8f8f8f;
                padding: 5px;
            }
        """
        self.setStyleSheet(style_sheet)

    @Slot(str, bool)
    def on_button_toggled(self, name, checked):
        if checked:
            # Keep checked buttons in the ordered dictionary of selected buttons; True is an arbitrary value
            if name not in self.selected_characters:
                self.selected_characters[name] = True # Add to maintain order; arbitrary value
        else:
            # Remove unchecked button characters.
            if name in self.selected_characters:
               del self.selected_characters[name] # Remove

    def get_selected_results(self):
        # Get the ordered list from the dictionary keys
        results = list(self.selected_characters.keys())

        # Append the typed strings (separated by commas) to the list of characters
        custom_text = self.custom_input.text().strip()
        if custom_text:
            raw_names = [name.strip() for name in custom_text.split(',') if name.strip()]
            custom_names = [re.sub(r" +", "_", name) for name in raw_names]
            # Append custom names that are not already in the list
            for name in custom_names:
                if name not in results:
                    results.append(name)

        return list(results)


#--------------------------------- Functions ----------------------------------#

def get_bbox_of_nodes(selected_nodes):
    """
    Calculates the combined bounding box of all currently selected nodes
    based on their position in the Node Graph (DAG).

    :param selected_nodes (list): A list of nuke.Node objects.
    :return: A dictionary with keys 'x', 'y', 'r', 't' representing the
        combined bounding box min x &amp; y and the right and top limits, or None
        if no nodes are selected.
    """
    if not selected_nodes:
        return None

    # Setup infinite min and max
    x_min, y_min = float('inf'), float('inf')
    x_max, y_max = float('-inf'), float('-inf')

    for node in selected_nodes:
        x = node.xpos()
        y = node.ypos()

        # Node's dimensions to calculate the right and top edges.
        w = node.screenWidth()
        h = node.screenHeight()

        # Right edge and Top edge
        r = x + w
        t = y + h

        x_min = min(x_min, x)
        y_min = min(y_min, y)
        x_max = max(x_max, r)
        y_max = max(y_max, t)

    if x_min == float('inf'):
        return None

    return {'x': x_min, 'y': y_min, 'r': x_max, 't': y_max}


def create_inkpaint_template(template_path, character, replace_map, start_x, start_y, is_first_instance=False):
    """
    Loads a Nuke node network from a template file, performs string replacements,
    and then pastes the modified script.

    :param template_path: Full path to the .nk template file.
    :param character name
    :param replace_map: A dictionary where keys are the placeholder strings
                        and values are the replacement strings.
    :param start_x, start_y: records position to place subsequent imported template
    :param is_first_instance: tracks if initial template import (for position management)
    :return: List of all nodes created by loading the template.
    """
    # Keep track of new nodes to select at the end.
    global CREATED_NODES

    # 1. Read the template file as a string
    try:
        with open(template_path, 'r') as f:
            template_content = f.read()
    except FileNotFoundError:
        nuke.message(f"Error: Template file not found at {template_path}")
        return []

    # 2. Perform string replacements
    modified_content = template_content
    for placeholder, replacement in replace_map.items():
        modified_content = modified_content.replace(placeholder, replacement)

    # 3. Write the modified content to a temporary file
    temp_file = os.path.join(tempfile.gettempdir(), f"nuke_temp_{uuid.uuid4().hex}.nk")
    try:
        with open(temp_file, 'w') as f:
            f.write(modified_content)
    except IOError:
        nuke.message(f"Error: Failed to write to temporary file {temp_file}")
        return []

    #initial_selection = set(nuke.selectedNodes())

    # 4. Load the Template (.nk) from the temp file
    # The actual nuke.nodePaste happens here
    nuke.nodePaste(temp_file)

    # Get all nodes that are NOW selected (i.e., the nodes that were just pasted)
    newly_pasted_nodes = nuke.selectedNodes()

    # Keep track of new nodes to select at end.
    CREATED_NODES.extend(newly_pasted_nodes)

    # 5. Position management

    # Safely exit if template not pasted
    if not newly_pasted_nodes:
            return start_x, start_y

    if is_first_instance:
        # Use Nuke's built-in center function for the first template
        # This will move the nodes to the center of the current view.
        nuke.center()

        # Calculate the next starting position based on the new, centered bounding box
        # The Nuke function dedicated to calculating the bounding box of an iterable of nodes.
        bbox = get_bbox_of_nodes(newly_pasted_nodes)

        # The next X position is the right edge of the centered box + padding
        next_x = bbox['r'] + 100
        next_y = bbox['y']
        #next_y = bbox['t'] # Keep the Y coordinate of the top of the box

    else:
        # For subsequent instances, use the provided start_x, start_y

        # Calculate the bounding box of the newly pasted (selected) nodes
        bbox = get_bbox_of_nodes(newly_pasted_nodes)
        current_min_x = bbox['x']
        current_min_y = bbox['y']

        # Calculate the difference and move the entire selection
        dx = start_x - current_min_x
        dy = start_y - current_min_y
        for node in newly_pasted_nodes:
            # Add the delta (dx, dy) to the node's current position (xpos, ypos)
            new_x = node['xpos'].value() + dx
            new_y = node['ypos'].value() + dy

            node['xpos'].setValue(new_x)
            node['ypos'].setValue(new_y)

        # Get the new bounding box AFTER moving
        moved_bbox = get_bbox_of_nodes(newly_pasted_nodes)
        next_x = moved_bbox['r'] + 100
        next_y = start_y

    # Deselect all the newly pasted nodes
    for node in newly_pasted_nodes:
        node.setSelected(False)

    # 6. Handle Connections and Cleanup (if necessary)

    # I re-wrote this bit from multiple comprehensions and loops.
    # Initialize containers in a single pass
    writes_dict = {}
    reads = []

    # Single pass iteration to categorize all nodes
    for node in newly_pasted_nodes:
        node_class = node.Class()

        if node_class == 'Write':
            # Build Dictionary and Update Write Node in one step
            label = node['label'].value()

            # Crucial Check: Skip if the label is blank
            if not label:
                continue

            # Add to dictionary for later Read matching
            writes_dict[label] = node

            # Update the layer_name based on the label
            if "INK" in label:
                node['layer_name'].setValue(f"{character.upper()}_INK")
            elif "PAINT" in label:
                node['layer_name'].setValue(f"{character.upper()}_PAINT")

        elif node_class == 'Read':
            # Collect Read Nodes ---
            reads.append(node)

    # Update the file path tcl expression to pick up matching write node path
    for read_node in reads:
        read_label = read_node['label'].value()

        # Ignore unlabeled reads:
        if not label:
            continue

        # Check if the Read node's label matches a key (label) in the Write dictionary
        if read_label in writes_dict:
            # Get the Write node object directly from the dictionary lookup
            write_node = writes_dict[read_label]

            # Use the Write node's name to set the Read's file expression
            write_name = write_node['name'].value()
            read_node['file'].setValue(f"[value {write_name}.file]")

    # 7. Add Stamps (Refactored from conditional block to Dictionary Dispatch pattern)
    labels_to_stamps = {
        f"{character.upper()}_INK": f"{character.upper()}_INK",
        f"{character.upper()}_PAINT": f"{character.upper()}_PAINT",
        f"{character.upper()}_ALL": f"{character.upper()}_ALL",
    }

    for node in newly_pasted_nodes:
        node_label = node.knob("label").getValue()

        if node_label in labels_to_stamps:
            stamp_label = labels_to_stamps[node_label]

            node.setSelected(True)

            # Use a context manager to suppress the output (to mute arbitrary error messages)
            # `io.StringIO()` creates an in-memory text buffer that can act like a file.
            with contextlib.redirect_stdout(io.StringIO()), contextlib.redirect_stderr(io.StringIO()):
                # The calls to the stamps module are now "silenced".
                # Any output will be written to the in-memory buffers instead of the console.
                anchor_node = stamps.anchor(stamp_label, "2D")
                # Stamps do not have an 'inpanel=False' option to suppress property panels. Closing instead
                anchor_node.hideControlPanel()
                stamp_node = stamps.stampCreateByTitle(stamp_label)
                stamp_node.hideControlPanel()

            anchor_node.setSelected(False)
            stamp_node.setSelected(False)

            # Keep track of new nodes to select at end.
            CREATED_NODES.extend([anchor_node, stamp_node])

    # 8. Cleanup the temporary file
    if os.path.exists(temp_file):
        os.remove(temp_file)

    return next_x, next_y

def run_template_import(prefixes):

    # PROGRESS BAR: Create the Progress Task
    task = nuke.ProgressTask("Processing Custom Nodes...")

    # PROGRESS BAR: Get potential length of process tasks (to assess progress)
    total_cycles = len(prefixes)

    try:
        # PROGRESS BAR: Check if there are any prefixes to process to avoid division by zero
        if total_cycles == 0:
            task.setMessage("No characteres to process. Done.")
            return

        # Set initial template position
        current_x, current_y = 0, 0

        for i, prefix in enumerate(prefixes):

            # PROGRESS BAR: Check if user has hit cancel button
            if task.isCancelled():
                task.setMessage("Task Cancelled by User.")
                print("Task Cancelled by User.")

                break

            # PROGRESS BAR: Update the status message
            task.setMessage(f"Processing character: {prefix} ({i + 1}/{total_cycles})")

            # PROGRESS BAR: Calculate percentage: (current index + 1) / total items * 100
            progress_percent = int(((i + 1) / total_cycles) * 100)
            task.setProgress(progress_percent)

            # Determine if this is the first template
            is_first = (i == 0)

            # The replacement mapping for the script.
            REPLACEMENT_MAP = {
                'CHARPREFIXLOWER': prefix.lower(),
                'CHARPREFIXUPPER': prefix.upper(),
                'CHARPREFIXTITLE': prefix.title(),
            }

            # --- Explicitly capture the return values ---
            next_template_x, next_template_y = create_inkpaint_template(
                template_path=TEMPLATE_FILE,
                character = prefix,
                replace_map=REPLACEMENT_MAP,
                start_x = current_x,  # Pass the current position
                start_y = current_y,  # Pass the current position
                is_first_instance=is_first,
            )

            # --- Update positions for the next iteration ---
            current_x, current_y = next_template_x, next_template_y

    finally:
        # PROGRESS BAR: Optionally, set the bar to 100% when finished successfully
        if not task.isCancelled():
            task.setProgress(100)
            task.setMessage("Processing Complete.")

        # PROGRESS BAR: close progress bar
        del task

    #print("All template instances created and laid out.")

def launch_character_selector():
    # Keep track of new nodes to select at the end.
    global CREATED_NODES

    # Loop through any existing selection and explicitly deselect each node.
    already_selected = nuke.selectedNodes()

    for node in already_selected:
        node.setSelected(False)

    # Create the dialog instance
    dialog = CharacterSelectorDialog(CHARACTERS)

    # Show the dialog
    result = dialog.exec_()

    # Process the results if the user clicked 'Import' ('OK' or accepted)
    if result == QDialog.Accepted:
        selected_names = dialog.get_selected_results()
        if selected_names:
            # For each character name in selected_names (from dialog):
            run_template_import(selected_names)

            # Select all new nodes for user to be able to move templates
            for node in CREATED_NODES:
                node.setSelected(True)
        else:
            print("No characters selected.")
    else:
        print("Selection canceled.")

    print("The import is done")

# This is for the environment implementation:
def execute():
    launch_character_selector()
</pre>


<p>
<a href="pmount_index.html">PMount</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
