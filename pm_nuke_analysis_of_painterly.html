<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>pm_nuke_analysis_of_painterly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PM</a>
</p>

<div id="Painterly"><h1 id="Painterly" class="header"><a href="#Painterly">Painterly</a></h1></div>


<div id="NVO"><h1 id="NVO" class="header"><a href="#NVO">NVO</a></h1></div>

<div id="NVO-Normalization of P vectors"><h3 id="Normalization of P vectors" class="header"><a href="#NVO-Normalization of P vectors">Normalization of P vectors</a></h3></div>

<div id="NVO-Normalization of P vectors-Red/Le Green/Le"><h4 id="Red/Le Green/Le" class="header"><a href="#NVO-Normalization of P vectors-Red/Le Green/Le">Red/Le Green/Le</a></h4></div>

<p>
This expression is shorthand for normalizing the red and green channels by dividing each by the value of the channel named "Le." In other words, it does the following:
</p>

<ul>
<li>
Le = sqrt((Red*Red) + (Green*Green))+0.00000001

</ul>

<p>
For the red channel, it sets the new value to:
</p>
<ul>
<li>
Red / Le

</ul>

<p>
For the green channel, it sets the new value to:
</p>
<ul>
<li>
Green / Le

</ul>

<div id="NVO-Normalization of P vectors-What It Means"><h4 id="What It Means" class="header"><a href="#NVO-Normalization of P vectors-What It Means">What It Means</a></h4></div>

<p>
Normalization or Unpremultiplication: By dividing the red and green values by another channel (in this case, "Le"), you effectively remove the influence of that channel’s overall intensity. Often in compositing workflows you may want to isolate color information by removing the contribution of luminance or a matte value. If "Le" is serving as a luminance (or even an alpha-like) channel, this operation will leave you with normalized color values.
</p>

<div id="NVO-Normalization of P vectors-Use Cases:"><h4 id="Use Cases:" class="header"><a href="#NVO-Normalization of P vectors-Use Cases:">Use Cases:</a></h4></div>

<ul>
<li>
<span id="NVO-Normalization of P vectors-Use Cases:-Color Correction:"></span><strong id="Color Correction:">Color Correction:</strong> When you need to adjust or balance color channels independently of their brightness.

<li>
<span id="NVO-Normalization of P vectors-Use Cases:-Matte Extraction / Keying:"></span><strong id="Matte Extraction / Keying:">Matte Extraction / Keying:</strong> When "Le" represents a luma or matte channel that you want to use to drive further operations, dividing by it can help separate pure color data.

<li>
<span id="NVO-Normalization of P vectors-Use Cases:-Unpremultiplication:"></span><strong id="Unpremultiplication:">Unpremultiplication:</strong> A similar concept where colors are divided by an alpha channel to undo the premultiply (though here the channel is named “Le” instead of “alpha”).

</ul>

<div id="NVO-Normalization of P vectors-Example Scenario"><h4 id="Example Scenario" class="header"><a href="#NVO-Normalization of P vectors-Example Scenario">Example Scenario</a></h4></div>

<p>
Imagine you have a layer where the intensity of a light (or a matte) is stored in the "Le" channel. By computing:
</p>

<ul>
<li>
Red = Red / Le

<li>
Green = Green / Le

</ul>

<p>
You remove the influence of that intensity from the red and green channels. The result is a set of color ratios that can be used for further processing—perhaps to reintroduce a controlled amount of that light later on or to drive a keying process that is independent of the brightness variations.
</p>

<div id="NVO-Normalization of P vectors-In summary, the expressions:"><h4 id="In summary, the expressions:" class="header"><a href="#NVO-Normalization of P vectors-In summary, the expressions:">In summary, the expressions:</a></h4></div>

<pre plaintext>
Red/Le
Green/Le
</pre>

<p>
...in a Nuke Expression node adjust the red and green channels by dividing them by the "Le" channel, effectively normalizing these channels to isolate color information from overall intensity.
</p>

<div id="NVO-The Le Expression"><h3 id="The Le Expression" class="header"><a href="#NVO-The Le Expression">The Le Expression</a></h3></div>

<p>
This expression calculates the magnitude of the red/green vector and adds a tiny offset to prevent division by zero. Here's a breakdown:
</p>

<ul>
<li>
sqrt((Red*Red) + (Green*Green)): This part computes the Euclidean distance (or length) of the vector formed by the Red and Green channels. In other words, it takes the square root of the sum of the squares of Red and Green values. This is analogous to calculating the hypotenuse of a right triangle, where the legs are the Red and Green values.

<li>
+ 0.00000001: The extremely small number is added to ensure that Le never becomes exactly zero. This is important because if you later divide by Le (like in your expressions for Red/Le and Green/Le), you want to avoid a division-by-zero error.

</ul>

<div id="NVO-The Le Expression-What It Achieves Overall"><h4 id="What It Achieves Overall" class="header"><a href="#NVO-The Le Expression-What It Achieves Overall">What It Achieves Overall</a></h4></div>

<p>
By defining Le in this way, you create a measure of the overall intensity or "length" of the color vector in the red-green plane. When you use it to normalize the red and green channels (by dividing each by Le), you obtain the directional information independent of the magnitude. This is useful for operations like:
</p>

<ul>
<li>
<span id="NVO-The Le Expression-What It Achieves Overall-Normalization:"></span><strong id="Normalization:">Normalization:</strong> Isolating color direction regardless of intensity.

<li>
<span id="NVO-The Le Expression-What It Achieves Overall-Unpremultiplying:"></span><strong id="Unpremultiplying:">Unpremultiplying:</strong> Removing the influence of brightness or a particular matte.

</ul>

<p>
This approach is common in compositing or image processing tasks where you might need to re-map or adjust color values more robustly.
</p>

<div id="fbm_noise"><h1 id="fbm_noise" class="header"><a href="#fbm_noise">fbm_noise</a></h1></div>

<div id="fbm_noise-See page on fBm:"><h4 id="See page on fBm:" class="header"><a href="#fbm_noise-See page on fBm:">See page on fBm:</a></h4></div>
<ul>
<li>
<a href="nuke_expressions_fbm.html">Nuke - Fractional Brownian Motion (fBm)</a>

</ul>

<p>
This expression is calling a fractional Brownian motion (fBm) noise function with inputs that let you customize the noise’s appearance based on coordinates and various parameters. Here’s a step-by-step breakdown:
</p>

<div id="fbm_noise-The Expression"><h2 id="The Expression" class="header"><a href="#fbm_noise-The Expression">The Expression</a></h2></div>

<pre plaintext>
fBm(r*xScale/globalScale + pos.x,  g*yScale/globalScale + pos.y,  b*zScale/globalScale + pos.z,  oct, lac, gain)
</pre>

<div id="fbm_noise-The Expression-Breaking Down the Components"><h4 id="Breaking Down the Components" class="header"><a href="#fbm_noise-The Expression-Breaking Down the Components">Breaking Down the Components</a></h4></div>

<p>
Coordinate Transformation:
</p>

<ul>
<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-r, g, b:"></span><strong id="r, g, b:">r, g, b:</strong> These typically represent your base coordinate values or channel values. Although their names imply “color” channels, in many noise setups they are repurposed as the x, y, and z spatial coordinates.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-xScale, yScale, zScale:"></span><strong id="xScale, yScale, zScale:">xScale, yScale, zScale:</strong> These factors scale the corresponding coordinate axes. By adjusting them, you change the “frequency” or “detail” of the noise along each axis.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-globalScale:"></span><strong id="globalScale:">globalScale:</strong> Dividing by globalScale normalizes or adjusts the overall scale of the noise. This lets you control the noise granularity on a global level.

</ul>

<ul>
<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-pos.x, pos.y, pos.z:"></span><strong id="pos.x, pos.y, pos.z:">pos.x, pos.y, pos.z:</strong> These are offset values (position offsets) added to the respective coordinates. They shift the input domain of the noise function, essentially “moving” the noise pattern in space.

</ul>

<p>
fBm Noise Function Parameters:
</p>

<ul>
<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-oct:"></span><strong id="oct:">oct:</strong> Short for “octaves,” this parameter defines how many layers (or frequency iterations) of noise to combine. More octaves usually mean more detail and complexity in the final noise.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-lac:"></span><strong id="lac:">lac:</strong> This represents “lacunarity,” which determines the frequency multiplier between successive octaves. It controls how quickly the frequency increases as you add higher levels of detail.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-gain:"></span><strong id="gain:">gain:</strong> This governs the amplitude scaling between octaves. It tells you how much each successive octave contributes relative to the previous one, affecting the overall contrast and "roughness" of the noise.

</ul>

<div id="fbm_noise-The Expression-What the Expression Achieves"><h3 id="What the Expression Achieves" class="header"><a href="#fbm_noise-The Expression-What the Expression Achieves">What the Expression Achieves</a></h3></div>

<ul>
<li>
<span id="fbm_noise-The Expression-What the Expression Achieves-Customizable Noise Texture:"></span><strong id="Customizable Noise Texture:">Customizable Noise Texture:</strong> By combining scaled and offset coordinates with multiple octaves of noise, the function generates a detailed, fractal-like noise pattern. Adjusting xScale, globalScale, and the other parameters lets you tailor the noise—from gentle turbulence to high-frequency textural detail.

<li>
<span id="fbm_noise-The Expression-What the Expression Achieves-Seamless Control Over Appearance:"></span><strong id="Seamless Control Over Appearance:">Seamless Control Over Appearance:</strong> The use of coordinate scaling and offsets (pos.x/y/z) means you can precisely position and resize the noise’s features. The parameters oct, lac, and gain allow you to dial in the complexity and visual roughness, making this a very flexible tool in your compositing workflow.

</ul>

<p>
Practical Use in Nuke
</p>

<p>
You might connect this fBm expression to drive procedural texture effects, displacement maps, or create natural-looking randomness in effects like clouds, rust, or surface imperfections. Because the transformation is fully parameterized, you can animate the position or adjust the scales over time to create dynamic, evolving noise.
</p>

<p>
This expression is a compact, yet powerful way to leverage procedural (fractal) noise in Nuke. Let me know if you’d like to explore further examples, such as how to incorporate time-based variations or combine multiple noise layers for even more intricate effects!
</p>

<div id="Color Matrix"><h1 id="Color Matrix" class="header"><a href="#Color Matrix">Color Matrix</a></h1></div>

<p>
Let's break down what the 3×3 matrix is doing when you use it to adjust the vector direction of your noise:
</p>

<p>
Imagine your input is treated as a 3‑component vector 
</p>

<pre plaintext>
[ 𝑥 , 𝑦 , 𝑧 ].
</pre>

<p>
In your case, you're only interested in a 2D transformation—the components corresponding to <code>𝑥</code> and <code>𝑦.</code> Your matrix is set up so that only the first two rows and the first two columns are active. In other words, your matrix looks something like this:
</p>

<pre plaintext>
[ 𝑎 𝑏 0 ]
[ 𝑐 𝑑 0 ]
[ 0 0 0 ]
</pre>

<ul>
<li>
Row 1 (cells <code>[ 𝑎 , 𝑏 , 0 ]</code>) -  This row defines how the output’s first component (let’s call it the transformed <code>𝑥</code>) is calculated from the input vector:

</ul>
  
<pre plaintext>
𝑥′ = 𝑎 × 𝑥 + 𝑏 × 𝑦
</pre>

<p>
You have two cells activated here (the multipliers for the <code>𝑥</code> and <code>𝑦</code> inputs), which you can adjust to control the contribution of the original <code>𝑥</code> and <code>𝑦</code> to the new <code>𝑥</code> .
</p>

<p>
Row 2 (cells <code>[ 𝑐 , 𝑑 , 0 ]</code>) - This row defines the output’s second component (the transformed <code>𝑦):</code>
</p>
<pre plaintext>
𝑦 ′ = 𝑐 × 𝑥 + 𝑑 × 𝑦
</pre>

<p>
Again, only the first two cells here are active. Changing these values lets you control how the original <code>𝑥</code> and <code>𝑦</code> mix to produce the new <code>𝑦.</code>
</p>

<ul>
<li>
Row 3 (all cells set to zero) Since row 3 is entirely zero, the third output channel (or the <code>𝑧</code> component) is forced to 0, meaning it plays no role in your transformation.

<li>
Column 3 (all zeros) Having zeros in column three means that the third component of your input (whatever is stored there) doesn't contribute to either the transformed <code>𝑥</code> or <code>𝑦</code> outputs.

</ul>

<div id="Color Matrix-What This Accomplishes"><h3 id="What This Accomplishes" class="header"><a href="#Color Matrix-What This Accomplishes">What This Accomplishes</a></h3></div>

<p>
2D Linear Transformation: By only using a 2×2 submatrix from the overall 3×3 matrix, you’re effectively applying a linear transformation (rotation, scaling, or shearing) to your 2D coordinates (the <code>𝑥</code> and <code>𝑦</code> inputs). For example, if you set your active cells to:
</p>

<ul>
<li>
𝑎 = cos𝜃

<li>
𝑏 = − sin𝜃

<li>
𝑐 = sin𝜃

<li>
𝑑 = cos𝜃

</ul>

<p>
...then you’re rotating your noise’s vector by an angle <code>𝜃.</code>
</p>

<ul>
<li>
<span id="Color Matrix-What This Accomplishes-Isolating the 2D Behavior:"></span><strong id="Isolating the 2D Behavior:">Isolating the 2D Behavior:</strong> The fact that all of column three and all of row three are zero means you intentionally ignore any third-channel data (such as a z component or an additional parameter). This is typical when your effect is solely based on 2D behavior (such as tiling or directional noise in a plane).

<li>
<span id="Color Matrix-What This Accomplishes-Control Over Vector Direction:"></span><strong id="Control Over Vector Direction:">Control Over Vector Direction:</strong> You can fine-tune the exact behavior of your noise’s directional properties by adjusting the active cells. For instance, you might not only rotate the vector but also scale it (by changing the magnitude of <code>𝑎</code>, <code>𝑏</code>, <code>𝑐</code>, and <code>𝑑)</code> to achieve the desired intensity or sharpness in your noise pattern.

</ul>

<div id="Color Matrix-What This Accomplishes-In Summary"><h4 id="In Summary" class="header"><a href="#Color Matrix-What This Accomplishes-In Summary">In Summary</a></h4></div>

<p>
Your 3×3 ColorMatrix in the context of adjusting noise is functioning as a 2D transformation tool:
</p>

<ul>
<li>
The first row’s two active cells control how much of the original <code>𝑥</code> and <code>𝑦</code> contribute to the new <code>𝑥</code>

<li>
The second row’s two active cells handle the contribution to the new <code>𝑦.</code>

<li>
Everything else (the entire third row and column three) is set to zero to effectively isolate and ignore any additional data outside the 2D transformation.

</ul>

<p>
This approach is a common technique to adjust the vector direction of noise, allowing for precise control over how your noise pattern is oriented and scaled in the 2D space.
</p>

<div id="Expressions on Painterly Nodes"><h1 id="Expressions on Painterly Nodes" class="header"><a href="#Expressions on Painterly Nodes">Expressions on Painterly Nodes</a></h1></div>

<pre python>
Switch2 -&gt; 'parent.ViewMode'
Blur1 -&gt; 'parent.Blur'
VectorBlur1 -&gt; 'parent.SmearIntensity*50'
VectorBlur1 -&gt; 'parent.SmearOpacity'
IDistort1 -&gt; 'parent.IDistort1_uv_offset'
IDistort1 -&gt; 'parent.IDistort1_uv_scale.w'
IDistort1 -&gt; 'parent.IDistort1_uv_scale.h'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.0'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.1'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.4'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.5'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.0'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.1'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.4'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.5'
Blur12 -&gt; 'parent.Softness'
Merge3 -&gt; 'parent.SmearNormals'
Switch6 -&gt; 'parent.Mask'
Reformat4 -&gt; 'Reformat1.type'
Reformat4 -&gt; 'Reformat1.box_width'
Reformat4 -&gt; 'Reformat1.box_height'
Reformat4 -&gt; 'Reformat1.box_fixed'
Reformat4 -&gt; 'Reformat1.box_pixel_aspect'
Reformat4 -&gt; 'Reformat1.scale'
Reformat4 -&gt; 'Reformat1.resize'
Reformat4 -&gt; 'Reformat1.center'
Reformat4 -&gt; 'Reformat1.flip'
Reformat4 -&gt; 'Reformat1.flop'
Reformat4 -&gt; 'Reformat1.turn'
Reformat4 -&gt; 'Reformat1.filter'
Reformat4 -&gt; 'Reformat1.clamp'
Reformat4 -&gt; 'Reformat1.black_outside'
Reformat4 -&gt; 'Reformat1.pbb'
Reformat4 -&gt; 'Reformat1.disable'
Switch7 -&gt; 'parent.ViewMode'
Blur12 -&gt; 'parent.Softness'
Switch1 -&gt; 'parent.NoiseType'
Clamp2 -&gt; '1-parent.ClampValues'
Unpremult1 -&gt; '1-parent.Unpremult1_disable'
UDIM_SELECT -&gt; 'parent.UDIM_SELECT_whitepoint'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.globalScale'
Noise2 -&gt; 'parent.NoiseSeed+1000'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.oct'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.lac'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.gain'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.globalScale'
Noise1 -&gt; 'parent.NoiseSeed+2000'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.oct'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.lac'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.gain'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.globalScale'
Noise3 -&gt; 'parent.NoiseSeed'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.oct'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.lac'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.gain'
TriPlanar -&gt; 'fbm_3dNoise1.pos'
TriPlanar -&gt; 'fbm_3dNoise1.pos'
TriPlanar -&gt; 'fbm_3dNoise1.pos'
Switch3 -&gt; 'parent.DistortEdgesOnly'
Switch5 -&gt; 'parent.SmearEdgesOnly'
Switch4 -&gt; 'parent.BlurEdgesOnly'
Blur4 -&gt; 'parent.EdgeSoftness'
Erode1 -&gt; '-(parent.EdgeThickness)+1'
EdgeDetect2 -&gt; 'parent.EdgeThreshold'
Reformat1 -&gt; 'input.bbox.r-input.bbox.x'
Reformat1 -&gt; 'input.bbox.t-input.bbox.y'
Clamp2 -&gt; '1-parent.ClampValues'
Reformat2 -&gt; 'Reformat1.type'
Reformat2 -&gt; 'Reformat1.box_width'
Reformat2 -&gt; 'Reformat1.box_height'
Reformat2 -&gt; 'Reformat1.box_fixed'
Reformat2 -&gt; 'Reformat1.box_pixel_aspect'
Reformat2 -&gt; 'Reformat1.scale'
Reformat2 -&gt; 'Reformat1.resize'
Reformat2 -&gt; 'Reformat1.center'
Reformat2 -&gt; 'Reformat1.flip'
Reformat2 -&gt; 'Reformat1.flop'
Reformat2 -&gt; 'Reformat1.turn'
Reformat2 -&gt; 'Reformat1.filter'
Reformat2 -&gt; 'Reformat1.clamp'
Reformat2 -&gt; 'Reformat1.black_outside'
Reformat2 -&gt; 'Reformat1.pbb'
Reformat2 -&gt; 'Reformat1.disable'
Axis1 -&gt; 'parent.SmearDirection*180'
</pre>

<div id="Reformat with Expressions on Pulldowns"><h1 id="Reformat with Expressions on Pulldowns" class="header"><a href="#Reformat with Expressions on Pulldowns">Reformat with Expressions on Pulldowns</a></h1></div>

<p>
Pulldowns on standard property tabs for tools don't seem to allow for expression assignment to pulldown menus. However, some nodes in the FB tools DO have expressions binding them to other nodes.
</p>

<p>
I found the best way (other than setting via Python) is to edit them in the Nuke file with the following syntax:
</p>

<p>
<code>Reformat</code> is the 'new' driven node in this case, and <code>Reformat1</code> is the 'parent' or driver node:
</p>

<pre nuke>
Reformat {
 type {{Reformat1.type}}
 format {{{Reformat1.format}}}
 box_width {{Reformat1.box_width}}
 box_height {{Reformat1.box_height}}
 box_fixed {{Reformat1.box_fixed}}
 box_pixel_aspect {{Reformat1.box_pixel_aspect}}
 scale {{Reformat1.scale}}
 resize {{Reformat1.resize}}
 center {{Reformat1.center}}
 flip {{Reformat1.flip}}
 flop {{Reformat1.flop}}
 turn {{Reformat1.turn}}
 filter {{Reformat1.filter}}
 clamp {{Reformat1.clamp}}
 black_outside {{Reformat1.black_outside}}
 pbb {{Reformat1.pbb}}
 name Reformat2
 disable {{Reformat1.disable}}
}
</pre>

<p>
Alternatively, just clone - but this was an interesting case to see (and how to replicate).
</p>


<div id="fBm Noise Formula"><h1 id="fBm Noise Formula" class="header"><a href="#fBm Noise Formula">fBm Noise Formula</a></h1></div>

<p>
Breakdown of the fBm Noise Formula on the customized Expression node, HueNoise_controls:
</p>

<div id="fBm Noise Formula-Red"><h4 id="Red" class="header"><a href="#fBm Noise Formula-Red">Red</a></h4></div>

<pre nuke>
set cut_paste_input [stack 0]
version 15.0 v7
push $cut_paste_input
Expression {
 channel0 rgb
 expr0 fBm(r*xScale/globalScale+pos.x,g*yScale/globalScale+pos.y,b*zScale/globalScale+pos.z,oct,lac,gain)
 name HueNoise_controls
 selected true
 xpos 376
 ypos 438
 addUserKnob {20 User}
 addUserKnob {13 pos}
 pos {1850 925 0}
 addUserKnob {7 globalScale R 0 10}
 globalScale 15
 addUserKnob {7 yScale R 0 5}
 yScale 0.5
 addUserKnob {7 xScale R 0 5}
 xScale 0.5
 addUserKnob {7 zScale R 0 5}
 zScale 0.5
 addUserKnob {7 oct R 0 10}
 oct 10
 addUserKnob {7 lac R 0 5}
 lac 3.82
 addUserKnob {7 gain R 0 2}
 gain 0.5
}
</pre>

<div id="fBm Noise Formula-Green"><h4 id="Green" class="header"><a href="#fBm Noise Formula-Green">Green</a></h4></div>

<p>
As <code>Red</code> but with:
</p>
<pre nuke>
 pos {{parent.HueNoise_controls.pos} {parent.HueNoise_controls.pos-1000} {parent.HueNoise_controls.pos}}
</pre>

<div id="fBm Noise Formula-Blue"><h4 id="Blue" class="header"><a href="#fBm Noise Formula-Blue">Blue</a></h4></div>

<p>
As <code>Red</code> but with:
</p>
<pre nuke>
 pos {{parent.HueNoise_controls.pos} {parent.HueNoise_controls.pos+1000} {parent.HueNoise_controls.pos}}
</pre>

<div id="fBm Noise Formula-Generic Formula"><h4 id="Generic Formula" class="header"><a href="#fBm Noise Formula-Generic Formula">Generic Formula</a></h4></div>

<p>
Below is the generic form of the formula, with each term named rather than hard-coded:
</p>

<pre text>
noise = fBm(
  x,
  y,
  z,
  octaves,
  lacunarity,
  gain
)
</pre>

<div id="fBm Noise Formula-Term Definitions"><h2 id="Term Definitions" class="header"><a href="#fBm Noise Formula-Term Definitions">Term Definitions</a></h2></div>

<ul>
<li>
x, y, z the three coordinates at which you sample the noise field.

<li>
octaves how many layers of noise are summed together.

<li>
lacunarity the factor by which frequency increases each octave.

<li>
gain the factor by which amplitude decreases each octave.

<li>
fBm fractal Brownian motion, a function that combines multiple noise layers to produce natural, continuous randomness.

</ul>

<div id="fBm Noise Formula-Layman’s Descriptions"><h2 id="Layman’s Descriptions" class="header"><a href="#fBm Noise Formula-Layman’s Descriptions">Layman’s Descriptions</a></h2></div>

<ul>
<li>
<span id="fBm Noise Formula-Layman’s Descriptions-octaves:"></span><strong id="octaves:">octaves:</strong> imagine stacking several sheets of paper, each with finer wrinkles—more octaves means more detailed wrinkles.

<li>
<span id="fBm Noise Formula-Layman’s Descriptions-lacunarity:"></span><strong id="lacunarity:">lacunarity:</strong> controls how much smaller each new sheet’s wrinkles are compared to the last.

<li>
<span id="fBm Noise Formula-Layman’s Descriptions-gain:"></span><strong id="gain:">gain:</strong> controls how faint each new sheet’s wrinkles appear compared to the previous one.

</ul>

<div id="fBm Noise Formula-Mapping to the Painterly Example"><h2 id="Mapping to the Painterly Example" class="header"><a href="#fBm Noise Formula-Mapping to the Painterly Example">Mapping to the Painterly Example</a></h2></div>
<p>
In the Red-channel expression, the coordinates x, y, z are driven by the pixel color and user knobs:
</p>

<pre text>
x = (r * xScale / globalScale) + pos.x  
y = (g * yScale / globalScale) + pos.y  
z = (b * zScale / globalScale) + pos.z
</pre>

<ul>
<li>
r, g, b incoming pixel’s red, green, blue values (0–1).

<li>
xScale, yScale, zScale how strongly each color channel stretches its noise axis.

<li>
globalScale common divisor to keep overall noise frequency in check.

<li>
pos.x, pos.y, pos.z user-controlled offsets panning the noise field in each dimension.

</ul>

<div id="fBm Noise Formula-What are xScale, yScale, zScale and globalScale?"><h2 id="What are xScale, yScale, zScale and globalScale?" class="header"><a href="#fBm Noise Formula-What are xScale, yScale, zScale and globalScale?">What are xScale, yScale, zScale and globalScale?</a></h2></div>

<p>
xScale, yScale, zScale and globalScale aren’t magic built-ins—they’re just user knobs on that Expression node (or on the gizmo wrapping it). When you write
</p>

<pre text>
fBm(
  (r*xScale/globalScale) + pos.x,
   …
)
</pre>

<p>
Nuke looks for knobs named <code>xScale</code> and <code>globalScale</code> on that same node and plugs their numeric values into the expression.
</p>

<p>
Here’s what each represents, and how to inspect or add them:
</p>

<ul>
<li>
xScale, yScale, zScale

<ul>
<li>
What they do: stretch or squash how much each color channel (R, G, B) contributes to the noise’s X, Y, Z coordinates.

<li>
Where they come from: custom Float knobs you (or the gizmo’s author) added to the node.

</ul>
</ul>

<ul>
<li>
globalScale

<ul>
<li>
What it does: a single divisor to keep the overall noise frequency in check, so you don’t have to tweak all three axis-scales when you want higher or lower detail.

<li>
Where it comes from: another custom Float knob on the same node.

</ul>
</ul>

<div id="fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-How to see or add them:"><h4 id="How to see or add them:" class="header"><a href="#fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-How to see or add them:">How to see or add them:</a></h4></div>

<ul>
<li>
Select your Expression node and open Manage User Knobs…

<li>
You should see knobs named xScale, yScale, zScale, globalScale (and maybe pos.x, pos.y, pos.z) in the list.

<li>
If they’re missing, click Add… → Float Knob, name it exactly xScale (no spaces), give it a default (e.g. 1.0), then repeat for globalScale, etc.

<li>
Hit OK. Now those knobs appear in your node’s properties and feed their values into the fBm formula.

</ul>

<p>
In short:
</p>
<ul>
<li>
xScale and globalScale are node-level parameters you (or a gizmo) must define.

<li>
Nuke reads their current values when evaluating the fBm expression.

<li>
Tweak xScale to bias noise along the R-axis, and tweak globalScale to zoom the entire noise pattern in or out.P

</ul>

<div id="fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-Putting it all together:"><h3 id="Putting it all together:" class="header"><a href="#fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-Putting it all together:">Putting it all together:</a></h3></div>

<pre text>
noise = fBm(
  (r*xScale/globalScale) + pos.x,
  (g*yScale/globalScale) + pos.y,
  (b*zScale/globalScale) + pos.z,
  octaves,
  lacunarity,
  gain
)
</pre>

<p>
This generates a procedural noise value in the Red channel, keyed to your image content and tuned by the octaves, lacunarity, and gain knobs.
</p>


<div id="UDIM Passes &amp; Noise"><h1 id="UDIM Passes &amp; Noise" class="header"><a href="#UDIM Passes &amp; Noise">UDIM Passes &amp; Noise</a></h1></div>

<div id="UDIM Passes &amp; Noise-What a UDIM‐based UV Pass Looks Like"><h4 id="What a UDIM‐based UV Pass Looks Like" class="header"><a href="#UDIM Passes &amp; Noise-What a UDIM‐based UV Pass Looks Like">What a UDIM‐based UV Pass Looks Like</a></h4></div>

<p>
A “UV pass” from your renderer is simply an image where each pixel’s red and green channels encode its U and V coordinates on the model. When you use UDIM tiling, those UVs aren’t constrained to 0–1—you’ll see values stepping up into 1–2, 2–3, and so on, depending on the tile.
</p>

<div id="UDIM Passes &amp; Noise-UDIM Tile Layout"><h3 id="UDIM Tile Layout" class="header"><a href="#UDIM Passes &amp; Noise-UDIM Tile Layout">UDIM Tile Layout</a></h3></div>

<p>
UDIM numbers start at 1001 in the lower‐left tile and increase to the right and then upward in rows of ten. Visually:
</p>

<pre text>
Row y=1:  1011 1012 1013 …  
Row y=0:  1001 1002 1003 …   ← V between 0–1
           ↑U =0–1   1–2   2–3
</pre>

<ul>
<li>
Tile 1001 has UVs U∈[0,1), V∈[0,1).

<li>
Tile 1002 has U∈[1,2), V∈[0,1).

<li>
Tile 1011 has U∈[0,1), V∈[1,2).

</ul>

<div id="UDIM Passes &amp; Noise-UDIM Tile Layout-The “∈” Symbol"><h4 id="The “∈” Symbol" class="header"><a href="#UDIM Passes &amp; Noise-UDIM Tile Layout-The “∈” Symbol">The “∈” Symbol</a></h4></div>

<p>
The symbol <code>∈</code> means “is an element of” or “belongs to” in set theory.
</p>

<p>
For example: <code>3 ∈ {1, 2, 3, 4}</code> reads “3 is an element of the set {1, 2, 3, 4}.”
</p>

<div id="UDIM Passes &amp; Noise-How That Appears in Your UV Pass"><h3 id="How That Appears in Your UV Pass" class="header"><a href="#UDIM Passes &amp; Noise-How That Appears in Your UV Pass">How That Appears in Your UV Pass</a></h3></div>

<p>
In the render:
</p>

<ul>
<li>
U channel (R in your UV pass)

<ul>
<li>
On tile 1001: values range 0.0→1.0 (dark to bright in red channel).

<li>
On tile 1002: values range 1.0→2.0 (even brighter).

<li>
On tile 1003: 2.0→3.0, etc.

</ul>
</ul>

<ul>
<li>
V channel (G in your UV pass) works the same vertically.

</ul>

<p>
There’s no special “brightness” hack per tile—pixels simply carry the raw U, V numbers that tell you exactly which UDIM tile and where within it each point lives.
</p>

<div id="UDIM Passes &amp; Noise-Why This Matters in Compositing"><h3 id="Why This Matters in Compositing" class="header"><a href="#UDIM Passes &amp; Noise-Why This Matters in Compositing">Why This Matters in Compositing</a></h3></div>

<ul>
<li>
<span id="UDIM Passes &amp; Noise-Why This Matters in Compositing-Identify the tile:"></span><strong id="Identify the tile:">Identify the tile:</strong> floor(U) and floor(V) give you the tile’s X and Y index (e.g. U=4.2 → tile X=4 ⇒ 1001+4 = 1005).

<li>
<span id="UDIM Passes &amp; Noise-Why This Matters in Compositing-Reconstruct UDIM number:"></span><strong id="Reconstruct UDIM number:">Reconstruct UDIM number:</strong> UDIM = 1001 + floor(U) + floor(V)×10

<li>
<span id="UDIM Passes &amp; Noise-Why This Matters in Compositing-Sample per‐tile sources:"></span><strong id="Sample per‐tile sources:">Sample per‐tile sources:</strong> Using an STMap or UVTile node, these absolute UVs drive look-ups so that each pixel fetches the right UDIM tile of your textures.

</ul>

<div id="UDIM Passes &amp; Noise-Why This Matters in Compositing-So—does each UDIM show up as a “brighter” band?"><h4 id="So—does each UDIM show up as a “brighter” band?" class="header"><a href="#UDIM Passes &amp; Noise-Why This Matters in Compositing-So—does each UDIM show up as a “brighter” band?">So—does each UDIM show up as a “brighter” band?</a></h4></div>

<p>
Sort of—but that brightness isn’t artistic, it’s numeric:
</p>

<ul>
<li>
A pixel in UDIM 1001 might have U = 0.3 → R=0.3 (dark red).

<li>
In UDIM 1002 at the same local U (0.3) it will be R=1.3 (brighter red).

</ul>

<p>
That jump is simply the coordinate stepping into the next tile, not a coded “pass label.” You then use those values to drive your STMap/UVTile logic so the right texture tile is sampled.
</p>

<div id="UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)"><h3 id="In the Comp - The Grade Node (Whitepoint)" class="header"><a href="#UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)">In the Comp - The Grade Node (Whitepoint)</a></h3></div>

<p>
The tooltip says:
</p>

<table>
<tr>
<td>
"Set the clamp to the number of UDIMS in the scene geometry. Larger numbers will reduce fidelity, but ensure coverage of all geo."
</td>
</tr>
</table>

<p>
The tooltip really nails it: that Grade is not there to recolor—it's acting as a “clamp &amp; scale” on your UV‐pass so that the STMap node drives the noise sampler over exactly the UDIM range you care about.
</p>

<div id="UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Here’s the step-by-step in the setup:"><h5 id="Here’s the step-by-step in the setup:" class="header"><a href="#UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Here’s the step-by-step in the setup:">Here’s the step-by-step in the setup:</a></h5></div>

<ul>
<li>
The CG render emits a UV pass where each pixel’s R and G are the U,V coordinates.

<li>
You pipe that UV pass through a Grade node, using the whitepoint slider as a clamp/scale value.

<ul>
<li>
Grade’s whitepoint defines the input value that maps to output = 1.0 (anything above it gets clipped to 1).

<li>
By setting whitepoint = N (the number of UDIM tiles in your scene), you effectively remap UVs from [0…N] → [0…1] and clamp anything above N down to 1.

</ul>
<li>
That graded result goes into STMap’s stmap input. STMap then interprets those normalized U &amp; V channels as “where in the noise texture to sample.”

<li>
The noise node in STMap’s src sees a UV map that covers [0…1] exactly once for each tile in the UDIM space you specified.

</ul>

<div id="UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Why this matters:"><h4 id="Why this matters:" class="header"><a href="#UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Why this matters:">Why this matters:</a></h4></div>

<ul>
<li>
If you set whitepoint too low, any UVs outside that range will all collapse to 1—so large chunks of geometry end up sampling the same noise.

<li>
If you set it too high, you spread the [0…1] noise domain across many UDIMs, giving each tile less noise detail (reduced fidelity).

<li>
By matching whitepoint to your UDIM count, you ensure each tile sees the full [0…1] noise sweep exactly once, with no out-of-range UVs sampling “blank” areas.

</ul>

<p>
In short, that Grade’s whitepoint knob is a quick “map your 0→UDIM-space UVs into a 0→1 domain for STMap” so your procedural noise tiles correctly over all of your scene’s geometry.
</p>


<div id="Node by Node"><h1 id="Node by Node" class="header"><a href="#Node by Node">Node by Node</a></h1></div>

<p>
Image input
</p>
<ul>
<li>
Clamp (clone):

<ul>
<li>
'P' ('Pref'?) channel for rgba

<li>
This is an optional clamp value of:

<ul>
<li>
min: -1_000_000

<li>
max:  1_000_000

</ul>
<li>
Expression to group

</ul>
<li>
Dot:

<ul>
<li>
essentially a label:

<ul>
<li>
	input format : [value input.format.width]x[value input.format.height]

</ul>
</ul>
<li>
Dot:

<ul>
<li>
essentially a label:

<ul>
<li>
	input overscan : [expr [value input.bbox.r] - [value input.bbox.x]]x[expr [value input.bbox.t] - [value input.bbox.y]]

</ul>
</ul>
<li>
Reformat:

<ul>
<li>
This is the driver for other Reformats (mask, etc.)

<li>
input.bbox.r - input.bbox.x (get width based on right coord minus left bounding box)

<li>
input.bbox.t - input.bbox.y (get height based on bottom coord minus top bounding box)

<li>
type: to box

<li>
resize type: none, center

</ul>
<li>
Backtrack to a Constant:

<ul>
<li>
Constant size: 4000 x 4000

<li>
RGB (set to black)

<li>
Expression driven on all knobs to image Reformat node (tied to the image reformat)

</ul>
<li>
Merge:

<ul>
<li>
B - Image

<li>
A - Constant via Reformat

<li>
Mix set to zero (so no color influence).

<li>
Ensures stream integrity. 

</ul>
</ul>

<div id="3d Noise Group"><h1 id="3d Noise Group" class="header"><a href="#3d Noise Group">3d Noise Group</a></h1></div>

<ul>
<li>
HueNoise_control:

<ul>
<li>
This is a customized <code>Expression</code> node, with 'User' knobs for variables for an fBm formula

<li>
See above for explanation.

</ul>
</ul>
<p>
<a href="pmount_index.html">PM</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
