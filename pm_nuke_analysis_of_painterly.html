<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_nuke_analysis_of_painterly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PM</a>
</p>

<div id="Painterly"><h1 id="Painterly" class="header"><a href="#Painterly">Painterly</a></h1></div>


<div id="NVO"><h1 id="NVO" class="header"><a href="#NVO">NVO</a></h1></div>

<div id="NVO-Normalization of P vectors"><h3 id="Normalization of P vectors" class="header"><a href="#NVO-Normalization of P vectors">Normalization of P vectors</a></h3></div>

<div id="NVO-Normalization of P vectors-Red/Le Green/Le"><h4 id="Red/Le Green/Le" class="header"><a href="#NVO-Normalization of P vectors-Red/Le Green/Le">Red/Le Green/Le</a></h4></div>

<p>
This expression is shorthand for normalizing the red and green channels by dividing each by the value of the channel named "Le." In other words, it does the following:
</p>

<ul>
<li>
Le = sqrt((Red*Red) + (Green*Green))+0.00000001

</ul>
<p>
For the red channel, it sets the new value to:
</p>
<ul>
<li>
Red / Le

</ul>
<p>
For the green channel, it sets the new value to:
</p>
<ul>
<li>
Green / Le

</ul>
<div id="NVO-Normalization of P vectors-What It Means"><h4 id="What It Means" class="header"><a href="#NVO-Normalization of P vectors-What It Means">What It Means</a></h4></div>

<p>
Normalization or Unpremultiplication: By dividing the red and green values by another channel (in this case, "Le"), you effectively remove the influence of that channel‚Äôs overall intensity. Often in compositing workflows you may want to isolate color information by removing the contribution of luminance or a matte value. If "Le" is serving as a luminance (or even an alpha-like) channel, this operation will leave you with normalized color values.
</p>

<div id="NVO-Normalization of P vectors-Use Cases:"><h4 id="Use Cases:" class="header"><a href="#NVO-Normalization of P vectors-Use Cases:">Use Cases:</a></h4></div>

<ul>
<li>
<span id="NVO-Normalization of P vectors-Use Cases:-Color Correction:"></span><strong id="Color Correction:">Color Correction:</strong> When you need to adjust or balance color channels independently of their brightness.

<li>
<span id="NVO-Normalization of P vectors-Use Cases:-Matte Extraction / Keying:"></span><strong id="Matte Extraction / Keying:">Matte Extraction / Keying:</strong> When "Le" represents a luma or matte channel that you want to use to drive further operations, dividing by it can help separate pure color data.

<li>
<span id="NVO-Normalization of P vectors-Use Cases:-Unpremultiplication:"></span><strong id="Unpremultiplication:">Unpremultiplication:</strong> A similar concept where colors are divided by an alpha channel to undo the premultiply (though here the channel is named ‚ÄúLe‚Äù instead of ‚Äúalpha‚Äù).

</ul>
<div id="NVO-Normalization of P vectors-Example Scenario"><h4 id="Example Scenario" class="header"><a href="#NVO-Normalization of P vectors-Example Scenario">Example Scenario</a></h4></div>

<p>
Imagine you have a layer where the intensity of a light (or a matte) is stored in the "Le" channel. By computing:
</p>

<ul>
<li>
Red = Red / Le

<li>
Green = Green / Le

</ul>
<p>
You remove the influence of that intensity from the red and green channels. The result is a set of color ratios that can be used for further processing‚Äîperhaps to reintroduce a controlled amount of that light later on or to drive a keying process that is independent of the brightness variations.
</p>

<div id="NVO-Normalization of P vectors-In summary, the expressions:"><h4 id="In summary, the expressions:" class="header"><a href="#NVO-Normalization of P vectors-In summary, the expressions:">In summary, the expressions:</a></h4></div>

<pre plaintext>
Red/Le
Green/Le
</pre>

<p>
...in a Nuke Expression node adjust the red and green channels by dividing them by the "Le" channel, effectively normalizing these channels to isolate color information from overall intensity.
</p>

<div id="NVO-The Le Expression"><h3 id="The Le Expression" class="header"><a href="#NVO-The Le Expression">The Le Expression</a></h3></div>

<p>
This expression calculates the magnitude of the red/green vector and adds a tiny offset to prevent division by zero. Here's a breakdown:
</p>

<ul>
<li>
sqrt((Red*Red) + (Green*Green)): This part computes the Euclidean distance (or length) of the vector formed by the Red and Green channels. In other words, it takes the square root of the sum of the squares of Red and Green values. This is analogous to calculating the hypotenuse of a right triangle, where the legs are the Red and Green values.

<li>
+ 0.00000001: The extremely small number is added to ensure that Le never becomes exactly zero. This is important because if you later divide by Le (like in your expressions for Red/Le and Green/Le), you want to avoid a division-by-zero error.

</ul>
<div id="NVO-The Le Expression-What It Achieves Overall"><h4 id="What It Achieves Overall" class="header"><a href="#NVO-The Le Expression-What It Achieves Overall">What It Achieves Overall</a></h4></div>

<p>
By defining Le in this way, you create a measure of the overall intensity or "length" of the color vector in the red-green plane. When you use it to normalize the red and green channels (by dividing each by Le), you obtain the directional information independent of the magnitude. This is useful for operations like:
</p>

<ul>
<li>
<span id="NVO-The Le Expression-What It Achieves Overall-Normalization:"></span><strong id="Normalization:">Normalization:</strong> Isolating color direction regardless of intensity.

<li>
<span id="NVO-The Le Expression-What It Achieves Overall-Unpremultiplying:"></span><strong id="Unpremultiplying:">Unpremultiplying:</strong> Removing the influence of brightness or a particular matte.

</ul>
<p>
This approach is common in compositing or image processing tasks where you might need to re-map or adjust color values more robustly.
</p>

<div id="fbm_noise"><h1 id="fbm_noise" class="header"><a href="#fbm_noise">fbm_noise</a></h1></div>

<div id="fbm_noise-See page on fBm:"><h4 id="See page on fBm:" class="header"><a href="#fbm_noise-See page on fBm:">See page on fBm:</a></h4></div>
<ul>
<li>
<a href="nuke_expressions_fbm.html">Nuke - Fractional Brownian Motion (fBm)</a>

</ul>
<p>
This expression is calling a fractional Brownian motion (fBm) noise function with inputs that let you customize the noise‚Äôs appearance based on coordinates and various parameters. Here‚Äôs a step-by-step breakdown:
</p>

<div id="fbm_noise-The Expression"><h2 id="The Expression" class="header"><a href="#fbm_noise-The Expression">The Expression</a></h2></div>

<pre plaintext>
fBm(r*xScale/globalScale + pos.x,  g*yScale/globalScale + pos.y,  b*zScale/globalScale + pos.z,  oct, lac, gain)
</pre>

<div id="fbm_noise-The Expression-Breaking Down the Components"><h4 id="Breaking Down the Components" class="header"><a href="#fbm_noise-The Expression-Breaking Down the Components">Breaking Down the Components</a></h4></div>

<p>
Coordinate Transformation:
</p>

<ul>
<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-r, g, b:"></span><strong id="r, g, b:">r, g, b:</strong> These typically represent your base coordinate values or channel values. Although their names imply ‚Äúcolor‚Äù channels, in many noise setups they are repurposed as the x, y, and z spatial coordinates.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-xScale, yScale, zScale:"></span><strong id="xScale, yScale, zScale:">xScale, yScale, zScale:</strong> These factors scale the corresponding coordinate axes. By adjusting them, you change the ‚Äúfrequency‚Äù or ‚Äúdetail‚Äù of the noise along each axis.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-globalScale:"></span><strong id="globalScale:">globalScale:</strong> Dividing by globalScale normalizes or adjusts the overall scale of the noise. This lets you control the noise granularity on a global level.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-pos.x, pos.y, pos.z:"></span><strong id="pos.x, pos.y, pos.z:">pos.x, pos.y, pos.z:</strong> These are offset values (position offsets) added to the respective coordinates. They shift the input domain of the noise function, essentially ‚Äúmoving‚Äù the noise pattern in space.

</ul>
<p>
fBm Noise Function Parameters:
</p>

<ul>
<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-oct:"></span><strong id="oct:">oct:</strong> Short for ‚Äúoctaves,‚Äù this parameter defines how many layers (or frequency iterations) of noise to combine. More octaves usually mean more detail and complexity in the final noise.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-lac:"></span><strong id="lac:">lac:</strong> This represents ‚Äúlacunarity,‚Äù which determines the frequency multiplier between successive octaves. It controls how quickly the frequency increases as you add higher levels of detail.

<li>
<span id="fbm_noise-The Expression-Breaking Down the Components-gain:"></span><strong id="gain:">gain:</strong> This governs the amplitude scaling between octaves. It tells you how much each successive octave contributes relative to the previous one, affecting the overall contrast and "roughness" of the noise.

</ul>
<div id="fbm_noise-The Expression-What the Expression Achieves"><h3 id="What the Expression Achieves" class="header"><a href="#fbm_noise-The Expression-What the Expression Achieves">What the Expression Achieves</a></h3></div>

<ul>
<li>
<span id="fbm_noise-The Expression-What the Expression Achieves-Customizable Noise Texture:"></span><strong id="Customizable Noise Texture:">Customizable Noise Texture:</strong> By combining scaled and offset coordinates with multiple octaves of noise, the function generates a detailed, fractal-like noise pattern. Adjusting xScale, globalScale, and the other parameters lets you tailor the noise‚Äîfrom gentle turbulence to high-frequency textural detail.

<li>
<span id="fbm_noise-The Expression-What the Expression Achieves-Seamless Control Over Appearance:"></span><strong id="Seamless Control Over Appearance:">Seamless Control Over Appearance:</strong> The use of coordinate scaling and offsets (pos.x/y/z) means you can precisely position and resize the noise‚Äôs features. The parameters oct, lac, and gain allow you to dial in the complexity and visual roughness, making this a very flexible tool in your compositing workflow.

</ul>
<p>
Practical Use in Nuke
</p>

<p>
You might connect this fBm expression to drive procedural texture effects, displacement maps, or create natural-looking randomness in effects like clouds, rust, or surface imperfections. Because the transformation is fully parameterized, you can animate the position or adjust the scales over time to create dynamic, evolving noise.
</p>

<p>
This expression is a compact, yet powerful way to leverage procedural (fractal) noise in Nuke. Let me know if you‚Äôd like to explore further examples, such as how to incorporate time-based variations or combine multiple noise layers for even more intricate effects!
</p>

<div id="Color Matrix"><h1 id="Color Matrix" class="header"><a href="#Color Matrix">Color Matrix</a></h1></div>

<p>
Let's break down what the 3√ó3 matrix is doing when you use it to adjust the vector direction of your noise:
</p>

<p>
Imagine your input is treated as a 3‚Äëcomponent vector 
</p>

<pre plaintext>
[ ùë• , ùë¶ , ùëß ].
</pre>

<p>
In your case, you're only interested in a 2D transformation‚Äîthe components corresponding to <code>ùë•</code> and <code>ùë¶.</code> Your matrix is set up so that only the first two rows and the first two columns are active. In other words, your matrix looks something like this:
</p>

<pre plaintext>
[ ùëé ùëè 0 ]
[ ùëê ùëë 0 ]
[ 0 0 0 ]
</pre>

<ul>
<li>
Row 1 (cells <code>[ ùëé , ùëè , 0 ]</code>) -  This row defines how the output‚Äôs first component (let‚Äôs call it the transformed <code>ùë•</code>) is calculated from the input vector:

</ul>
  
<pre plaintext>
ùë•‚Ä≤ = ùëé √ó ùë• + ùëè √ó ùë¶
</pre>

<p>
You have two cells activated here (the multipliers for the <code>ùë•</code> and <code>ùë¶</code> inputs), which you can adjust to control the contribution of the original <code>ùë•</code> and <code>ùë¶</code> to the new <code>ùë•</code> .
</p>

<p>
Row 2 (cells <code>[ ùëê , ùëë , 0 ]</code>) - This row defines the output‚Äôs second component (the transformed <code>ùë¶):</code>
</p>
<pre plaintext>
ùë¶ ‚Ä≤ = ùëê √ó ùë• + ùëë √ó ùë¶
</pre>

<p>
Again, only the first two cells here are active. Changing these values lets you control how the original <code>ùë•</code> and <code>ùë¶</code> mix to produce the new <code>ùë¶.</code>
</p>

<ul>
<li>
Row 3 (all cells set to zero) Since row 3 is entirely zero, the third output channel (or the <code>ùëß</code> component) is forced to 0, meaning it plays no role in your transformation.

<li>
Column 3 (all zeros) Having zeros in column three means that the third component of your input (whatever is stored there) doesn't contribute to either the transformed <code>ùë•</code> or <code>ùë¶</code> outputs.

</ul>
<div id="Color Matrix-What This Accomplishes"><h3 id="What This Accomplishes" class="header"><a href="#Color Matrix-What This Accomplishes">What This Accomplishes</a></h3></div>

<p>
2D Linear Transformation: By only using a 2√ó2 submatrix from the overall 3√ó3 matrix, you‚Äôre effectively applying a linear transformation (rotation, scaling, or shearing) to your 2D coordinates (the <code>ùë•</code> and <code>ùë¶</code> inputs). For example, if you set your active cells to:
</p>

<ul>
<li>
ùëé = cosùúÉ

<li>
ùëè = ‚àí sinùúÉ

<li>
ùëê = sinùúÉ

<li>
ùëë = cosùúÉ

</ul>
<p>
...then you‚Äôre rotating your noise‚Äôs vector by an angle <code>ùúÉ.</code>
</p>

<ul>
<li>
<span id="Color Matrix-What This Accomplishes-Isolating the 2D Behavior:"></span><strong id="Isolating the 2D Behavior:">Isolating the 2D Behavior:</strong> The fact that all of column three and all of row three are zero means you intentionally ignore any third-channel data (such as a z component or an additional parameter). This is typical when your effect is solely based on 2D behavior (such as tiling or directional noise in a plane).

<li>
<span id="Color Matrix-What This Accomplishes-Control Over Vector Direction:"></span><strong id="Control Over Vector Direction:">Control Over Vector Direction:</strong> You can fine-tune the exact behavior of your noise‚Äôs directional properties by adjusting the active cells. For instance, you might not only rotate the vector but also scale it (by changing the magnitude of <code>ùëé</code>, <code>ùëè</code>, <code>ùëê</code>, and <code>ùëë)</code> to achieve the desired intensity or sharpness in your noise pattern.

</ul>
<div id="Color Matrix-What This Accomplishes-In Summary"><h4 id="In Summary" class="header"><a href="#Color Matrix-What This Accomplishes-In Summary">In Summary</a></h4></div>

<p>
Your 3√ó3 ColorMatrix in the context of adjusting noise is functioning as a 2D transformation tool:
</p>

<ul>
<li>
The first row‚Äôs two active cells control how much of the original <code>ùë•</code> and <code>ùë¶</code> contribute to the new <code>ùë•</code>

<li>
The second row‚Äôs two active cells handle the contribution to the new <code>ùë¶.</code>

<li>
Everything else (the entire third row and column three) is set to zero to effectively isolate and ignore any additional data outside the 2D transformation.

</ul>
<p>
This approach is a common technique to adjust the vector direction of noise, allowing for precise control over how your noise pattern is oriented and scaled in the 2D space.
</p>

<div id="Expressions on Painterly Nodes"><h1 id="Expressions on Painterly Nodes" class="header"><a href="#Expressions on Painterly Nodes">Expressions on Painterly Nodes</a></h1></div>

<pre python>
Switch2 -&gt; 'parent.ViewMode'
Blur1 -&gt; 'parent.Blur'
VectorBlur1 -&gt; 'parent.SmearIntensity*50'
VectorBlur1 -&gt; 'parent.SmearOpacity'
IDistort1 -&gt; 'parent.IDistort1_uv_offset'
IDistort1 -&gt; 'parent.IDistort1_uv_scale.w'
IDistort1 -&gt; 'parent.IDistort1_uv_scale.h'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.0'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.1'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.4'
ColorMatrix1 -&gt; 'parent.Axis1.world_matrix.5'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.0'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.1'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.4'
ColorMatrix2 -&gt; 'parent.Axis1.world_matrix.5'
Blur12 -&gt; 'parent.Softness'
Merge3 -&gt; 'parent.SmearNormals'
Switch6 -&gt; 'parent.Mask'
Reformat4 -&gt; 'Reformat1.type'
Reformat4 -&gt; 'Reformat1.box_width'
Reformat4 -&gt; 'Reformat1.box_height'
Reformat4 -&gt; 'Reformat1.box_fixed'
Reformat4 -&gt; 'Reformat1.box_pixel_aspect'
Reformat4 -&gt; 'Reformat1.scale'
Reformat4 -&gt; 'Reformat1.resize'
Reformat4 -&gt; 'Reformat1.center'
Reformat4 -&gt; 'Reformat1.flip'
Reformat4 -&gt; 'Reformat1.flop'
Reformat4 -&gt; 'Reformat1.turn'
Reformat4 -&gt; 'Reformat1.filter'
Reformat4 -&gt; 'Reformat1.clamp'
Reformat4 -&gt; 'Reformat1.black_outside'
Reformat4 -&gt; 'Reformat1.pbb'
Reformat4 -&gt; 'Reformat1.disable'
Switch7 -&gt; 'parent.ViewMode'
Blur12 -&gt; 'parent.Softness'
Switch1 -&gt; 'parent.NoiseType'
Clamp2 -&gt; '1-parent.ClampValues'
Unpremult1 -&gt; '1-parent.Unpremult1_disable'
UDIM_SELECT -&gt; 'parent.UDIM_SELECT_whitepoint'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.globalScale'
Noise2 -&gt; 'parent.NoiseSeed+1000'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.oct'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.lac'
Noise2 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.gain'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.globalScale'
Noise1 -&gt; 'parent.NoiseSeed+2000'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.oct'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.lac'
Noise1 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.gain'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.globalScale'
Noise3 -&gt; 'parent.NoiseSeed'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.oct'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.lac'
Noise3 -&gt; 'parent.fbm_3dNoise1.HueNoise_controls.gain'
TriPlanar -&gt; 'fbm_3dNoise1.pos'
TriPlanar -&gt; 'fbm_3dNoise1.pos'
TriPlanar -&gt; 'fbm_3dNoise1.pos'
Switch3 -&gt; 'parent.DistortEdgesOnly'
Switch5 -&gt; 'parent.SmearEdgesOnly'
Switch4 -&gt; 'parent.BlurEdgesOnly'
Blur4 -&gt; 'parent.EdgeSoftness'
Erode1 -&gt; '-(parent.EdgeThickness)+1'
EdgeDetect2 -&gt; 'parent.EdgeThreshold'
Reformat1 -&gt; 'input.bbox.r-input.bbox.x'
Reformat1 -&gt; 'input.bbox.t-input.bbox.y'
Clamp2 -&gt; '1-parent.ClampValues'
Reformat2 -&gt; 'Reformat1.type'
Reformat2 -&gt; 'Reformat1.box_width'
Reformat2 -&gt; 'Reformat1.box_height'
Reformat2 -&gt; 'Reformat1.box_fixed'
Reformat2 -&gt; 'Reformat1.box_pixel_aspect'
Reformat2 -&gt; 'Reformat1.scale'
Reformat2 -&gt; 'Reformat1.resize'
Reformat2 -&gt; 'Reformat1.center'
Reformat2 -&gt; 'Reformat1.flip'
Reformat2 -&gt; 'Reformat1.flop'
Reformat2 -&gt; 'Reformat1.turn'
Reformat2 -&gt; 'Reformat1.filter'
Reformat2 -&gt; 'Reformat1.clamp'
Reformat2 -&gt; 'Reformat1.black_outside'
Reformat2 -&gt; 'Reformat1.pbb'
Reformat2 -&gt; 'Reformat1.disable'
Axis1 -&gt; 'parent.SmearDirection*180'
</pre>

<div id="Reformat with Expressions on Pulldowns"><h1 id="Reformat with Expressions on Pulldowns" class="header"><a href="#Reformat with Expressions on Pulldowns">Reformat with Expressions on Pulldowns</a></h1></div>

<p>
Pulldowns on standard property tabs for tools don't seem to allow for expression assignment to pulldown menus. However, some nodes in the FB tools DO have expressions binding them to other nodes.
</p>

<p>
I found the best way (other than setting via Python) is to edit them in the Nuke file with the following syntax:
</p>

<p>
<code>Reformat</code> is the 'new' driven node in this case, and <code>Reformat1</code> is the 'parent' or driver node:
</p>

<pre nuke>
Reformat {
 type {{Reformat1.type}}
 format {{{Reformat1.format}}}
 box_width {{Reformat1.box_width}}
 box_height {{Reformat1.box_height}}
 box_fixed {{Reformat1.box_fixed}}
 box_pixel_aspect {{Reformat1.box_pixel_aspect}}
 scale {{Reformat1.scale}}
 resize {{Reformat1.resize}}
 center {{Reformat1.center}}
 flip {{Reformat1.flip}}
 flop {{Reformat1.flop}}
 turn {{Reformat1.turn}}
 filter {{Reformat1.filter}}
 clamp {{Reformat1.clamp}}
 black_outside {{Reformat1.black_outside}}
 pbb {{Reformat1.pbb}}
 name Reformat2
 disable {{Reformat1.disable}}
}
</pre>

<p>
Alternatively, just clone - but this was an interesting case to see (and how to replicate).
</p>


<div id="fBm Noise Formula"><h1 id="fBm Noise Formula" class="header"><a href="#fBm Noise Formula">fBm Noise Formula</a></h1></div>

<p>
Breakdown of the fBm Noise Formula on the customized Expression node, HueNoise_controls:
</p>

<p>
These are the subjects covered below:
</p>
 
<ul>
<li>
How fBm noise is driven by image data and user knobs

<li>
Using Grade as a clamp/scale for UDIM‚Äêbased STMap sampling

<li>
The role of UDIM layouts in interpreting UV passes

<li>
Why out‚Äêof‚Äêrange UVs collapse to flat colors under a whitepoint clamp

</ul>
<div id="fBm Noise Formula-Red"><h4 id="Red" class="header"><a href="#fBm Noise Formula-Red">Red</a></h4></div>

<p>
The user settings are set here, not driven from the external panels (and all the user values expression'ed to the Green and Blue versions):
</p>

<pre nuke>
set cut_paste_input [stack 0]
version 15.0 v7
push $cut_paste_input
Expression {
 channel0 rgb
 expr0 fBm(r*xScale/globalScale+pos.x,g*yScale/globalScale+pos.y,b*zScale/globalScale+pos.z,oct,lac,gain)
 name HueNoise_controls
 selected true
 xpos 376
 ypos 438
 addUserKnob {20 User}
 addUserKnob {13 pos}
 pos {1850 925 0}
 addUserKnob {7 globalScale R 0 10}
 globalScale 15
 addUserKnob {7 yScale R 0 5}
 yScale 0.5
 addUserKnob {7 xScale R 0 5}
 xScale 0.5
 addUserKnob {7 zScale R 0 5}
 zScale 0.5
 addUserKnob {7 oct R 0 10}
 oct 10
 addUserKnob {7 lac R 0 5}
 lac 3.82
 addUserKnob {7 gain R 0 2}
 gain 0.5
}
</pre>

<div id="fBm Noise Formula-Green"><h4 id="Green" class="header"><a href="#fBm Noise Formula-Green">Green</a></h4></div>

<p>
As <code>Red</code> but with:
</p>
<pre nuke>
 pos `{{parent.HueNoise_controls.pos} {parent.HueNoise_controls.pos-1000} {parent.HueNoise_controls.pos}}`
</pre>

<div id="fBm Noise Formula-Blue"><h4 id="Blue" class="header"><a href="#fBm Noise Formula-Blue">Blue</a></h4></div>

<p>
As <code>Red</code> but with:
</p>
<pre nuke>
 pos `{{parent.HueNoise_controls.pos} {parent.HueNoise_controls.pos+1000} {parent.HueNoise_controls.pos}}`
</pre>

<div id="fBm Noise Formula-Generic Formula"><h4 id="Generic Formula" class="header"><a href="#fBm Noise Formula-Generic Formula">Generic Formula</a></h4></div>

<p>
Below is the generic form of the formula, with each term named rather than hard-coded:
</p>

<pre text>
noise = fBm(
  x,
  y,
  z,
  octaves,
  lacunarity,
  gain
)
</pre>

<div id="fBm Noise Formula-Term Definitions"><h2 id="Term Definitions" class="header"><a href="#fBm Noise Formula-Term Definitions">Term Definitions</a></h2></div>

<ul>
<li>
x, y, z the three coordinates at which you sample the noise field.

<li>
octaves how many layers of noise are summed together.

<li>
lacunarity the factor by which frequency increases each octave.

<li>
gain the factor by which amplitude decreases each octave.

<li>
fBm fractal Brownian motion, a function that combines multiple noise layers to produce natural, continuous randomness.

</ul>
<div id="fBm Noise Formula-Layman‚Äôs Descriptions"><h2 id="Layman‚Äôs Descriptions" class="header"><a href="#fBm Noise Formula-Layman‚Äôs Descriptions">Layman‚Äôs Descriptions</a></h2></div>

<ul>
<li>
<span id="fBm Noise Formula-Layman‚Äôs Descriptions-octaves:"></span><strong id="octaves:">octaves:</strong> imagine stacking several sheets of paper, each with finer wrinkles‚Äîmore octaves means more detailed wrinkles.

<li>
<span id="fBm Noise Formula-Layman‚Äôs Descriptions-lacunarity:"></span><strong id="lacunarity:">lacunarity:</strong> controls how much smaller each new sheet‚Äôs wrinkles are compared to the last.

<li>
<span id="fBm Noise Formula-Layman‚Äôs Descriptions-gain:"></span><strong id="gain:">gain:</strong> controls how faint each new sheet‚Äôs wrinkles appear compared to the previous one.

</ul>
<div id="fBm Noise Formula-Mapping to the Painterly Example"><h2 id="Mapping to the Painterly Example" class="header"><a href="#fBm Noise Formula-Mapping to the Painterly Example">Mapping to the Painterly Example</a></h2></div>
<p>
In the Red-channel expression, the coordinates x, y, z are driven by the pixel color and user knobs:
</p>

<pre text>
x = (r * xScale / globalScale) + pos.x  
y = (g * yScale / globalScale) + pos.y  
z = (b * zScale / globalScale) + pos.z
</pre>

<ul>
<li>
r, g, b incoming pixel‚Äôs red, green, blue values (0‚Äì1).

<li>
xScale, yScale, zScale how strongly each color channel stretches its noise axis.

<li>
globalScale common divisor to keep overall noise frequency in check.

<li>
pos.x, pos.y, pos.z user-controlled offsets panning the noise field in each dimension.

</ul>
<div id="fBm Noise Formula-What are xScale, yScale, zScale and globalScale?"><h2 id="What are xScale, yScale, zScale and globalScale?" class="header"><a href="#fBm Noise Formula-What are xScale, yScale, zScale and globalScale?">What are xScale, yScale, zScale and globalScale?</a></h2></div>

<p>
xScale, yScale, zScale and globalScale aren‚Äôt magic built-ins‚Äîthey‚Äôre just user knobs on that Expression node (or on the gizmo wrapping it). When you write
</p>

<pre text>
fBm(
  (r*xScale/globalScale) + pos.x,
   ‚Ä¶
)
</pre>

<p>
Nuke looks for knobs named <code>xScale</code> and <code>globalScale</code> on that same node and plugs their numeric values into the expression.
</p>

<p>
Here‚Äôs what each represents, and how to inspect or add them:
</p>

<ul>
<li>
xScale, yScale, zScale

<ul>
<li>
What they do: stretch or squash how much each color channel (R, G, B) contributes to the noise‚Äôs X, Y, Z coordinates.

<li>
Where they come from: custom Float knobs you (or the gizmo‚Äôs author) added to the node.

</ul>
<li>
globalScale

<ul>
<li>
What it does: a single divisor to keep the overall noise frequency in check, so you don‚Äôt have to tweak all three axis-scales when you want higher or lower detail.

<li>
Where it comes from: another custom Float knob on the same node.

</ul>
</ul>
<div id="fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-How to see or add them:"><h4 id="How to see or add them:" class="header"><a href="#fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-How to see or add them:">How to see or add them:</a></h4></div>

<ul>
<li>
Select your Expression node and open Manage User Knobs‚Ä¶

<li>
You should see knobs named xScale, yScale, zScale, globalScale (and maybe pos.x, pos.y, pos.z) in the list.

<li>
If they‚Äôre missing, click Add‚Ä¶ ‚Üí Float Knob, name it exactly xScale (no spaces), give it a default (e.g. 1.0), then repeat for globalScale, etc.

<li>
Hit OK. Now those knobs appear in your node‚Äôs properties and feed their values into the fBm formula.

</ul>
<p>
In short:
</p>
<ul>
<li>
xScale and globalScale are node-level parameters you (or a gizmo) must define.

<li>
Nuke reads their current values when evaluating the fBm expression.

<li>
Tweak xScale to bias noise along the R-axis, and tweak globalScale to zoom the entire noise pattern in or out.P

</ul>
<div id="fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-Putting it all together:"><h3 id="Putting it all together:" class="header"><a href="#fBm Noise Formula-What are xScale, yScale, zScale and globalScale?-Putting it all together:">Putting it all together:</a></h3></div>

<pre text>
noise = fBm(
  (r*xScale/globalScale) + pos.x,
  (g*yScale/globalScale) + pos.y,
  (b*zScale/globalScale) + pos.z,
  octaves,
  lacunarity,
  gain
)
</pre>

<p>
This generates a procedural noise value in the Red channel, keyed to your image content and tuned by the octaves, lacunarity, and gain knobs.
</p>


<div id="UDIM Passes &amp; Noise"><h1 id="UDIM Passes &amp; Noise" class="header"><a href="#UDIM Passes &amp; Noise">UDIM Passes &amp; Noise</a></h1></div>

<div id="UDIM Passes &amp; Noise-What a UDIM‚Äêbased UV Pass Looks Like"><h4 id="What a UDIM‚Äêbased UV Pass Looks Like" class="header"><a href="#UDIM Passes &amp; Noise-What a UDIM‚Äêbased UV Pass Looks Like">What a UDIM‚Äêbased UV Pass Looks Like</a></h4></div>

<p>
A ‚ÄúUV pass‚Äù from your renderer is simply an image where each pixel‚Äôs red and green channels encode its U and V coordinates on the model. When you use UDIM tiling, those UVs aren‚Äôt constrained to 0‚Äì1‚Äîyou‚Äôll see values stepping up into 1‚Äì2, 2‚Äì3, and so on, depending on the tile.
</p>

<div id="UDIM Passes &amp; Noise-UDIM Tile Layout"><h3 id="UDIM Tile Layout" class="header"><a href="#UDIM Passes &amp; Noise-UDIM Tile Layout">UDIM Tile Layout</a></h3></div>

<p>
UDIM numbers start at 1001 in the lower‚Äêleft tile and increase to the right and then upward in rows of ten. Visually:
</p>

<pre text>
Row y=1:  1011 1012 1013 ‚Ä¶  
Row y=0:  1001 1002 1003 ‚Ä¶   ‚Üê V between 0‚Äì1
           ‚ÜëU‚ÄÜ=0‚Äì1   1‚Äì2   2‚Äì3
</pre>

<ul>
<li>
Tile 1001 has UVs U‚àà[0,1), V‚àà[0,1).

<li>
Tile 1002 has U‚àà[1,2), V‚àà[0,1).

<li>
Tile 1011 has U‚àà[0,1), V‚àà[1,2).

</ul>
<div id="UDIM Passes &amp; Noise-UDIM Tile Layout-The ‚Äú‚àà‚Äù Symbol"><h4 id="The ‚Äú‚àà‚Äù Symbol" class="header"><a href="#UDIM Passes &amp; Noise-UDIM Tile Layout-The ‚Äú‚àà‚Äù Symbol">The ‚Äú‚àà‚Äù Symbol</a></h4></div>

<p>
The symbol <code>‚àà</code> means ‚Äúis an element of‚Äù or ‚Äúbelongs to‚Äù in set theory.
</p>

<p>
For example: <code>3 ‚àà {1, 2, 3, 4}</code> reads ‚Äú3 is an element of the set {1, 2, 3, 4}.‚Äù
</p>

<div id="UDIM Passes &amp; Noise-How That Appears in Your UV Pass"><h3 id="How That Appears in Your UV Pass" class="header"><a href="#UDIM Passes &amp; Noise-How That Appears in Your UV Pass">How That Appears in Your UV Pass</a></h3></div>

<p>
In the render:
</p>

<ul>
<li>
U channel (R in your UV pass)

<ul>
<li>
On tile 1001: values range 0.0‚Üí1.0 (dark to bright in red channel).

<li>
On tile 1002: values range 1.0‚Üí2.0 (even brighter).

<li>
On tile 1003: 2.0‚Üí3.0, etc.

</ul>
<li>
V channel (G in your UV pass) works the same vertically.

</ul>
<p>
There‚Äôs no special ‚Äúbrightness‚Äù hack per tile‚Äîpixels simply carry the raw U, V numbers that tell you exactly which UDIM tile and where within it each point lives.
</p>

<div id="UDIM Passes &amp; Noise-Why This Matters in Compositing"><h3 id="Why This Matters in Compositing" class="header"><a href="#UDIM Passes &amp; Noise-Why This Matters in Compositing">Why This Matters in Compositing</a></h3></div>

<ul>
<li>
<span id="UDIM Passes &amp; Noise-Why This Matters in Compositing-Identify the tile:"></span><strong id="Identify the tile:">Identify the tile:</strong> floor(U) and floor(V) give you the tile‚Äôs X and Y index (e.g. U=4.2 ‚Üí tile X=4 ‚áí 1001+4 = 1005).

<li>
<span id="UDIM Passes &amp; Noise-Why This Matters in Compositing-Reconstruct UDIM number:"></span><strong id="Reconstruct UDIM number:">Reconstruct UDIM number:</strong> UDIM = 1001 + floor(U) + floor(V)√ó10

<li>
<span id="UDIM Passes &amp; Noise-Why This Matters in Compositing-Sample per‚Äêtile sources:"></span><strong id="Sample per‚Äêtile sources:">Sample per‚Äêtile sources:</strong> Using an STMap or UVTile node, these absolute UVs drive look-ups so that each pixel fetches the right UDIM tile of your textures.

</ul>
<div id="UDIM Passes &amp; Noise-Why This Matters in Compositing-So‚Äîdoes each UDIM show up as a ‚Äúbrighter‚Äù band?"><h4 id="So‚Äîdoes each UDIM show up as a ‚Äúbrighter‚Äù band?" class="header"><a href="#UDIM Passes &amp; Noise-Why This Matters in Compositing-So‚Äîdoes each UDIM show up as a ‚Äúbrighter‚Äù band?">So‚Äîdoes each UDIM show up as a ‚Äúbrighter‚Äù band?</a></h4></div>

<p>
Sort of‚Äîbut that brightness isn‚Äôt artistic, it‚Äôs numeric:
</p>

<ul>
<li>
A pixel in UDIM 1001 might have U = 0.3 ‚Üí R=0.3 (dark red).

<li>
In UDIM 1002 at the same local U (0.3) it will be R=1.3 (brighter red).

</ul>
<p>
That jump is simply the coordinate stepping into the next tile, not a coded ‚Äúpass label.‚Äù You then use those values to drive your STMap/UVTile logic so the right texture tile is sampled.
</p>

<div id="UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)"><h3 id="In the Comp - The Grade Node (Whitepoint)" class="header"><a href="#UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)">In the Comp - The Grade Node (Whitepoint)</a></h3></div>

<p>
The tooltip says:
</p>

<table>
<tr>
<td>
"Set the clamp to the number of UDIMS in the scene geometry. Larger numbers will reduce fidelity, but ensure coverage of all geo."
</td>
</tr>
</table>

<p>
The tooltip really nails it: that Grade is not there to recolor‚Äîit's acting as a ‚Äúclamp &amp; scale‚Äù on your UV‚Äêpass so that the STMap node drives the noise sampler over exactly the UDIM range you care about.
</p>

<div id="UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Here‚Äôs the step-by-step in the setup:"><h5 id="Here‚Äôs the step-by-step in the setup:" class="header"><a href="#UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Here‚Äôs the step-by-step in the setup:">Here‚Äôs the step-by-step in the setup:</a></h5></div>

<ul>
<li>
The CG render emits a UV pass where each pixel‚Äôs R and G are the U,V coordinates.

<li>
You pipe that UV pass through a Grade node, using the whitepoint slider as a clamp/scale value.

<ul>
<li>
Grade‚Äôs whitepoint defines the input value that maps to output = 1.0 (anything above it gets clipped to 1).

<li>
By setting whitepoint = N (the number of UDIM tiles in your scene), you effectively remap UVs from [0‚Ä¶N] ‚Üí [0‚Ä¶1] and clamp anything above N down to 1.

</ul>
<li>
That graded result goes into STMap‚Äôs stmap input. STMap then interprets those normalized U &amp; V channels as ‚Äúwhere in the noise texture to sample.‚Äù

<li>
The noise node in STMap‚Äôs src sees a UV map that covers [0‚Ä¶1] exactly once for each tile in the UDIM space you specified.

</ul>
<div id="UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Why this matters:"><h4 id="Why this matters:" class="header"><a href="#UDIM Passes &amp; Noise-In the Comp - The Grade Node (Whitepoint)-Why this matters:">Why this matters:</a></h4></div>

<ul>
<li>
If you set whitepoint too low, any UVs outside that range will all collapse to 1‚Äîso large chunks of geometry end up sampling the same noise.

<ul>
<li>
In other words, anything outside the whitepoint clamp will be driven to exactly 1.0, so when that graded UV pass hits your STMap, all those pixels get UV=(1,1). STMap then looks up your noise at exactly that one coordinate and paints the entire region with that single sample value. Visually you‚Äôll see a flat patch of constant color (the noise‚Äôs color at UV=1,1) wherever your original UVs exceeded the whitepoint threshold. 

</ul>
<li>
If you set it too high, you spread the [0‚Ä¶1] noise domain across many UDIMs, giving each tile less noise detail (reduced fidelity).

<li>
By matching whitepoint to your UDIM count, you ensure each tile sees the full [0‚Ä¶1] noise sweep exactly once, with no out-of-range UVs sampling ‚Äúblank‚Äù areas.

</ul>
<p>
In short, that Grade‚Äôs whitepoint knob is a quick ‚Äúmap your 0‚ÜíUDIM-space UVs into a 0‚Üí1 domain for STMap‚Äù so your procedural noise tiles correctly over all of your scene‚Äôs geometry.
</p>

<div id="Extra Note On Integer vs Float"><h1 id="Extra Note On Integer vs Float" class="header"><a href="#Extra Note On Integer vs Float">Extra Note On Integer vs Float</a></h1></div>

<div id="Extra Note On Integer vs Float-Should Whitepoint Be an Integer?"><h4 id="Should Whitepoint Be an Integer?" class="header"><a href="#Extra Note On Integer vs Float-Should Whitepoint Be an Integer?">Should Whitepoint Be an Integer?</a></h4></div>

<p>
By default, Grade‚Äôs Whitepoint is a floating-point knob, so you can dial in any real value. In a UDIM workflow you‚Äôll most often use whole numbers (e.g. ‚Äú8‚Äù tiles), but leaving it as a float gives you extra flexibility:
</p>

<div id="Extra Note On Integer vs Float-Why Integers Make Sense"><h4 id="Why Integers Make Sense" class="header"><a href="#Extra Note On Integer vs Float-Why Integers Make Sense">Why Integers Make Sense</a></h4></div>

<ul>
<li>
Discrete tile count‚ÄÉUDIMs are inherently whole-numbered (1001, 1002, ‚Ä¶).

<li>
Predictable mapping‚ÄÉSetting Whitepoint to exactly 4.0 means UVs 0‚Äì4 map to 0‚Äì1 cleanly, and anything above 4.0 clamps to 1.

</ul>
<div id="Extra Note On Integer vs Float-What You Gain from Floats"><h4 id="What You Gain from Floats" class="header"><a href="#Extra Note On Integer vs Float-What You Gain from Floats">What You Gain from Floats</a></h4></div>

<ul>
<li>
Fudge Factor for UV Bleed If some UVs accidentally stray to 4.02 or 4.1, using Whitepoint=4.05 instead of 4.0 keeps them inside the 0‚Äì1 range‚Äîavoiding flat clamps on minor overshoots.

<li>
Continuous Scale Control You can subtly compress or stretch your entire UV domain.

</ul>
  
<pre text>
Whitepoint=3.5 ‚Üí UVs 0‚Äì3.5 map to 0‚Äì1.
</pre>

<p>
This can be handy for creative ‚Äúsqueeze‚Äù effects or previewing half-tile coverage.
</p>

<p>
Animated Transitions Animate Whitepoint from 0 to 8.0 over time to progressively ‚Äúreveal‚Äù more tiles in your STMap‚Äôd noise field.
</p>

<div id="Extra Note On Integer vs Float-How to Enforce Integer Behavior"><h4 id="How to Enforce Integer Behavior" class="header"><a href="#Extra Note On Integer vs Float-How to Enforce Integer Behavior">How to Enforce Integer Behavior</a></h4></div>

<p>
If you only ever want whole-number UDIM counts, you have two options:
</p>
<ul>
<li>
Use an Integer Knob In Manage User Knobs‚Ä¶, add your own Integer knob (not Float) and drive Grade.whitepoint with it.

<li>
Floor the Value in an Expression

</ul>
  
<pre text>
Grade1.whitepoint = floor(YourFloatKnob)  
</pre>

<p>
This forces any fractional input down to the next lower integer.
</p>

<div id="Extra Note On Integer vs Float-Bottom Line"><h4 id="Bottom Line" class="header"><a href="#Extra Note On Integer vs Float-Bottom Line">Bottom Line</a></h4></div>

<ul>
<li>
Integer Whitepoint ‚Üí clear, predictable UDIM clamps.

<li>
Float Whitepoint ‚Üí fine-tune clamp threshold, animate, or craft non-standard UV-scaling effects.

</ul>
<p>
Choose based on whether you need strict UDIM counting or more nuanced control
</p>

<div id="Node by Node"><h1 id="Node by Node" class="header"><a href="#Node by Node">Node by Node</a></h1></div>

<p>
Image input
</p>
<ul>
<li>
Clamp (clone):

<ul>
<li>
'P' ('Pref'?) channel for rgba

<li>
This is an optional clamp value of:

<ul>
<li>
min: -1_000_000

<li>
max:  1_000_000

</ul>
<li>
Expression to group

</ul>
<li>
Dot:

<ul>
<li>
essentially a label:

<ul>
<li>
	input format : [value input.format.width]x[value input.format.height]

</ul>
</ul>
<li>
Dot:

<ul>
<li>
essentially a label:

<ul>
<li>
	input overscan : [expr [value input.bbox.r] - [value input.bbox.x]]x[expr [value input.bbox.t] - [value input.bbox.y]]

</ul>
</ul>
<li>
Reformat:

<ul>
<li>
This is the driver for other Reformats (mask, etc.)

<li>
input.bbox.r - input.bbox.x (get width based on right coord minus left bounding box)

<li>
input.bbox.t - input.bbox.y (get height based on bottom coord minus top bounding box)

<li>
type: to box

<li>
resize type: none, center

</ul>
<li>
Backtrack to a Constant:

<ul>
<li>
Constant size: 4000 x 4000

<li>
RGB (set to black)

<li>
Expression driven on all knobs to image Reformat node (tied to the image reformat)

</ul>
<li>
Merge:

<ul>
<li>
B - Image

<li>
A - Constant via Reformat

<li>
Mix set to zero (so no color influence).

<li>
Ensures stream integrity. 

</ul>
</ul>
<div id="2D Noise"><h1 id="2D Noise" class="header"><a href="#2D Noise">2D Noise</a></h1></div>

<ul>
<li>
Noise x3:

<ul>
<li>
All the knobs default (fBm type) except:

<ul>
<li>
The controls below fBm selection. Expression driven from Group panel.

<li>
(Although in the original they are expression driven from HueNoise, which is driven from the panel.)

</ul>
</ul>
</ul>
<p>
Blue:
</p>
<pre nuke>
set cut_paste_input [stack 0]
version 15.0 v7
push $cut_paste_input
Noise {
 cliptype none
 size `{{parent.fbm_3dNoise1.HueNoise_controls.globalScale}}`
 zoffset `{{parent.NoiseSeed}}`
 octaves `{{parent.fbm_3dNoise1.HueNoise_controls.oct}}`
 lacunarity `{{parent.fbm_3dNoise1.HueNoise_controls.lac}}`
 gain `{{parent.fbm_3dNoise1.HueNoise_controls.gain}}`
 center {960 540}
 name Noise3
 selected true
 xpos 585
 ypos -189
}
</pre>

<p>
Green (same as blue except):
</p>

<pre nuke>
 zoffset `{{parent.NoiseSeed+2000}}`
</pre>

<p>
Red (same a blue except):
</p>

<pre nuke>
 zoffset `{{parent.NoiseSeed+1000}}`
</pre>

<ul>
<li>
Shuffles x2:

<ul>
<li>
Set each noise into RG&amp;B

</ul>
<li>
FrameHold:

<ul>
<li>
set to zero in this case

</ul>
<li>
Grade:

<ul>
<li>
Black clamp off

<li>
blackpoint 0.25

</ul>
<li>
Switch:

<ul>
<li>
This switch is linked to the NoiseType pulldown

</ul>
</ul>
<div id="3D Noise"><h1 id="3D Noise" class="header"><a href="#3D Noise">3D Noise</a></h1></div>

<ul>
<li>
Shuffle:

<ul>
<li>
P (or Pref) into RGBA

</ul>
<li>
Unpremult:

<ul>
<li>
Disable/Enable from Panel (expression)

</ul>
<li>
Clamp (clone):

<ul>
<li>
Not sure why this is repeated on the stream.

<li>
'P' ('Pref'?) channel for rgba

<li>
This is an optional clamp value of:

<ul>
<li>
min: -1_000_000

<li>
max:  1_000_000

</ul>
<li>
Expression to group

</ul>
</ul>
<div id="3D Noise-3D Noise fBm Group"><h2 id="3D Noise fBm Group" class="header"><a href="#3D Noise-3D Noise fBm Group">3D Noise fBm Group</a></h2></div>
<ul>
<li>
This seems to be an expanded gizmo.

<li>
Group input

<li>
Shuffle:

<ul>
<li>
Takes P channel and outputs to RGBA

</ul>
<li>
Unpremult:

<ul>
<li>
Standard settings

</ul>
<li>
HueNoise_control x3:

<ul>
<li>
This is a customized <code>Expression</code> node, with 'User' knobs for variables for an fBm formula

<li>
These User knobs are set here (on Red one), not linked to external controls.

<li>
The Green and Blue instances are expression driven from RED (User controls)

<li>
See above for explanation.

</ul>
<li>
Shuffle x3:

<ul>
<li>
[Channel color] -&gt; [Channel color]

<li>
Other two 'black'

<ul>
<li>
RGBA -&gt; Rbbb

<li>
RGBA -&gt; bGbb

<li>
RGBA -&gt; bbBb

</ul>
</ul>
<li>
Merge:

<ul>
<li>
Operation to Plus

</ul>
<li>
Group output.

</ul>
<div id="3D Noise (continued)"><h1 id="3D Noise (continued)" class="header"><a href="#3D Noise (continued)">3D Noise (continued)</a></h1></div>

<ul>
<li>
Expression Node:

<ul>
<li>
Normalize Vector Operation (NVO)

<li>
Le = sqrt((Red*Red) + (Green*Green))+0.00000001

<li>
Red channel <code>Red/Le</code>

<li>
Green channel <code>Green/Le</code>

</ul>
<li>
Median:

<ul>
<li>
Set to '1'

</ul>
<li>
Switch:

<ul>
<li>
This switch is linked to the NoiseType pulldown

</ul>
</ul>
<div id="UV Noise"><h1 id="UV Noise" class="header"><a href="#UV Noise">UV Noise</a></h1></div>

<p>
Image (which presumably would have a Pref layer:
</p>
<ul>
<li>
Shuffle:

<ul>
<li>
Shuffle the Pref (or P or whatever) into RGBA

</ul>
<li>
Grade:

<ul>
<li>
More on this above

<li>
Expression on 'whitepoint':

<ul>
<li>
Parent float slider: <code>parent.UDIM_SELECT_whitepoint</code>

</ul>
</ul>
<li>
STMap:

<ul>
<li>
stmap input: the Grade

<li>
src input: will be from 2D Noise

</ul>
<li>
Switch:

<ul>
<li>
This switch is linked to the NoiseType pulldown

</ul>
</ul>
<div id="Triplanar Noise"><h1 id="Triplanar Noise" class="header"><a href="#Triplanar Noise">Triplanar Noise</a></h1></div>

<p>
Skipping this until I know it's a requirement. (It involves a LOT of magic: blinkscripts etc.)
</p>

<div id="Noise out Stream (from Switch)"><h1 id="Noise out Stream (from Switch)" class="header"><a href="#Noise out Stream (from Switch)">Noise out Stream (from Switch)</a></h1></div>

<ul>
<li>
Merge:

<ul>
<li>
Here for integrity assurance

<li>
Operation Over

<li>
Noise stream input to A

<li>
B is unconnected (black essentially)

</ul>
<li>
Shuffle:

<ul>
<li>
The Noise is RGB (stream B)

<li>
The alpha from the original Image input is A

</ul>
</ul>
<div id="Fork"><h1 id="Fork" class="header"><a href="#Fork">Fork</a></h1></div>
<p>
-&gt; Normals
-&gt; Blur - first
</p>

<div id="Normals"><h1 id="Normals" class="header"><a href="#Normals">Normals</a></h1></div>

<p>
Uses the RGba or Normal channel (or other) to conform normals (mix with geo normals I guess) but can use RGba.
</p>

<p>
Image in:
</p>
<ul>
<li>
Shuffle:

<ul>
<li>
in is controlled by 'Conform Normals' &gt; Channel:

<li>
RGB or N or other perhaps; RGB by default

</ul>
<li>
NVO:

<ul>
<li>
Le=sqrt((Red*Red) + (Green*Green))+0.00000001 

<li>
Red/Le

<li>
Green/Le

</ul>
<li>
Merge:

<ul>
<li>
A - the NVO

<li>
B - See fork from 'Noise out Stream (from Switch)

<li>
Mix is controlled from 'Smear Normals' slider (default zero)

</ul>
<li>
Blur - second:

<ul>
<li>
size expression from 'Softness'

</ul>
<li>
Fork:

<ul>
<li>
main stream:

<ul>
<li>
Shuffle NoiseNormals:

<li>
A -&gt; rgba -&gt; NoiseNormals

<li>
B -&gt; (main image stream) rgba -&gt; rgba

</ul>
</ul>
<li>
Fork:

<ul>
<li>
Much further down

<li>
Switch -&gt; View mode as input 1

</ul>
</ul>
<div id="Blur - first"><h1 id="Blur - first" class="header"><a href="#Blur - first">Blur - first</a></h1></div>

<p>
Blur (clone of blur - second):
</p>
<ul>
<li>
Input from Noise out Stream (shuffle)

<li>
Dormant Premult here (cloned and manually disabled)

<li>
Blur Node (clone of blur - second):

<ul>
<li>
Size - driven by 'Softness' on gizmo

<li>
x crop to format.

</ul>
<li>
ENTERS IMAGE STREAM:

<ul>
<li>
Shuffle:

<ul>
<li>
B - Regular image -&gt; RGBA

<li>
A - the Blur -&gt; RGBA to Noise (RGBA)

</ul>
</ul>
<li>
Forks to -&gt; mask area

<li>
Continues down the image stream

</ul>
<div id="Mask Area"><h1 id="Mask Area" class="header"><a href="#Mask Area">Mask Area</a></h1></div>

<p>
Three shuffles - noise R,G,B
Shuffle:
</p>
<ul>
<li>
Noise.red -&gt; rgba.alpha (then RGB to black)

</ul>
<p>
Shuffle:
</p>
<ul>
<li>
Noise.green -&gt; rgba.alpha (then RGB to black)

</ul>
<p>
Shuffle:
</p>
<ul>
<li>
Noise.blue -&gt; rgba.alpha (then RGB to black)

</ul>
<p>
Switch:
</p>
<ul>
<li>
Takes in 'mask' input (to gizmo)

<li>
Shuffled noise R

<li>
Shuffled noise G

<li>
Shuffled noise B

<li>
Shuffle:

<ul>
<li>
From Image, but puts black in Noise channel's RGBA

<li>
Just maintains format, but alpha is all black

<li>
Corresponds to 'None' on gizmo's Mask pulldown

</ul>
<li>
Invert:

<ul>
<li>
Inverts mattes as masks

</ul>
<li>
Feeds into merge (main stream)

</ul>
<div id="Merge to Main Image Stream"><h1 id="Merge to Main Image Stream" class="header"><a href="#Merge to Main Image Stream">Merge to Main Image Stream</a></h1></div>

<p>
Merge:
</p>
<ul>
<li>
purpose - to add masked version of Noise layer

<li>
A -&gt; from the shuffle that makes the Noise layer all black (the none option for the Mask Area).

<li>
B -&gt; from the shuffle that takes in NoiseNormals (it's already got Noise)

<li>
mask -&gt; from Invert after Mask Area switch.

<li>
Operation: copy:

<ul>
<li>
A channels Noise rgba Noise.alpha

<li>
B channels Noise rgba Noise.alpha

<li>
output Noise rgba Noise.alpha

<li>
also merge: none none

<li>
mask: x rgba.alpha

<li>
mix: 1

</ul>
</ul>
<p>
Merge:
</p>
<ul>
<li>
purpose - to add the masked version of the NoiseNormals layer

<li>
A -&gt; from the shuffle that makes the Noise layer all black (the none option for the Mask Area).

<li>
B -&gt; from the Merge that adds the (masked) Noise (it's already got NoiseNormals, but this replaces with mask option)

<li>
mask -&gt; from Invert after Mask Area switch.

<li>
Operation: copy:

<ul>
<li>
A channels NoiseNormals rgba NoiseNormals.alpha

<li>
B channels NoiseNormals rgba NoiseNormals.alpha

<li>
output NoiseNormals rgba NoiseNormals.alpha

<li>
also merge: none none

<li>
mask: x rgba.alpha

<li>
mix: 1

</ul>
</ul>
<div id="Vector Section"><h1 id="Vector Section" class="header"><a href="#Vector Section">Vector Section</a></h1></div>

<p>
Shuffle:
</p>
<ul>
<li>
Noise layer:

<ul>
<li>
To neutralize RGxx (blue and alpha) -&gt; blue to black, alpha to black

</ul>
</ul>
<p>
Axis (freestanding)
</p>
<ul>
<li>
rotate 'z':

<ul>
<li>
<code>{parent.SmearDirection*180}</code>

</ul>
</ul>
<p>
ColorMatrix
</p>
<ul>
<li>
Channels: Noise

<li>
[ exp exp 0]

<li>
[ exp exp 0]

<li>
[ 0   0   0]

<li>
exp -&gt; expression to Axis 'world_matrix' rows/cols

</ul>
<p>
ColorMatrix
</p>
<ul>
<li>
Channels: NoiseNormals

<li>
[ exp exp 0]

<li>
[ exp exp 0]

<li>
[ 0   0   0]

<li>
exp -&gt; expression to Axis 'world_matrix' rows/cols

</ul>
<p>
iDistort
</p>
<ul>
<li>
mask input:

<ul>
<li>
Switch - zero (no connection) or 1 Normal edge detect

<li>
<code>{parent.SmearEdgesOnly}</code>

</ul>
<li>
UV Channels -&gt; NoiseNormals 

<li>
UV offset -&gt; expression

<ul>
<li>
<code>{parent.IDistort1_uv_offset}</code> (Offset)

</ul>
<li>
UV scale -&gt; expression:

<ul>
<li>
w -&gt; <code>{parent.IDistort1_uv_scale.w}</code> (Paint Intensity)

<li>
h -&gt; <code>{parent.IDistort1_uv_scale.h}</code> (Paint Intensity)

</ul>
</ul>
<p>
VectorBlur
</p>
<ul>
<li>
uv channels -&gt; NoiseNormals

<li>
motion amount -&gt; <code>{parent.SmearIntensity*50}</code>

<li>
mix -&gt; <code>{parent.SmearOpacity}</code>

</ul>
<p>
Blur
</p>
<ul>
<li>
mask input:

<ul>
<li>
Switch -&gt; <code>{parent.BlurEdgesOnly}</code>

</ul>
<li>
size <code>{parent.Blur}</code>

</ul>
<p>
Switch
</p>
<ul>
<li>
<code>{parent.ViewMode}</code>

<li>
zero - Result

<li>
1 - Second blur

<li>
2 - Edge Normals

</ul>
<p>
Reformat
</p>
<ul>
<li>
to root (2048x858)

<li>
resize type; none x center

<li>
x preserve bounding box

</ul>
<p>
Shuffle
</p>
<ul>
<li>
Orig Image input:

<ul>
<li>
B none -&gt; rgba (no connections)

</ul>
<li>
Stream:

<ul>
<li>
A rgba -&gt; rgba

</ul>
</ul>
 
<ul>
<li>
Output

</ul>
<div id="Edge Normals"><h1 id="Edge Normals" class="header"><a href="#Edge Normals">Edge Normals</a></h1></div>

<p>
Image in:
</p>
<ul>
<li>
Shuffle:

<ul>
<li>
N rgba -&gt; rgba

</ul>
<li>
EdgeDetect:

<ul>
<li>
edge detector: Sobel

<li>
channels: rgb

<li>
threshold:

<ul>
<li>
<code>{parent.EdgeThreshold}</code>

</ul>
<li>
output: x rgba.alpha

</ul>
<li>
Shuffle:

<ul>
<li>
B rgba.alpha -&gt; rgba (all)

</ul>
<li>
Clamp:

<ul>
<li>
channels: all

</ul>
<li>
Erode:

<ul>
<li>
channels: rgba

<li>
size: <code>{-(parent.EdgeThickness)+1}</code> 

</ul>
<li>
Blur:

<ul>
<li>
channels: all

<li>
size: <code>{parent.EdgeSoftness}</code>

</ul>
</ul>
<p>
<a href="pmount_index.html">PM</a>
</p>


<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
