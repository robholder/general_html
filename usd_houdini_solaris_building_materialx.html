<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>usd_houdini_solaris_building_materialx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="Houdini.html">Houdini</a>
</p>


<div id="Video - Tutorial (YouTube)"><h3 id="Video - Tutorial (YouTube)" class="header"><a href="#Video - Tutorial (YouTube)">Video - Tutorial (YouTube)</a></h3></div>
<ul>
<li>
<a href="https://www.youtube.com/watch?vcE-Bbdspu_8&amp;t5648s">01:34:08 Building Material X Shaders</a>

</ul>
<div id="Material X"><h1 id="Material X" class="header"><a href="#Material X">Material X</a></h1></div>

<p>
Houdini uses VEX based shaders to define its proprietary renderers.
</p>

<p>
<code>Material X</code> shaders are alternatives, with the ability to be exported with USD to be interpreted by either Houdini compliant or other renderers.
</p>


<div id="Material X-Karma (CPU) and Karma (XPU)"><h3 id="Karma (CPU) and Karma (XPU)" class="header"><a href="#Material X-Karma (CPU) and Karma (XPU)">Karma (CPU) and Karma (XPU)</a></h3></div>

<ul>
<li>
<code>Karma XPU</code> (which runs on both CPU and Graphics cards) has to use Material X to retain all the functionality in the renderer.

<li>
<code>Karma CPU</code> can use VEX based shaders, but only runs on the CPU, and is slow.

</ul>
<p>
<br>
</p>

<div id="Material X-Building a Material X Shader"><h3 id="Building a Material X Shader" class="header"><a href="#Material X-Building a Material X Shader">Building a Material X Shader</a></h3></div>

<ul>
<li>
Create a MaterialLibrary node:

<ul>
<li>
<code>TAB</code> &gt; material library

</ul>
<li>
Inside:

<ul>
<li>
Add a USD Material X subnet node:

<ul>
<li>
<code>TAB</code> &gt; USD Material X Subnet

<li>
Inside USD Material X subnet node:

<ul>
<li>
<code>TAB</code> will now only show Material X compliant nodes:

<ul>
<li>
Exception: Mtlx nodes with Houdini logo only function in Houdini (at this time)

</ul>
<li>
(Using Vex based nodes will break Material X compatibility)

</ul>
</ul>
</ul>
</ul>
<div id="Material X-MtlX Standard Surface"><h3 id="MtlX Standard Surface" class="header"><a href="#Material X-MtlX Standard Surface">MtlX Standard Surface</a></h3></div>

<p>
The <code>MtlX Standard Surface</code> is much like the PrincipledShader type in regular VEX based shaders.
</p>

<div id="Material X-Material Library"><h3 id="Material Library" class="header"><a href="#Material X-Material Library">Material Library</a></h3></div>

<p>
The <code>Material Library</code> node's parameters allows for you to assign the materials inside to geo.
</p>

<p>
The lower on the list of assignments an item is, that's the assignment that will override any duplicates above.
</p>

<ul>
<li>
Material VOP:

<ul>
<li>
material out node name

</ul>
<li>
Material Path:

<ul>
<li>
path to material out node

</ul>
<li>
Geometry Path:

<ul>
<li>
active with Assign to Geometry checkbox 

<li>
path to geometry to receive material assignment

</ul>
</ul>
<div id="Material X-Building a network shader"><h3 id="Building a network shader" class="header"><a href="#Material X-Building a network shader">Building a network shader</a></h3></div>

<p>
In the video tutorial, a shader is built of a biscuit/candy door.
</p>


<p>
Inside a <code>material library</code> node, create a <code>USD MaterialX Subnet</code>. (This will be a shader - and you can build as many as you want inside the material library node.)
</p>

<p>
Delete Surface &amp; Input nodes for the following example:
</p>

<ul>
<li>
MtlX Standard Surface:

<ul>
<li>
Plug into <code>surface_output</code>, the surface input connector node (should already be there)

</ul>
<li>
Mtlx Image:

<ul>
<li>
Signature --&gt; <code>Color</code>

<li>
Path to color map (texture image)

<li>
Plug into the MtlX Standard Surface:

<ul>
<li>
base_color

<li>
optionally:

<ul>
<li>
subsurface_color

<li>
subsurface_radius

<li>
NOTE: subsurface (tab) slider needs to be less than 1 to see normal map effect (see below)

</ul>
</ul>
</ul>
<li>
Mtlx Image:

<ul>
<li>
Signature --&gt; <code>Float</code>

<li>
Path to specular map (grayscale image)

<li>
Plug into the MtlX Standard Surface:

<ul>
<li>
specular_roughness

</ul>
</ul>
<li>
MtlX Normalmap:

<ul>
<li>
Plug into the MtlX Standard Surface:

<ul>
<li>
normal

</ul>
</ul>
<li>
Mtlx Image:

<ul>
<li>
Signature --&gt; <code>Vector3</code>

<li>
Path to bump map

<li>
Plug into the MtlX Normalmap:

<ul>
<li>
from 'out' to 'in' on the MtlX Normalmap node

</ul>
<li>
NOTE: subsurface setting of '1' will prevent bump normal from working.

</ul>
<li>
MtlX Displacement:

<ul>
<li>
this node should already be there from initial creation of the material library node

<li>
adjust scale slider!!

<li>
optionally add an MtlX Color Correct or MtlX Remap to adjust

<li>
plug from out to suboutput on MtlX Displacement_out node (below)

</ul>
<li>
MtlX Displacement_out:

<ul>
<li>
this node should already be there from initial creation of the material library node

</ul>
<li>
Mtlx Image:

<ul>
<li>
Signature --&gt; <code>Float</code>

<li>
Path to height map (grayscale)

<li>
Plug into MtlX Displacement node:

<ul>
<li>
displacement

</ul>
</ul>
</ul>
<p>
At the <code>Material Library</code> parameters panel, you can assign the shader to geo. Add as many assignments as needed.
</p>

<p>
<a href="Houdini.html">Houdini</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
