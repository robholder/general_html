<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_project_export-import_colorpicks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PMount</a>
</p>

<div id="Import/Export ColorPick Colors"><h1 id="Import/Export ColorPick Colors" class="header"><a href="#Import/Export ColorPick Colors">Import/Export ColorPick Colors</a></h1></div>

<div id="Import/Export ColorPick Colors-Discussion"><h2 id="Discussion" class="header"><a href="#Import/Export ColorPick Colors-Discussion">Discussion</a></h2></div>

<div id="Import/Export ColorPick Colors-Discussion-Question"><h3 id="Question" class="header"><a href="#Import/Export ColorPick Colors-Discussion-Question">Question</a></h3></div>

<p>
I want to write a Python script for Nuke, and I want it to analyze a selection of specific nodes, storing color swatch knobs as JSON data to export, and to import onto a similar selection of nodes.
</p>

<p>
I'm thinking to create a class to represent each node (they're all of the same type), and to store the data within the instance.
</p>

<ul>
<li>
Perhaps an <code>__init__</code> method to load the current values, and a method to update them with an imported JSON set.

<li>
Each node will have a name that defines it (for data export and import), although the nodes will have a numeric suffix that I will have to ignore. (For example: "my_node_a" and my_node_a25" would be essentially the same thing.)

<li>
I'd also like the facility to import "my_node_a" or "my_node_a56" onto "your_node_a", or "your_node_a 4".

</ul>
<p>
Can you give me an outline as to how to structure this project, and even suggest the actual code?
</p>


<div id="Import/Export ColorPick Colors-Discussion-Gemini Answer"><h3 id="Gemini Answer" class="header"><a href="#Import/Export ColorPick Colors-Discussion-Gemini Answer">Gemini Answer</a></h3></div>

<p>
Here's a detailed outline and a Python script for your Nuke project, focusing on a class-based approach to manage color swatch knob data for export and import.
</p>

<p>
The script will define a NodeColorData class to handle the logic for individual nodes, along with functions for exporting and importing data from a selection of Nuke nodes to a JSON file.
</p>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager"><h2 id="Nuke Color Swatch Data Manager" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager">Nuke Color Swatch Data Manager</a></h2></div>
<p>
Aug 23 at 10:40 AM
</p>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline"><h3 id="Project Structure Outline" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline">Project Structure Outline</a></h3></div>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:"><h4 id="get_base_node_name(node_name) Function:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:">get_base_node_name(node_name) Function:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: To normalize node names by removing numerical suffixes (e.g., my_node_a25 becomes my_node_a). This is crucial for matching nodes during import.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>: Uses regular expressions to identify and strip the suffixes.

</ul>
<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:"><h4 id="get_color_swatch_knobs(node) Function:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:">get_color_swatch_knobs(node) Function:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: To iterate through a given Nuke node and identify all nuke.Color_Knob types.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>: Returns a dictionary where keys are knob names and values are their current RGBA tuples.

</ul>
<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Note on Help Functions:"><h4 id="Note on Help Functions:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Note on Help Functions:">Note on Help Functions:</a></h4></div>

<p>
The helper functions get_base_node_name and get_color_swatch_knobs are placed outside the NodeColorData class because they perform generic, stateless operations that don't depend on or modify the internal state of a specific NodeColorData object. They serve as utility functions that can be used independently by any part of the program, not just by instances of the NodeColorData class.
</p>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:"><h4 id="Separating these functions from the class provides several benefits:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:">Separating these functions from the class provides several benefits:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Reusability ‚ôªÔ∏è"></span><strong id="Reusability ‚ôªÔ∏è">Reusability ‚ôªÔ∏è</strong>: These functions can be used by other classes or scripts that need to perform the same task without having to create an instance of NodeColorData. For example, get_base_node_name is used by both the NodeColorData class and the import_color_data_to_selected_nodes function.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Encapsulation &amp; Cohesion üì¶"></span><strong id="Encapsulation &amp; Cohesion üì¶">Encapsulation &amp; Cohesion üì¶</strong>: The NodeColorData class is designed to represent and manage the data for a single Nuke node. The helper functions, which extract information from a Nuke node, are logically distinct from the object that holds that information. Keeping them separate improves the class's cohesion by focusing its responsibilities on data management.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Clarity and Maintainability üßπ"></span><strong id="Clarity and Maintainability üßπ">Clarity and Maintainability üßπ</strong>: By placing generic utility functions outside the class, the class definition becomes cleaner and more focused. A developer reading the NodeColorData class can quickly understand its core purpose without being distracted by the implementation details of how data is extracted from a Nuke node.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Loose Coupling üîó"></span><strong id="Loose Coupling üîó">Loose Coupling üîó</strong>: The class is less tightly coupled to the implementation details of the helper functions. If the logic for getting a base node name or color knobs changes, only the helper function needs to be modified, not the class that uses it.

</ul>
<p>
In essence, the class methods (_<em>init</em>_, to_json_data, update_node_from_data) are actions that an instance of NodeColorData performs on its own data, whereas the helper functions are a toolbox of generic operations used by the class and other parts of the program to accomplish their tasks.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:"><h2 id="NodeColorData Class:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:">NodeColorData Class:</a></h2></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Purpose"></span><strong id="Purpose">Purpose</strong>: Encapsulates the logic and data for a single Nuke node's color swatches. This makes it easier to manage and transfer data.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-_<em>init</em>_(self, nuke_node)"></span><strong id="_<em>init</em>_(self, nuke_node)">_<em>init</em>_(self, nuke_node)</strong>:

<ul>
<li>
Takes an actual Nuke node object as an argument.

<li>
Stores the node's full name (self.node_name).

<li>
Calls get_base_node_name() to determine and store self.base_name.

<li>
Calls get_color_swatch_knobs() to extract and store all relevant color data in self.color_data.

<li>
Keeps a reference to the nuke_node for later updates.

</ul>
<li>
to_json_data(self):

<ul>
<li>
Returns a dictionary containing the node_name, base_name, and color_data of the instance. This dictionary is directly serializable into JSON.

</ul>
<li>
update_node_from_data(self, data_to_apply):

<ul>
<li>
Takes a dictionary (which would come from parsed JSON data).

<li>
Iterates through the colors in data_to_apply.

<li>
For each color knob, it finds the corresponding knob on the actual _nuke_node and attempts to set its value. Includes error handling for missing knobs or incorrect types.

</ul>
</ul>
<div id="Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:"><h3 id="export_selected_node_color_data(file_path) Function:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:">export_selected_node_color_data(file_path) Function:</a></h3></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: The main function to initiate the export process.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>:

<ul>
<li>
Gets all currently selected nodes in Nuke.

<li>
Creates a NodeColorData instance for each selected node.

<li>
Collects the JSON-ready data from each instance into a list.

<li>
Writes this list to the specified file_path as a pretty-printed JSON file.

<li>
Provides Nuke messages for success or failure.

</ul>
</ul>
<div id="Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:"><h3 id="import_color_data_to_selected_nodes(file_path) Function:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:">import_color_data_to_selected_nodes(file_path) Function:</a></h3></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: The main function to initiate the import process.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>:

<ul>
<li>
Gets all currently selected nodes in Nuke (these are the target nodes).

<li>
Reads the JSON data from the specified file_path.

<li>
Creates a mapping from base_name to the imported color data for efficient lookup.

<li>
Iterates through each selected target node:

<li>
Determines its target_base_name.

<li>
Looks up matching data in the data_map using the target_base_name. This handles the "my_node_a" -&gt; "your_node_a" scenario and also my_node_a25 -&gt; your_node_a 4 because both will resolve to _a base name.

</ul>
<li>
If a match is found, creates a NodeColorData instance for the target node and calls its update_node_from_data() method.

<li>
Provides Nuke messages for success or failure.

</ul>
<div id="Import/Export ColorPick Colors-NodeColorData Class:-Nuke Menu Integration (Optional but Recommended):"><h3 id="Nuke Menu Integration (Optional but Recommended):" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Nuke Menu Integration (Optional but Recommended):">Nuke Menu Integration (Optional but Recommended):</a></h3></div>

<p>
A function <code>create_nuke_menu_items()</code> demonstrates how to add these export and import functionalities to Nuke's Python menu, making them easily accessible.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:"><h3 id="Mock Nuke Environment:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:">Mock Nuke Environment:</a></h3></div>

<p>
Included for standalone testing of the Python logic without needing Nuke itself. This creates fake nuke objects (MockNode, MockColorKnob, MockNuke) that mimic the behavior necessary for the script. This part should not be run within a real Nuke session.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Conclusion and Suggestions"><h4 id="Conclusion and Suggestions" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Conclusion and Suggestions">Conclusion and Suggestions</a></h4></div>

<p>
This script provides a robust framework for managing your color swatch data in Nuke. The class-based approach makes the code modular and easier to maintain. The get_base_node_name function handles the numerical suffixes, and the import logic is designed to be flexible, allowing you to transfer data between similarly named node sets.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:"><h4 id="Here are a few suggestions for further development:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:">Here are a few suggestions for further development:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Error Handling and UI Feedback"></span><strong id="Error Handling and UI Feedback">Error Handling and UI Feedback</strong>: While nuke.message is used, you could implement more sophisticated UI feedback for errors, such as a custom Nuke panel showing detailed logs of successful and failed updates.
  <span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Knob Type Customization"></span><strong id="Knob Type Customization">Knob Type Customization</strong>: The get_color_swatch_knobs function specifically looks for nuke.Color_Knob types. If you have custom nodes or other 4-float knobs that should be treated as colors, you might need to extend this function to include logic to identify them based on name patterns or other attributes.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Advanced Mapping"></span><strong id="Advanced Mapping">Advanced Mapping</strong>: For more complex scenarios, where a node with base name "A" might need to receive data from a node with base name "B" in the JSON file, you could introduce a UI element during import to allow the user to manually map source base names to target base names.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Preserving User Selections"></span><strong id="Preserving User Selections">Preserving User Selections</strong>: The current getFilename calls for export/import rely on Nuke's file browser. You might want to save the last used directory to quickly access it again.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Undo Support"></span><strong id="Undo Support">Undo Support</strong>: For production scripts, it's good practice to wrap changes in a nuke.Undo.begin() and nuke.Undo.end() block to allow users to undo the import operation.

</ul>
<div id="GEMINI SUGGESTED OUTLINE"><h1 id="GEMINI SUGGESTED OUTLINE" class="header"><a href="#GEMINI SUGGESTED OUTLINE">GEMINI SUGGESTED OUTLINE</a></h1></div>

<table>
<tr>
<td>
RAW SUGGESTION - UNTESTED
</td>
</tr>
</table>
  
<pre python>
import nuke
import json
import re
import os

# --- Helper Functions ---

def get_base_node_name(node_name):
    """
    Extracts the base name of a node, ignoring trailing numbers or numbers preceded by an underscore.
    Examples:
    "my_node_a" -&gt; "my_node_a"
    "my_node_a25" -&gt; "my_node_a"
    "my_node_b_1" -&gt; "my_node_b"
    "my_node_c_001_final" -&gt; "my_node_c_001_final" (only trailing numbers are stripped)
    """
    # Pattern to match numbers at the end of the string, optionally preceded by an underscore
    match = re.match(r"^(.*?)(?:[_-]?\d+)?$", node_name)
    if match:
        return match.group(1).rstrip('_') # Remove any trailing underscore left by the regex
    return node_name

def get_color_swatch_knobs(node):
    """
    Retrieves all color swatch knob names and their current values from a given Nuke node.
    Assumes color swatch knobs are 4-tuple (RGBA) floats.
    """
    color_knobs = {}
    # Iterate through all knobs on the node
    for knob_name in node.knobs():
        knob = node[knob_name]
        # Check if the knob is a color knob (e.g., a Color_Knob or has 4 channels)
        # Nuke's built-in Color_Knob is the most common. We'll also check for 4-float knobs
        # that might represent a color if they are explicitly desired.
        if isinstance(knob, nuke.Color_Knob):
            color_knobs[knob_name] = list(knob.value()) # Store as a list of RGBA floats
        # You can extend this to include other 4-float knobs if they represent colors
        # For example, if you have custom nodes with 'color' or 'tint' knobs that are just 4 floats:
        # elif knob.Class() == 'Array_Knob' and knob.arraySize() == 4 and knob.type() == 'float':
        #     if any(k in knob_name.lower() for k in ['color', 'tint', 'fill']):
        #         color_knobs[knob_name] = list(knob.value())
    return color_knobs

# --- NodeColorData Class ---

class NodeColorData:
    """
    Represents the color swatch data for a single Nuke node, providing
    methods for loading, exporting, and updating.
    """
    def __init__(self, nuke_node):
        """
        Initializes the NodeColorData instance by extracting color swatch
        knob values from the given Nuke node.
        """
        if not isinstance(nuke_node, nuke.Node):
            raise TypeError("nuke_node must be a Nuke Node object.")

        self.node_name = nuke_node.name()
        self.base_name = get_base_node_name(self.node_name)
        self.color_data = get_color_swatch_knobs(nuke_node)
        self._nuke_node = nuke_node # Keep a reference to the actual Nuke node for updates

    def to_json_data(self):
        """
        Returns the stored color data in a dictionary format suitable for JSON export.
        """
        return {
            "node_name": self.node_name,
            "base_name": self.base_name,
            "colors": self.color_data
        }

    def update_node_from_data(self, data_to_apply):
        """
        Updates the Nuke node's color swatch knobs with the provided data.
        """
        if not isinstance(data_to_apply, dict) or "colors" not in data_to_apply:
            print(f"Error: Invalid data format for node {self.node_name}. Skipping update.")
            return

        for knob_name, new_value in data_to_apply["colors"].items():
            if knob_name in self._nuke_node.knobs():
                knob = self._nuke_node[knob_name]
                if isinstance(knob, nuke.Color_Knob):
                    try:
                        knob.setValue(new_value)
                        print(f"Updated '{knob_name}' on '{self.node_name}' to {new_value}")
                    except Exception as e:
                        print(f"Could not set value for knob '{knob_name}' on node '{self.node_name}': {e}")
                else:
                    print(f"Warning: Knob '{knob_name}' on '{self.node_name}' is not a Color_Knob. Skipping.")
            else:
                print(f"Warning: Knob '{knob_name}' not found on node '{self.node_name}'. Skipping.")

# --- Main Export/Import Functions ---

def export_selected_node_color_data(file_path):
    """
    Exports color swatch data from all selected Nuke nodes to a JSON file.
    """
    selected_nodes = nuke.selectedNodes()
    if not selected_nodes:
        nuke.message("No nodes selected. Please select nodes to export.")
        return

    all_node_data = []
    for node in selected_nodes:
        node_color_instance = NodeColorData(node)
        all_node_data.append(node_color_instance.to_json_data())

    try:
        with open(file_path, 'w') as f:
            json.dump(all_node_data, f, indent=4)
        nuke.message(f"Successfully exported color data for {len(selected_nodes)} nodes to:\n{file_path}")
    except Exception as e:
        nuke.message(f"Error exporting data: {e}")

def import_color_data_to_selected_nodes(file_path):
    """
    Imports color swatch data from a JSON file and applies it to selected Nuke nodes.
    It attempts to match nodes based on their base names.
    """
    selected_nodes = nuke.selectedNodes()
    if not selected_nodes:
        nuke.message("No nodes selected. Please select nodes to import data onto.")
        return

    if not os.path.exists(file_path):
        nuke.message(f"Error: File not found at {file_path}")
        return

    try:
        with open(file_path, 'r') as f:
            imported_data = json.load(f)
    except json.JSONDecodeError as e:
        nuke.message(f"Error decoding JSON file: {e}")
        return
    except Exception as e:
        nuke.message(f"Error reading file: {e}")
        return

    if not isinstance(imported_data, list):
        nuke.message("Error: Imported JSON data is not in the expected list format.")
        return

    # Create a mapping from base_name to the actual data for quick lookup
    data_map = {item["base_name"]: item for item in imported_data}

    updated_count = 0
    for node in selected_nodes:
        target_base_name = get_base_node_name(node.name())

        # Find the best match: direct base_name, or if not found, use the first matching base_name from the imported data
        # This handles the "my_node_a" -&gt; "your_node_a" scenario
        data_to_apply = data_map.get(target_base_name)

        if not data_to_apply:
            # Fallback for more generic mapping if direct base name not found.
            # This is where "my_node_a" or "my_node_a56" can be applied to "your_node_a"
            # It implies a 1-to-1 mapping based on a common root or manual intervention
            # For simplicity, we'll try to match by exact base_name first.
            # If the user wants a more complex mapping (e.g., 'source_A' -&gt; 'target_B'),
            # they would need to manually choose the source data.
            # For now, we match source base_name to target base_name.
            print(f"No direct base name match for '{target_base_name}' in imported data. Skipping node {node.name()}")
            continue

        node_color_instance = NodeColorData(node) # Create an instance for the target node
        node_color_instance.update_node_from_data(data_to_apply)
        updated_count += 1

    nuke.message(f"Successfully updated color data for {updated_count} out of {len(selected_nodes)} selected nodes.")

# --- Nuke Menu Integration (Example - run this in Nuke's script editor) ---
# Note: This part needs to be run in Nuke for the menu items to appear.
def create_nuke_menu_items():
    menubar = nuke.menu('Nuke')
    nuke_python_menu = menubar.findItem('Python') or menubar.addMenu('Python')

    # Check if menu items already exist to avoid duplicates if script is run multiple times
    if not nuke_python_menu.findItem('Export Color Data'):
        nuke_python_menu.addCommand(
            'Export Color Data',
            lambda: export_selected_node_color_data(
                nuke.getFilename("Export Color Data", "*.json")
            ),
            'alt+e' # Optional hotkey
        )

    if not nuke_python_menu.findItem('Import Color Data'):
        nuke_python_menu.addCommand(
            'Import Color Data',
            lambda: import_color_data_to_selected_nodes(
                nuke.getFilename("Import Color Data", "*.json")
            ),
            'alt+i' # Optional hotkey
        )
    nuke.message("Nuke Color Data Manager menu items added to 'Python' menu.")

# Call this function to set up the menu items when the script is loaded in Nuke.
# If you put this script in your Nuke plugins folder, this call would typically
# be at the end of the file, or called from your menu.py.
# create_nuke_menu_items()

# --- Mock Nuke Environment for Standalone Testing (DO NOT RUN IN NUKE) ---
# This section is for demonstrating the logic outside of a running Nuke instance.
# In a real Nuke environment, 'nuke' would be pre-defined.
if 'nuke' not in globals():
    class MockColorKnob:
        def __init__(self, value=(1.0, 0.0, 0.0, 1.0)):
            self._value = list(value)
        def value(self):
            return tuple(self._value)
        def setValue(self, new_value):
            if isinstance(new_value, (list, tuple)) and len(new_value) == 4:
                self._value = list(new_value)
                # print(f"MockColorKnob set to: {self._value}")
            else:
                raise ValueError("Color must be a 4-tuple/list.")

    class MockNode:
        def __init__(self, name, knobs_data=None):
            self._name = name
            self._knobs = {}
            if knobs_data:
                for k_name, k_value in knobs_data.items():
                    self._knobs[k_name] = MockColorKnob(k_value)

        def name(self):
            return self._name

        def knobs(self):
            return self._knobs.keys()

        def __getitem__(self, key):
            if key in self._knobs:
                return self._knobs[key]
            raise KeyError(f"Knob '{key}' not found on node '{self._name}'")

        def Class(self): # Mimic Nuke node's Class() method
            return "SomeNodeType"

    class MockNuke:
        def __init__(self):
            self._selected_nodes = []

        def selectedNodes(self):
            return self._selected_nodes

        def setSelectedNodes(self, nodes):
            self._selected_nodes = nodes

        def message(self, msg):
            print(f"[Nuke Message] {msg}")

        def getFilename(self, title, filter):
            # In a real Nuke env, this opens a file dialog. For mock, just return a dummy path.
            print(f"[Nuke] Opened file dialog for: {title} ({filter})")
            return "mock_color_data.json" # Return a default mock file name

        def menu(self, name):
            # Mock for menu creation
            class MockMenu:
                def findItem(self, item_name): return None # Always return None for simplicity
                def addMenu(self, name): return self
                def addCommand(self, name, command, hotkey): print(f"Mock Menu: Added '{name}'")
            return MockMenu()

    # Initialize mock Nuke
    nuke = MockNuke()
    print("--- Running in Mock Nuke Environment ---")

    # --- Demo Usage with Mock Nodes ---
    if __name__ == "__main__":
        # Create some mock nodes
        node1 = MockNode("my_node_a", {"tint_color": (0.8, 0.1, 0.2, 1.0), "bg_color": (0.1, 0.5, 0.9, 1.0)})
        node2 = MockNode("my_node_a25", {"tint_color": (0.5, 0.5, 0.5, 1.0), "bg_color": (0.9, 0.8, 0.1, 1.0)})
        node3 = MockNode("my_node_b", {"tint_color": (0.2, 0.3, 0.4, 1.0), "border_color": (0.9, 0.6, 0.3, 1.0)})
        node4 = MockNode("my_node_c", {"tint_color": (0.0, 1.0, 0.0, 1.0)})

        # Another set of nodes to import onto
        target_node1 = MockNode("your_node_a", {"tint_color": (0.0, 0.0, 0.0, 1.0), "bg_color": (0.0, 0.0, 0.0, 1.0)})
        target_node2 = MockNode("your_node_a 4", {"tint_color": (0.0, 0.0, 0.0, 1.0), "bg_color": (0.0, 0.0, 0.0, 1.0)})
        target_node3 = MockNode("your_node_b", {"tint_color": (0.0, 0.0, 0.0, 1.0), "border_color": (0.0, 0.0, 0.0, 1.0)})
        target_node4 = MockNode("another_node_z", {"tint_color": (0.0, 0.0, 0.0, 1.0)})


        # --- Export Demo ---
        print("\n--- Demo: Exporting Data ---")
        nuke.setSelectedNodes([node1, node2, node3])
        export_file = "exported_colors.json"
        nuke.getFilename = lambda title, filter: export_file # Override getFilename for mock
        export_selected_node_color_data(export_file)

        print(f"\nContents of {export_file} after export:")
        with open(export_file, 'r') as f:
            print(json.dumps(json.load(f), indent=4))

        # --- Import Demo ---
        print("\n--- Demo: Importing Data ---")
        nuke.setSelectedNodes([target_node1, target_node2, target_node3, target_node4])
        import_file = "exported_colors.json" # Using the file just exported
        nuke.getFilename = lambda title, filter: import_file # Override getFilename for mock
        import_color_data_to_selected_nodes(import_file)

        print("\nState of target_node1 after import:")
        print(f"  tint_color: {target_node1['tint_color'].value()}")
        print(f"  bg_color: {target_node1['bg_color'].value()}")

        print("\nState of target_node2 (your_node_a 4) after import (should match my_node_a's data):")
        print(f"  tint_color: {target_node2['tint_color'].value()}")
        print(f"  bg_color: {target_node2['bg_color'].value()}")

        print("\nState of target_node3 (your_node_b) after import (should match my_node_b's data):")
        print(f"  tint_color: {target_node3['tint_color'].value()}")
        print(f"  border_color: {target_node3['border_color'].value()}")

        print("\nState of target_node4 (another_node_z) after import (no match, should be unchanged):")
        print(f"  tint_color: {target_node4['tint_color'].value()}")


        # Clean up mock file
        if os.path.exists(export_file):
            os.remove(export_file)
            print(f"\nCleaned up mock file: {export_file}")
</pre>

<div id="Regex for Character Base Names"><h1 id="Regex for Character Base Names" class="header"><a href="#Regex for Character Base Names">Regex for Character Base Names</a></h1></div>

<div id="Regex for Character Base Names-Question:"><h3 id="Question:" class="header"><a href="#Regex for Character Base Names-Question:">Question:</a></h3></div>

<p>
I want to analyze a list of strings in Python, and find the base name of each group. A group is defined by being the first section (or sections) separated by underscores. There a few markers that would inform the reader that the base name has been reached; for example, if there is "_Key" or "_Fill" in the string then the base name is most likely to be everything preceding those substrings.
</p>

<p>
There may be multiple base names in the list (almost always there will be), so I'd like to analyze all input strings and separate them into the group base names. Example strings:
</p>

<pre>
Denied_1_Key_Skin
Denied_1_Fill_Dress
Kitty_Key_Belt
Kitty_2_Key_Belt
Brian_Egg_Fill_Shoe1
Brian_Egg_Key_Sock
</pre>
<p>
...and the intended base name groups would be:
</p>
<pre>
Denied_1
Kitty
Kitty_2
Brian_Egg
</pre>
<p>
...Any ideas?
</p>

<div id="Regex for Character Base Names-Answer:"><h3 id="Answer:" class="header"><a href="#Regex for Character Base Names-Answer:">Answer:</a></h3></div>

<p>
Here are a few ways to find the base names of groups from a list of strings in Python.
</p>

<div id="Regex for Character Base Names-Using Regular Expressions"><h2 id="Using Regular Expressions" class="header"><a href="#Regex for Character Base Names-Using Regular Expressions">Using Regular Expressions</a></h2></div>

<p>
Regular expressions are ideal for pattern-matching tasks like this. You can define a pattern that looks for the special "marker" substrings and captures everything before them.
</p>

<pre python>
import re

def find_base_names_regex(strings):
    """
    Finds base names using a regular expression.
    
    Args:
        strings (list): A list of input strings.
        
    Returns:
        set: A set of unique base names.
    """
    base_names = set()
    # The pattern looks for any characters (.*) at the beginning of the string,
    # followed by one of the specified markers.
    # The '?' makes the matching non-greedy, ensuring we stop at the first marker.
    pattern = re.compile(r'(.+?)(_Key|_Fill)')
    
    for s in strings:
        match = pattern.search(s)
        if match:
            # The first group (match.group(1)) contains the captured base name.
            base_names.add(match.group(1))
            
    return base_names

# Example usage:

input_strings = [
    "Denied_1_Key_Skin",
    "Denied_1_Fill_Dress",
    "Kitty_Key_Belt",
    "Kitty_2_Key_Belt",
    "Brian_Egg_Fill_Shoe1",
    "Brian_Egg_Key_Sock"
]

print(f"Base names found using regex: {find_base_names_regex(input_strings)}")
</pre>
<p>
<br>
</p>
<ul>
<li>
The pattern (.+?)(_Key|_Fill) works as follows:

<ul>
<li>
<code>(.+?)</code> : This is the capturing group.

<li>
<code>(</code> and <code>)</code> : define the group to capture.

<li>
<code>.</code> : matches any character.

<li>
<code>+</code> : matches one or more of the preceding character.

<li>
<code>?</code> : makes the + non-greedy, so it matches the shortest possible string.

<li>
<code>(_Key|_Fill)</code> : This is the second group that matches either "_Key" or "_Fill." The | acts as an "OR" operator.

</ul>
</ul>
<div id="Regex for Character Base Names-Using String Splitting and Looping"><h2 id="Using String Splitting and Looping" class="header"><a href="#Regex for Character Base Names-Using String Splitting and Looping">Using String Splitting and Looping</a></h2></div>

<p>
You can also solve this without regular expressions by splitting each string by the underscore _ delimiter and iterating through the parts. This can be more readable for simpler cases.
</p>

<pre python>
def find_base_names_split(strings):
    """
    Finds base names by splitting strings and checking for markers.
    
    Args:
        strings (list): A list of input strings.
        
    Returns:
        set: A set of unique base names.
    """
    base_names = set()
    markers = {"Key", "Fill"}
    
    for s in strings:
        parts = s.split('_')
        base_name_parts = []
        for part in parts:
            if part in markers:
                # Once a marker is found, everything before it is the base name.
                base_names.add("_".join(base_name_parts))
                break
            else:
                base_name_parts.append(part)
                
    return base_names

# Example usage:
input_strings = [
    "Denied_1_Key_Skin",
    "Denied_1_Fill_Dress",
    "Kitty_Key_Belt",
    "Kitty_2_Key_Belt",
    "Brian_Egg_Fill_Shoe1",
    "Brian_Egg_Key_Sock"
]

print(f"Base names found using string splitting: {find_base_names_split(input_strings)}")
</pre>

<p>
Both methods will produce the desired output: {&amp;#39;Denied_1&amp;#39;, &amp;#39;Brian_Egg&amp;#39;, &amp;#39;Kitty&amp;#39;, &amp;#39;Kitty_2&amp;#39;}. The regular expression method is generally more concise and powerful for more complex patterns, while the string splitting method can be easier to understand for beginners.
</p>

<div id="Another Approach (Qt Dialot)"><h1 id="Another Approach (Qt Dialot)" class="header"><a href="#Another Approach (Qt Dialot)">Another Approach (Qt Dialot)</a></h1></div>

<div id="Another Approach (Qt Dialot)-Question"><h3 id="Question" class="header"><a href="#Another Approach (Qt Dialot)-Question">Question</a></h3></div>

<p>
I want to make a Qt (Pyside2) Dialog for Nuke. It must present a list of possible base names (retrieved from nodes of a certain type in Nuke), so that the user can select which nodes (that start with the base name string) to perform analysis on each node, and export a JSON file of parameters with the base name as the potential name of the file, to show up as a 'save as' window to the user.
Can you give me an outline and an example script that could do this?
</p>

<div id="Another Approach (Qt Dialot)-Answer"><h3 id="Answer" class="header"><a href="#Another Approach (Qt Dialot)-Answer">Answer</a></h3></div>

<div id="Another Approach (Qt Dialot)-Outline for the Nuke Dialog"><h2 id="Outline for the Nuke Dialog" class="header"><a href="#Another Approach (Qt Dialot)-Outline for the Nuke Dialog">Outline for the Nuke Dialog</a></h2></div>

<ul>
<li>
Import necessary libraries: PySide2 for the UI, nuke for node interaction, json for file export, and os for path manipulation.

<li>
Define the main dialog class: A custom class inheriting from PySide2.QtWidgets.QDialog.

<li>
Initialize the UI components within the _<em>init</em>_ method.

<li>
Set up a QVBoxLayout to organize the widgets.

<li>
Create a QListWidget to display the base names.

<li>
Add "OK" and "Cancel" buttons using QDialogButtonBox.

<li>
Add a QPushButton for "Export JSON".

</ul>
<div id="Another Approach (Qt Dialot)-Populate the QListWidget:"><h2 id="Populate the QListWidget:" class="header"><a href="#Another Approach (Qt Dialot)-Populate the QListWidget:">Populate the QListWidget:</a></h2></div>

<ul>
<li>
Create a function to get all nodes of a specific type (e.g., "Read" nodes).

<li>
Iterate through these nodes to extract the base names based on your underscore-separated pattern. Store these unique base names in a Python set to avoid duplicates.

<li>
Add the unique base names to the QListWidget.

<li>
Connect UI signals to functions:

<li>
Connect the "OK" button's accepted signal to a function that handles the main logic.

<li>
Connect the "Export JSON" button's clicked signal to a function that handles the export process.

</ul>
<div id="Another Approach (Qt Dialot)-Implement the core logic:"><h2 id="Implement the core logic:" class="header"><a href="#Another Approach (Qt Dialot)-Implement the core logic:">Implement the core logic:</a></h2></div>

<ul>
<li>
<span id="Another Approach (Qt Dialot)-Implement the core logic:-Base Name Extraction Function"></span><strong id="Base Name Extraction Function">Base Name Extraction Function</strong>: This function will contain the logic to parse node names and find the base names. A regular expression is a robust way to do this.

<li>
<span id="Another Approach (Qt Dialot)-Implement the core logic:-Analysis and Export Function"></span><strong id="Analysis and Export Function">Analysis and Export Function</strong>: This function is triggered by the "Export JSON" button.

<li>
Get the selected base names from the QListWidget.

<li>
For each selected base name, find all the nodes in the Nuke script whose names start with that base name.

<li>
Iterate through these nodes and collect relevant parameters (e.g., name, class, knob values) into a Python dictionary.

<li>
Use PySide2.QtWidgets.QFileDialog.getSaveFileName to show a "Save As" dialog, suggesting the base name as the default file name.

<li>
Save the collected dictionary to a JSON file at the user-specified path.

<li>
<span id="Another Approach (Qt Dialot)-Implement the core logic:-Launch the dialog"></span><strong id="Launch the dialog">Launch the dialog</strong>: A main function to instantiate and show the dialog. The showModal() method is used to make it a blocking dialog that prevents interaction with Nuke's main interface until it is closed.

</ul>
<div id="Another Approach (Qt Dialot)-Implement the core logic:-Example Nuke Script"><h3 id="Example Nuke Script" class="header"><a href="#Another Approach (Qt Dialot)-Implement the core logic:-Example Nuke Script">Example Nuke Script</a></h3></div>

<p>
Here is an example script that implements this functionality. You can save this as a Python file and run it from Nuke's Script Editor.
</p>

<pre Python>
#
# nuke_json_export_tool.py
#
import nuke
import json
import os
import re

from PySide2.QtWidgets import (
    QDialog, QVBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QDialogButtonBox, QFileDialog, QApplication
)
from PySide2.QtCore import Qt

def get_base_names():
    """
    Finds unique base names from all 'Read' nodes in the Nuke script.
    A base name is defined as the part of the name before '_Key' or '_Fill'.
    """
    base_names = set()
    
    # This regular expression captures the group name
    pattern = re.compile(r'(.+?)_Key|(.+?)_Fill')
    
    # Get all nodes of a specific type. Let's use 'Read' nodes for this example.
    for node in nuke.allNodes('Read'):
        node_name = node.name()
        match = pattern.search(node_name)
        if match:
            # The pattern has two capturing groups, so we check which one matched.
            base_name = match.group(1) or match.group(2)
            base_names.add(base_name)
            
    return sorted(list(base_names))

class BaseNameExporterDialog(QDialog):
    """
    A Qt Dialog for Nuke to select base names and export node parameters.
    """
    def __init__(self, parent=None):
        super(BaseNameExporterDialog, self).__init__(parent)
        
        self.setWindowTitle("Base Name Exporter")
        self.setMinimumSize(400, 300)
        
        self.base_names = get_base_names()
        
        self.setup_ui()
        self.populate_list()
        self.connect_signals()
        
    def setup_ui(self):
        """
        Builds the UI layout and widgets.
        """
        self.main_layout = QVBoxLayout(self)
        
        # QListWidget for displaying base names
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QListWidget.MultiSelection)
        self.main_layout.addWidget(self.list_widget)
        
        # Button box with OK and Cancel
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        self.main_layout.addWidget(self.button_box)
        
        # Export button
        self.export_button = QPushButton("Export JSON")
        self.main_layout.addWidget(self.export_button)
        
    def populate_list(self):
        """
        Adds the retrieved base names to the list widget.
        """
        if not self.base_names:
            QListWidgetItem("No matching nodes found.", self.list_widget)
            self.export_button.setEnabled(False) # Disable if no nodes
        else:
            self.list_widget.addItems(self.base_names)
    
    def connect_signals(self):
        """
        Connects UI signals to their respective functions.
        """
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.export_button.clicked.connect(self.export_json)

    def export_json(self):
        """
        Handles the JSON export process.
        """
        # Get selected base names from the list widget
        selected_items = self.list_widget.selectedItems()
        if not selected_items:
            nuke.message("Please select at least one base name.")
            return

        for item in selected_items:
            base_name = item.text()
            
            # Find all nodes that start with the selected base name
            nodes_to_export = [
                n for n in nuke.allNodes() 
                if n.name().startswith(base_name)
            ]
            
            if not nodes_to_export:
                continue

            export_data = {}
            for node in nodes_to_export:
                node_data = {
                    "class": node.Class(),
                    "knobs": {}
                }
                # Collect all knob values
                for knob in node.allKnobs():
                    try:
                        node_data["knobs"][knob.name()] = knob.value()
                    except:
                        # Some knobs (e.g., array knobs) may have issues with .value()
                        continue
                export_data[node.name()] = node_data

            # Use a QFileDialog for "Save As"
            # Set a default file name based on the base name
            default_path = os.path.join(os.path.expanduser("~"), f"{base_name}.json")
            
            file_path, _ = QFileDialog.getSaveFileName(
                self, 
                "Save JSON File", 
                default_path,
                "JSON Files (*.json);;All Files (*)"
            )
            
            if file_path:
                try:
                    with open(file_path, 'w') as f:
                        json.dump(export_data, f, indent=4)
                    nuke.message(f"Successfully exported data for '{base_name}' to:\n{file_path}")
                except Exception as e:
                    nuke.message(f"Error exporting JSON for '{base_name}':\n{e}")

    def show(self):
        """
        Shows the dialog as a modal window, parented to Nuke's main window.
        """
        # Get the main Nuke window to parent the dialog to it.
        # This prevents the dialog from being hidden when Nuke is not active.
        nuke_app = QApplication.instance()
        if nuke_app:
            main_window = [
                w for w in nuke_app.allWidgets() 
                if w.objectName() == "centralwidget"
            ][0].parent()
        else:
            main_window = None

        super(BaseNameExporterDialog, self).setParent(main_window)
        super(BaseNameExporterDialog, self).show()


# To run the script in Nuke's Script Editor:
if __name__ == '__main__':
    # Since the script can be run multiple times, handle existing instances.
    try:
        dialog.close()
    except NameError:
        pass
    
    dialog = BaseNameExporterDialog()
    dialog.show()
</pre>



<p>
<a href="pmount_index.html">PMount</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
