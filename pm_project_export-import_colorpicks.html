<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>pm_project_export-import_colorpicks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">Index</a>
</p>

<p>
<a href="pmount_index.html">PMount</a>
</p>

<div id="Import/Export ColorPick Colors"><h1 id="Import/Export ColorPick Colors" class="header"><a href="#Import/Export ColorPick Colors">Import/Export ColorPick Colors</a></h1></div>

<div id="Import/Export ColorPick Colors-Discussion"><h2 id="Discussion" class="header"><a href="#Import/Export ColorPick Colors-Discussion">Discussion</a></h2></div>

<div id="Import/Export ColorPick Colors-Discussion-Question"><h3 id="Question" class="header"><a href="#Import/Export ColorPick Colors-Discussion-Question">Question</a></h3></div>

<p>
I want to write a Python script for Nuke, and I want it to analyze a selection of specific nodes, storing color swatch knobs as JSON data to export, and to import onto a similar selection of nodes.
</p>

<p>
I'm thinking to create a class to represent each node (they're all of the same type), and to store the data within the instance.
</p>

<ul>
<li>
Perhaps an <code>__init__</code> method to load the current values, and a method to update them with an imported JSON set.

<li>
Each node will have a name that defines it (for data export and import), although the nodes will have a numeric suffix that I will have to ignore. (For example: "my_node_a" and my_node_a25" would be essentially the same thing.)

<li>
I'd also like the facility to import "my_node_a" or "my_node_a56" onto "your_node_a", or "your_node_a 4".

</ul>
<p>
Can you give me an outline as to how to structure this project, and even suggest the actual code?
</p>


<div id="Import/Export ColorPick Colors-Discussion-Gemini Answer"><h3 id="Gemini Answer" class="header"><a href="#Import/Export ColorPick Colors-Discussion-Gemini Answer">Gemini Answer</a></h3></div>

<p>
Here's a detailed outline and a Python script for your Nuke project, focusing on a class-based approach to manage color swatch knob data for export and import.
</p>

<p>
The script will define a NodeColorData class to handle the logic for individual nodes, along with functions for exporting and importing data from a selection of Nuke nodes to a JSON file.
</p>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager"><h2 id="Nuke Color Swatch Data Manager" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager">Nuke Color Swatch Data Manager</a></h2></div>
<p>
Aug 23 at 10:40 AM
</p>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline"><h3 id="Project Structure Outline" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline">Project Structure Outline</a></h3></div>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:"><h4 id="get_base_node_name(node_name) Function:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:">get_base_node_name(node_name) Function:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: To normalize node names by removing numerical suffixes (e.g., my_node_a25 becomes my_node_a). This is crucial for matching nodes during import.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_base_node_name(node_name) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>: Uses regular expressions to identify and strip the suffixes.

</ul>
<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:"><h4 id="get_color_swatch_knobs(node) Function:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:">get_color_swatch_knobs(node) Function:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: To iterate through a given Nuke node and identify all nuke.Color_Knob types.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-get_color_swatch_knobs(node) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>: Returns a dictionary where keys are knob names and values are their current RGBA tuples.

</ul>
<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Note on Help Functions:"><h4 id="Note on Help Functions:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Note on Help Functions:">Note on Help Functions:</a></h4></div>

<p>
The helper functions get_base_node_name and get_color_swatch_knobs are placed outside the NodeColorData class because they perform generic, stateless operations that don't depend on or modify the internal state of a specific NodeColorData object. They serve as utility functions that can be used independently by any part of the program, not just by instances of the NodeColorData class.
</p>

<div id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:"><h4 id="Separating these functions from the class provides several benefits:" class="header"><a href="#Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:">Separating these functions from the class provides several benefits:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Reusability ‚ôªÔ∏è"></span><strong id="Reusability ‚ôªÔ∏è">Reusability ‚ôªÔ∏è</strong>: These functions can be used by other classes or scripts that need to perform the same task without having to create an instance of NodeColorData. For example, get_base_node_name is used by both the NodeColorData class and the import_color_data_to_selected_nodes function.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Encapsulation &amp; Cohesion üì¶"></span><strong id="Encapsulation &amp; Cohesion üì¶">Encapsulation &amp; Cohesion üì¶</strong>: The NodeColorData class is designed to represent and manage the data for a single Nuke node. The helper functions, which extract information from a Nuke node, are logically distinct from the object that holds that information. Keeping them separate improves the class's cohesion by focusing its responsibilities on data management.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Clarity and Maintainability üßπ"></span><strong id="Clarity and Maintainability üßπ">Clarity and Maintainability üßπ</strong>: By placing generic utility functions outside the class, the class definition becomes cleaner and more focused. A developer reading the NodeColorData class can quickly understand its core purpose without being distracted by the implementation details of how data is extracted from a Nuke node.

<li>
<span id="Import/Export ColorPick Colors-Nuke Color Swatch Data Manager-Project Structure Outline-Separating these functions from the class provides several benefits:-Loose Coupling üîó"></span><strong id="Loose Coupling üîó">Loose Coupling üîó</strong>: The class is less tightly coupled to the implementation details of the helper functions. If the logic for getting a base node name or color knobs changes, only the helper function needs to be modified, not the class that uses it.

</ul>
<p>
In essence, the class methods (_<em>init</em>_, to_json_data, update_node_from_data) are actions that an instance of NodeColorData performs on its own data, whereas the helper functions are a toolbox of generic operations used by the class and other parts of the program to accomplish their tasks.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:"><h2 id="NodeColorData Class:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:">NodeColorData Class:</a></h2></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Purpose"></span><strong id="Purpose">Purpose</strong>: Encapsulates the logic and data for a single Nuke node's color swatches. This makes it easier to manage and transfer data.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-_<em>init</em>_(self, nuke_node)"></span><strong id="_<em>init</em>_(self, nuke_node)">_<em>init</em>_(self, nuke_node)</strong>:

<ul>
<li>
Takes an actual Nuke node object as an argument.

<li>
Stores the node's full name (self.node_name).

<li>
Calls get_base_node_name() to determine and store self.base_name.

<li>
Calls get_color_swatch_knobs() to extract and store all relevant color data in self.color_data.

<li>
Keeps a reference to the nuke_node for later updates.

</ul>
<li>
to_json_data(self):

<ul>
<li>
Returns a dictionary containing the node_name, base_name, and color_data of the instance. This dictionary is directly serializable into JSON.

</ul>
<li>
update_node_from_data(self, data_to_apply):

<ul>
<li>
Takes a dictionary (which would come from parsed JSON data).

<li>
Iterates through the colors in data_to_apply.

<li>
For each color knob, it finds the corresponding knob on the actual _nuke_node and attempts to set its value. Includes error handling for missing knobs or incorrect types.

</ul>
</ul>
<div id="Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:"><h3 id="export_selected_node_color_data(file_path) Function:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:">export_selected_node_color_data(file_path) Function:</a></h3></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: The main function to initiate the export process.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-export_selected_node_color_data(file_path) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>:

<ul>
<li>
Gets all currently selected nodes in Nuke.

<li>
Creates a NodeColorData instance for each selected node.

<li>
Collects the JSON-ready data from each instance into a list.

<li>
Writes this list to the specified file_path as a pretty-printed JSON file.

<li>
Provides Nuke messages for success or failure.

</ul>
</ul>
<div id="Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:"><h3 id="import_color_data_to_selected_nodes(file_path) Function:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:">import_color_data_to_selected_nodes(file_path) Function:</a></h3></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:-Purpose"></span><strong id="Purpose">Purpose</strong>: The main function to initiate the import process.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-import_color_data_to_selected_nodes(file_path) Function:-Implementation"></span><strong id="Implementation">Implementation</strong>:

<ul>
<li>
Gets all currently selected nodes in Nuke (these are the target nodes).

<li>
Reads the JSON data from the specified file_path.

<li>
Creates a mapping from base_name to the imported color data for efficient lookup.

<li>
Iterates through each selected target node:

<li>
Determines its target_base_name.

<li>
Looks up matching data in the data_map using the target_base_name. This handles the "my_node_a" -&gt; "your_node_a" scenario and also my_node_a25 -&gt; your_node_a 4 because both will resolve to _a base name.

</ul>
<li>
If a match is found, creates a NodeColorData instance for the target node and calls its update_node_from_data() method.

<li>
Provides Nuke messages for success or failure.

</ul>
<div id="Import/Export ColorPick Colors-NodeColorData Class:-Nuke Menu Integration (Optional but Recommended):"><h3 id="Nuke Menu Integration (Optional but Recommended):" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Nuke Menu Integration (Optional but Recommended):">Nuke Menu Integration (Optional but Recommended):</a></h3></div>

<p>
A function <code>create_nuke_menu_items()</code> demonstrates how to add these export and import functionalities to Nuke's Python menu, making them easily accessible.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:"><h3 id="Mock Nuke Environment:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:">Mock Nuke Environment:</a></h3></div>

<p>
Included for standalone testing of the Python logic without needing Nuke itself. This creates fake nuke objects (MockNode, MockColorKnob, MockNuke) that mimic the behavior necessary for the script. This part should not be run within a real Nuke session.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Conclusion and Suggestions"><h4 id="Conclusion and Suggestions" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Conclusion and Suggestions">Conclusion and Suggestions</a></h4></div>

<p>
This script provides a robust framework for managing your color swatch data in Nuke. The class-based approach makes the code modular and easier to maintain. The get_base_node_name function handles the numerical suffixes, and the import logic is designed to be flexible, allowing you to transfer data between similarly named node sets.
</p>

<div id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:"><h4 id="Here are a few suggestions for further development:" class="header"><a href="#Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:">Here are a few suggestions for further development:</a></h4></div>

<ul>
<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Error Handling and UI Feedback"></span><strong id="Error Handling and UI Feedback">Error Handling and UI Feedback</strong>: While nuke.message is used, you could implement more sophisticated UI feedback for errors, such as a custom Nuke panel showing detailed logs of successful and failed updates.
  <span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Knob Type Customization"></span><strong id="Knob Type Customization">Knob Type Customization</strong>: The get_color_swatch_knobs function specifically looks for nuke.Color_Knob types. If you have custom nodes or other 4-float knobs that should be treated as colors, you might need to extend this function to include logic to identify them based on name patterns or other attributes.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Advanced Mapping"></span><strong id="Advanced Mapping">Advanced Mapping</strong>: For more complex scenarios, where a node with base name "A" might need to receive data from a node with base name "B" in the JSON file, you could introduce a UI element during import to allow the user to manually map source base names to target base names.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Preserving User Selections"></span><strong id="Preserving User Selections">Preserving User Selections</strong>: The current getFilename calls for export/import rely on Nuke's file browser. You might want to save the last used directory to quickly access it again.

<li>
<span id="Import/Export ColorPick Colors-NodeColorData Class:-Mock Nuke Environment:-Here are a few suggestions for further development:-Undo Support"></span><strong id="Undo Support">Undo Support</strong>: For production scripts, it's good practice to wrap changes in a nuke.Undo.begin() and nuke.Undo.end() block to allow users to undo the import operation.

</ul>
<div id="GEMINI SUGGESTED OUTLINE"><h1 id="GEMINI SUGGESTED OUTLINE" class="header"><a href="#GEMINI SUGGESTED OUTLINE">GEMINI SUGGESTED OUTLINE</a></h1></div>

<table>
<tr>
<td>
RAW SUGGESTION - UNTESTED
</td>
</tr>
</table>
  
<pre python>
import nuke
import json
import re
import os

# --- Helper Functions ---

def get_base_node_name(node_name):
    """
    Extracts the base name of a node, ignoring trailing numbers or numbers preceded by an underscore.
    Examples:
    "my_node_a" -&gt; "my_node_a"
    "my_node_a25" -&gt; "my_node_a"
    "my_node_b_1" -&gt; "my_node_b"
    "my_node_c_001_final" -&gt; "my_node_c_001_final" (only trailing numbers are stripped)
    """
    # Pattern to match numbers at the end of the string, optionally preceded by an underscore
    match = re.match(r"^(.*?)(?:[_-]?\d+)?$", node_name)
    if match:
        return match.group(1).rstrip('_') # Remove any trailing underscore left by the regex
    return node_name

def get_color_swatch_knobs(node):
    """
    Retrieves all color swatch knob names and their current values from a given Nuke node.
    Assumes color swatch knobs are 4-tuple (RGBA) floats.
    """
    color_knobs = {}
    # Iterate through all knobs on the node
    for knob_name in node.knobs():
        knob = node[knob_name]
        # Check if the knob is a color knob (e.g., a Color_Knob or has 4 channels)
        # Nuke's built-in Color_Knob is the most common. We'll also check for 4-float knobs
        # that might represent a color if they are explicitly desired.
        if isinstance(knob, nuke.Color_Knob):
            color_knobs[knob_name] = list(knob.value()) # Store as a list of RGBA floats
        # You can extend this to include other 4-float knobs if they represent colors
        # For example, if you have custom nodes with 'color' or 'tint' knobs that are just 4 floats:
        # elif knob.Class() == 'Array_Knob' and knob.arraySize() == 4 and knob.type() == 'float':
        #     if any(k in knob_name.lower() for k in ['color', 'tint', 'fill']):
        #         color_knobs[knob_name] = list(knob.value())
    return color_knobs

# --- NodeColorData Class ---

class NodeColorData:
    """
    Represents the color swatch data for a single Nuke node, providing
    methods for loading, exporting, and updating.
    """
    def __init__(self, nuke_node):
        """
        Initializes the NodeColorData instance by extracting color swatch
        knob values from the given Nuke node.
        """
        if not isinstance(nuke_node, nuke.Node):
            raise TypeError("nuke_node must be a Nuke Node object.")

        self.node_name = nuke_node.name()
        self.base_name = get_base_node_name(self.node_name)
        self.color_data = get_color_swatch_knobs(nuke_node)
        self._nuke_node = nuke_node # Keep a reference to the actual Nuke node for updates

    def to_json_data(self):
        """
        Returns the stored color data in a dictionary format suitable for JSON export.
        """
        return {
            "node_name": self.node_name,
            "base_name": self.base_name,
            "colors": self.color_data
        }

    def update_node_from_data(self, data_to_apply):
        """
        Updates the Nuke node's color swatch knobs with the provided data.
        """
        if not isinstance(data_to_apply, dict) or "colors" not in data_to_apply:
            print(f"Error: Invalid data format for node {self.node_name}. Skipping update.")
            return

        for knob_name, new_value in data_to_apply["colors"].items():
            if knob_name in self._nuke_node.knobs():
                knob = self._nuke_node[knob_name]
                if isinstance(knob, nuke.Color_Knob):
                    try:
                        knob.setValue(new_value)
                        print(f"Updated '{knob_name}' on '{self.node_name}' to {new_value}")
                    except Exception as e:
                        print(f"Could not set value for knob '{knob_name}' on node '{self.node_name}': {e}")
                else:
                    print(f"Warning: Knob '{knob_name}' on '{self.node_name}' is not a Color_Knob. Skipping.")
            else:
                print(f"Warning: Knob '{knob_name}' not found on node '{self.node_name}'. Skipping.")

# --- Main Export/Import Functions ---

def export_selected_node_color_data(file_path):
    """
    Exports color swatch data from all selected Nuke nodes to a JSON file.
    """
    selected_nodes = nuke.selectedNodes()
    if not selected_nodes:
        nuke.message("No nodes selected. Please select nodes to export.")
        return

    all_node_data = []
    for node in selected_nodes:
        node_color_instance = NodeColorData(node)
        all_node_data.append(node_color_instance.to_json_data())

    try:
        with open(file_path, 'w') as f:
            json.dump(all_node_data, f, indent=4)
        nuke.message(f"Successfully exported color data for {len(selected_nodes)} nodes to:\n{file_path}")
    except Exception as e:
        nuke.message(f"Error exporting data: {e}")

def import_color_data_to_selected_nodes(file_path):
    """
    Imports color swatch data from a JSON file and applies it to selected Nuke nodes.
    It attempts to match nodes based on their base names.
    """
    selected_nodes = nuke.selectedNodes()
    if not selected_nodes:
        nuke.message("No nodes selected. Please select nodes to import data onto.")
        return

    if not os.path.exists(file_path):
        nuke.message(f"Error: File not found at {file_path}")
        return

    try:
        with open(file_path, 'r') as f:
            imported_data = json.load(f)
    except json.JSONDecodeError as e:
        nuke.message(f"Error decoding JSON file: {e}")
        return
    except Exception as e:
        nuke.message(f"Error reading file: {e}")
        return

    if not isinstance(imported_data, list):
        nuke.message("Error: Imported JSON data is not in the expected list format.")
        return

    # Create a mapping from base_name to the actual data for quick lookup
    data_map = {item["base_name"]: item for item in imported_data}

    updated_count = 0
    for node in selected_nodes:
        target_base_name = get_base_node_name(node.name())

        # Find the best match: direct base_name, or if not found, use the first matching base_name from the imported data
        # This handles the "my_node_a" -&gt; "your_node_a" scenario
        data_to_apply = data_map.get(target_base_name)

        if not data_to_apply:
            # Fallback for more generic mapping if direct base name not found.
            # This is where "my_node_a" or "my_node_a56" can be applied to "your_node_a"
            # It implies a 1-to-1 mapping based on a common root or manual intervention
            # For simplicity, we'll try to match by exact base_name first.
            # If the user wants a more complex mapping (e.g., 'source_A' -&gt; 'target_B'),
            # they would need to manually choose the source data.
            # For now, we match source base_name to target base_name.
            print(f"No direct base name match for '{target_base_name}' in imported data. Skipping node {node.name()}")
            continue

        node_color_instance = NodeColorData(node) # Create an instance for the target node
        node_color_instance.update_node_from_data(data_to_apply)
        updated_count += 1

    nuke.message(f"Successfully updated color data for {updated_count} out of {len(selected_nodes)} selected nodes.")

# --- Nuke Menu Integration (Example - run this in Nuke's script editor) ---
# Note: This part needs to be run in Nuke for the menu items to appear.
def create_nuke_menu_items():
    menubar = nuke.menu('Nuke')
    nuke_python_menu = menubar.findItem('Python') or menubar.addMenu('Python')

    # Check if menu items already exist to avoid duplicates if script is run multiple times
    if not nuke_python_menu.findItem('Export Color Data'):
        nuke_python_menu.addCommand(
            'Export Color Data',
            lambda: export_selected_node_color_data(
                nuke.getFilename("Export Color Data", "*.json")
            ),
            'alt+e' # Optional hotkey
        )

    if not nuke_python_menu.findItem('Import Color Data'):
        nuke_python_menu.addCommand(
            'Import Color Data',
            lambda: import_color_data_to_selected_nodes(
                nuke.getFilename("Import Color Data", "*.json")
            ),
            'alt+i' # Optional hotkey
        )
    nuke.message("Nuke Color Data Manager menu items added to 'Python' menu.")

# Call this function to set up the menu items when the script is loaded in Nuke.
# If you put this script in your Nuke plugins folder, this call would typically
# be at the end of the file, or called from your menu.py.
# create_nuke_menu_items()

# --- Mock Nuke Environment for Standalone Testing (DO NOT RUN IN NUKE) ---
# This section is for demonstrating the logic outside of a running Nuke instance.
# In a real Nuke environment, 'nuke' would be pre-defined.
if 'nuke' not in globals():
    class MockColorKnob:
        def __init__(self, value=(1.0, 0.0, 0.0, 1.0)):
            self._value = list(value)
        def value(self):
            return tuple(self._value)
        def setValue(self, new_value):
            if isinstance(new_value, (list, tuple)) and len(new_value) == 4:
                self._value = list(new_value)
                # print(f"MockColorKnob set to: {self._value}")
            else:
                raise ValueError("Color must be a 4-tuple/list.")

    class MockNode:
        def __init__(self, name, knobs_data=None):
            self._name = name
            self._knobs = {}
            if knobs_data:
                for k_name, k_value in knobs_data.items():
                    self._knobs[k_name] = MockColorKnob(k_value)

        def name(self):
            return self._name

        def knobs(self):
            return self._knobs.keys()

        def __getitem__(self, key):
            if key in self._knobs:
                return self._knobs[key]
            raise KeyError(f"Knob '{key}' not found on node '{self._name}'")

        def Class(self): # Mimic Nuke node's Class() method
            return "SomeNodeType"

    class MockNuke:
        def __init__(self):
            self._selected_nodes = []

        def selectedNodes(self):
            return self._selected_nodes

        def setSelectedNodes(self, nodes):
            self._selected_nodes = nodes

        def message(self, msg):
            print(f"[Nuke Message] {msg}")

        def getFilename(self, title, filter):
            # In a real Nuke env, this opens a file dialog. For mock, just return a dummy path.
            print(f"[Nuke] Opened file dialog for: {title} ({filter})")
            return "mock_color_data.json" # Return a default mock file name

        def menu(self, name):
            # Mock for menu creation
            class MockMenu:
                def findItem(self, item_name): return None # Always return None for simplicity
                def addMenu(self, name): return self
                def addCommand(self, name, command, hotkey): print(f"Mock Menu: Added '{name}'")
            return MockMenu()

    # Initialize mock Nuke
    nuke = MockNuke()
    print("--- Running in Mock Nuke Environment ---")

    # --- Demo Usage with Mock Nodes ---
    if __name__ == "__main__":
        # Create some mock nodes
        node1 = MockNode("my_node_a", {"tint_color": (0.8, 0.1, 0.2, 1.0), "bg_color": (0.1, 0.5, 0.9, 1.0)})
        node2 = MockNode("my_node_a25", {"tint_color": (0.5, 0.5, 0.5, 1.0), "bg_color": (0.9, 0.8, 0.1, 1.0)})
        node3 = MockNode("my_node_b", {"tint_color": (0.2, 0.3, 0.4, 1.0), "border_color": (0.9, 0.6, 0.3, 1.0)})
        node4 = MockNode("my_node_c", {"tint_color": (0.0, 1.0, 0.0, 1.0)})

        # Another set of nodes to import onto
        target_node1 = MockNode("your_node_a", {"tint_color": (0.0, 0.0, 0.0, 1.0), "bg_color": (0.0, 0.0, 0.0, 1.0)})
        target_node2 = MockNode("your_node_a 4", {"tint_color": (0.0, 0.0, 0.0, 1.0), "bg_color": (0.0, 0.0, 0.0, 1.0)})
        target_node3 = MockNode("your_node_b", {"tint_color": (0.0, 0.0, 0.0, 1.0), "border_color": (0.0, 0.0, 0.0, 1.0)})
        target_node4 = MockNode("another_node_z", {"tint_color": (0.0, 0.0, 0.0, 1.0)})


        # --- Export Demo ---
        print("\n--- Demo: Exporting Data ---")
        nuke.setSelectedNodes([node1, node2, node3])
        export_file = "exported_colors.json"
        nuke.getFilename = lambda title, filter: export_file # Override getFilename for mock
        export_selected_node_color_data(export_file)

        print(f"\nContents of {export_file} after export:")
        with open(export_file, 'r') as f:
            print(json.dumps(json.load(f), indent=4))

        # --- Import Demo ---
        print("\n--- Demo: Importing Data ---")
        nuke.setSelectedNodes([target_node1, target_node2, target_node3, target_node4])
        import_file = "exported_colors.json" # Using the file just exported
        nuke.getFilename = lambda title, filter: import_file # Override getFilename for mock
        import_color_data_to_selected_nodes(import_file)

        print("\nState of target_node1 after import:")
        print(f"  tint_color: {target_node1['tint_color'].value()}")
        print(f"  bg_color: {target_node1['bg_color'].value()}")

        print("\nState of target_node2 (your_node_a 4) after import (should match my_node_a's data):")
        print(f"  tint_color: {target_node2['tint_color'].value()}")
        print(f"  bg_color: {target_node2['bg_color'].value()}")

        print("\nState of target_node3 (your_node_b) after import (should match my_node_b's data):")
        print(f"  tint_color: {target_node3['tint_color'].value()}")
        print(f"  border_color: {target_node3['border_color'].value()}")

        print("\nState of target_node4 (another_node_z) after import (no match, should be unchanged):")
        print(f"  tint_color: {target_node4['tint_color'].value()}")


        # Clean up mock file
        if os.path.exists(export_file):
            os.remove(export_file)
            print(f"\nCleaned up mock file: {export_file}")
</pre>




<p>
<a href="pmount_index.html">PMount</a>
</p>

<p>
<a href="index.html">Index</a>
</p>

</body>
</html>
