<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>blinkscript_storing_values_in_arrays</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="nuke_blinkscript_index.html">Nuke - Blinkscript</a>
</p>

<div id="Storing Values in an Array"><h1 id="Storing Values in an Array" class="header"><a href="#Storing Values in an Array">Storing Values in an Array</a></h1></div>


<p>
In BlinkScript, to store pixel values during iteration and find the most frequent color, a common approach involves using a frequency map or a similar data structure to count occurrences of each color. Iterate and Store Pixel Values.
</p>

<p>
Inside your process() function, you can iterate over a region of pixels using nested for loops or the ePixelWise kernel mode. For each pixel, read its color components (e.g., R, G, B, A) using src().
</p>

<pre C++>

    // Example for a single pixel in ePixelWise mode
    float4 pixelColor = src();
    // Access individual components: pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a
</pre>

<div id="Storing Values in an Array-Count Color Frequencies."><h3 id="Count Color Frequencies." class="header"><a href="#Storing Values in an Array-Count Color Frequencies.">Count Color Frequencies.</a></h3></div>

<p>
To find the most frequent color, you need to count how many times each unique color appears. Since BlinkScript has limitations on dynamic data structures like std::map, a common workaround is to:
</p>

<div id="Storing Values in an Array-Count Color Frequencies.-Quantize Colors:"><h4 id="Quantize Colors:" class="header"><a href="#Storing Values in an Array-Count Color Frequencies.-Quantize Colors:">Quantize Colors:</a></h4></div>

<p>
If dealing with a large range of colors, you might need to quantize them into a smaller set of representative colors to manage memory and comparison efficiently.
</p>

<div id="Storing Values in an Array-Count Color Frequencies.-Use Arrays for Frequency Counting:"><h4 id="Use Arrays for Frequency Counting:" class="header"><a href="#Storing Values in an Array-Count Color Frequencies.-Use Arrays for Frequency Counting:">Use Arrays for Frequency Counting:</a></h4></div>

<p>
You can declare fixed-size arrays to store color values and their corresponding counts. For example, if you're looking for a specific set of colors, you can have an array of float4 for the colors and an array of int for their counts.
</p>

<pre C++>

    // Example (simplified, assuming a limited number of unique colors)
    const int MAX_UNIQUE_COLORS = 100; // Adjust as needed
    float4 uniqueColors[MAX_UNIQUE_COLORS];
    int colorCounts[MAX_UNIQUE_COLORS];
    int numUniqueColors = 0;

    // Inside your pixel iteration loop:
    float4 currentPixel = src();
    bool found = false;
    for (int i = 0; i &lt; numUniqueColors; ++i) {
        if (uniqueColors[i] == currentPixel) { // Direct comparison might not be robust due to float precision
            colorCounts[i]++;
            found = true;
            break;
        }
    }
    if (!found &amp;&amp; numUniqueColors &lt; MAX_UNIQUE_COLORS) {
        uniqueColors[numUniqueColors] = currentPixel;
        colorCounts[numUniqueColors] = 1;
        numUniqueColors++;
    }
</pre>

<ul>
<li>
Consider a custom hash/quantization scheme: for mapping float4 colors to integer indices if direct comparison is problematic or the number of unique colors is very high.

</ul>

<p>
Find the Most Frequent Color.
</p>

<p>
After iterating through all relevant pixels and populating your frequency arrays, iterate through the colorCounts array to find the index with the highest count. The uniqueColors array at that same index will hold the most frequent color.
</p>

<pre C++>

    float4 mostFrequentColor;
    int maxCount = -1;
    for (int i = 0; i &lt; numUniqueColors; ++i) {
        if (colorCounts[i] &gt; maxCount) {
            maxCount = colorCounts[i];
            mostFrequentColor = uniqueColors[i];
        }
    }

    // You can then use 'mostFrequentColor' for further processing or output.
    dst() = mostFrequentColor; // Example: set output to the most frequent color
</pre>

<div id="Storing Values in an Array-Important Considerations:"><h3 id="Important Considerations:" class="header"><a href="#Storing Values in an Array-Important Considerations:">Important Considerations:</a></h3></div>

<div id="Storing Values in an Array-Important Considerations:-Float Precision:"><h4 id="Float Precision:" class="header"><a href="#Storing Values in an Array-Important Considerations:-Float Precision:">Float Precision:</a></h4></div>

<p>
Direct comparison of float4 values (==) might be unreliable due to floating-point precision issues. Consider comparing components within a small epsilon tolerance.
</p>

<div id="Storing Values in an Array-Important Considerations:-Memory Management:"><h4 id="Memory Management:" class="header"><a href="#Storing Values in an Array-Important Considerations:-Memory Management:">Memory Management:</a></h4></div>

<p>
Be mindful of the size of your arrays, especially when dealing with large images or a vast number of potential unique colors.
</p>

<div id="Storing Values in an Array-Important Considerations:-Performance:"><h4 id="Performance:" class="header"><a href="#Storing Values in an Array-Important Considerations:-Performance:">Performance:</a></h4></div>

<p>
The efficiency of finding and counting unique colors will depend on the chosen method and the complexity of your image data._
</p>


<p>
<a href="nuke_blinkscript_index.html">Nuke - Blinkscript</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
