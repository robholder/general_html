<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>unix_tools_find_utility</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="unix_tools_index.html">Unix Tools</a>
</p>

<div id="find"><h1 id="find" class="header"><a href="#find">find</a></h1></div>


<p>
Below is a walkthrough of how the <code>find</code> utility works, what many of its options do, and some practical examples to get you comfortable with its usage.
</p>

<div id="find-Basic Syntax"><h2 id="Basic Syntax" class="header"><a href="#find-Basic Syntax">Basic Syntax</a></h2></div>

<p>
The general form of the command is:
</p>
<pre bash>
find [path(s)] [expression]
</pre>

<ul>
<li>
<span id="find-Basic Syntax-path(s)"></span><strong id="path(s)">path(s)</strong>: These are the directories where the search will begin. If you omit the path, find defaults to the current directory.

<li>
<span id="find-Basic Syntax-expression"></span><strong id="expression">expression</strong>: This is made up of tests, actions, and operators that filter and process the list of files. The tests determine which files match and the actions (like <code>-print</code> or <code>-exec</code>) are performed on these files.

</ul>
<div id="find-Common Options and Flags"><h2 id="Common Options and Flags" class="header"><a href="#find-Common Options and Flags">Common Options and Flags</a></h2></div>

<p>
Here’s a breakdown of many of the flags and tests you might use:
</p>
<ul>
<li>
<code>-name</code> pattern Matches files whose names fit the given shell pattern (wildcards supported). 

<ul>
<li>
Example: <code>-name "*.txt"</code> finds files ending with <code>.txt</code>.

</ul>
<li>
<code>-iname pattern</code> Like <code>-name</code> but case insensitive.

<ul>
<li>
Example: -iname "*.jpg" finds .JPG as well as .jpg files.

</ul>
<li>
<code>-type [f|d|l|...]</code> Filters files by their type. Common types include:

<ul>
<li>
<code>f</code> – regular file

<li>
<code>d</code> – directory

<li>
<code>l</code> – symbolic link Example: -type f restricts search to regular files.

</ul>
<li>
<code>-size [+/-]n[cwkMG]</code> Matches files according to their size.

<ul>
<li>
A leading <code>+</code> means “greater than,” and <code>-</code> means “less than.”

<li>
The suffix defines the unit:

<ul>
<li>
<code>c</code> for bytes

<li>
<code>w</code> for words: Only on systems that support it, this suffix interprets the given number as two-byte words.

<ul>
<li>
<code>man find</code> to check if available.

<li>
For example, <code>-size 1w</code> would match files of 2 bytes in size.

</ul>
<li>
<code>k</code> for kilobytes

<li>
<code>M</code> for megabytes

<li>
<code>G</code> for gigabytes

<ul>
<li>
Example: <code>-size +100M</code> finds files larger than 100 megabytes.

</ul>
</ul>
</ul>
<li>
<code>-mtime n</code>, <code>-atime n</code>, <code>-ctime n</code> Search based on time attributes (modification, access, or change time).

<ul>
<li>
For these, n is measured in days.

<li>
Using <code>+n</code> finds files older than n days, and <code>-n</code> finds files newer than n days.

<ul>
<li>
Example: <code>-mtime +7</code> finds files modified more than 7 days ago.

<li>
Example: <code>-mtime -7</code> finds files modified less than 7 days ago.

</ul>
</ul>
<li>
<code>-perm mode</code> Filters files by their permissions.

<ul>
<li>
Example: <code>-perm 644</code> finds files with exactly <code>rw-r--r--</code> permissions, while using a leading <code>/</code> or <code>-</code> can specify other matching rules.

</ul>
<li>
<code>-user username</code> and <code>-group groupname</code> Matches files owned by a specific user or group.

<li>
<code>-maxdepth n</code> and <code>-mindepth n</code> Limit the search to certain levels in the directory tree.

<ul>
<li>
<code>-maxdepth 1</code> restricts the search to the specified directory without recursing into subdirectories.

<li>
<code>-mindepth 2</code> starts matching only from subdirectories (skipping the top-level).

</ul>
<li>
<code>-exec command {} \</code>; Execute an external command on each file that matches the tests. The <code>{}</code> is replaced by the current file's path. Example:

</ul>
  
<pre bash>
find . -name "*.log" -exec rm {} \;
</pre>

<p>
This would remove every file ending with <code>.log</code> in and below the current directory. Note: Some versions support <code>+</code> at the end instead of <code>\;</code> to batch-process files for efficiency:
</p>

<pre bash>
find . -name "*.log" -exec rm {} +
</pre>

<ul>
<li>
<code>-print</code> This action prints the path of a found file. It’s often optional because many versions of <code>find</code> default to printing if no action is given.

<li>
<code>-delete</code> Deletes the matching files. <span id="find-Common Options and Flags-Be cautious"></span><strong id="Be cautious">Be cautious</strong> with this flag because there’s no undo.

<li>
Logical Operators:

<li>
<code>-and</code> and <code>-a</code> (implicit): Both mean “and”.

<li>
<code>-or</code> and <code>-o</code>: Means “or”.

<li>
<code>-not</code> and <code>!:</code> Negates a test.

<li>
Parentheses (escaped as <code>\(</code> and <code>\)</code> on many shells) can be used to group conditions. Example:

</ul>
  
<pre bash>
find . \( -name "*.c" -o -name "*.h" \)
</pre>

<p>
...finds files that are either C source files or header files.
</p>

<ul>
<li>
<code>-prune</code> Tells <code>find</code> not to descend into a directory. This is useful to exclude directories from the search. Example:

</ul>
  
<pre bash>
find . -name ".git" -prune -o -print
</pre>

<p>
This skips any directories named <code>.git</code>.
</p>


<div id="find-More on -type"><h2 id="More on -type" class="header"><a href="#find-More on -type">More on -type</a></h2></div>

<p>
You cannot combine multiple file type characters in a single <code>-type</code> flag. The <code>-type</code> option only takes one single character (e.g., <code>f</code> for regular files, <code>d</code> for directories, <code>l</code> for symbolic links, etc.) as its argument.
If you need to match more than one type, you’ll have to combine separate <code>-type</code> tests using logical operators and grouping. For example, if you want to match files that are either regular files, directories, or symbolic links, you could write:
</p>

<pre bash>
find . \( -type f -o -type d -o -type l \) -print
</pre>
<p>
Here’s how it works:
</p>
<ul>
<li>
The \( and \) group the -type tests together.

<li>
The -o operator stands for "or" between tests.

<li>
The overall expression returns true for a file that matches any one of these types.

</ul>
<p>
This is the standard way to express a search that matches multiple file types with find.
</p>


<div id="find-Practical Examples"><h2 id="Practical Examples" class="header"><a href="#find-Practical Examples">Practical Examples</a></h2></div>

<div id="find-Practical Examples-Find All"><h3 id="Find All" class="header"><a href="#find-Practical Examples-Find All">Find All</a></h3></div>

<p>
Find All <code>.txt</code> Files in the Home Directory
</p>

<pre bash>
find ~/ -type f -name "*.txt"
</pre>

<div id="find-Practical Examples-Case-Insensitive Search"><h3 id="Case-Insensitive Search" class="header"><a href="#find-Practical Examples-Case-Insensitive Search">Case-Insensitive Search</a></h3></div>

<p>
Case-Insensitive Search for .jpg Files
</p>

<pre bash>
find . -type f -iname "*.jpg"
</pre>

<div id="find-Practical Examples-Find Files By Size"><h3 id="Find Files By Size" class="header"><a href="#find-Practical Examples-Find Files By Size">Find Files By Size</a></h3></div>

<p>
Find Files Larger Than 50 MB
</p>

<pre bash>
find /path/to/search -type f -size +50M
</pre>

<div id="find-Practical Examples-Find By Modified Time"><h3 id="Find By Modified Time" class="header"><a href="#find-Practical Examples-Find By Modified Time">Find By Modified Time</a></h3></div>

<p>
Find Files Modified More Than 30 Days Ago and List Them
</p>

<pre bash>
find . -type f -mtime +30 -print
</pre>

<div id="find-Practical Examples-Delete Find Results"><h3 id="Delete Find Results" class="header"><a href="#find-Practical Examples-Delete Find Results">Delete Find Results</a></h3></div>

<p>
Delete Temporary Files (with Caution!)
</p>

<pre bash>
find . -type f -name "*.tmp" -delete
</pre>

<div id="find-Practical Examples-Find Files By Name And Contents"><h3 id="Find Files By Name And Contents" class="header"><a href="#find-Practical Examples-Find Files By Name And Contents">Find Files By Name And Contents</a></h3></div>

<p>
Search and Execute a Command Find all .c files and search for the text “main” in them:
</p>

<pre bash>
find . -type f -name "*.c" -exec grep -H "main" {} \;
</pre>

<div id="find-Practical Examples-Find With Limits"><h3 id="Find With Limits" class="header"><a href="#find-Practical Examples-Find With Limits">Find With Limits</a></h3></div>

<p>
Limiting Search Depth Only search in the current directory and not in subdirectories:
</p>

<pre bash>
find . -maxdepth 1 -type f
</pre>

<div id="find-How It All Works Together"><h2 id="How It All Works Together" class="header"><a href="#find-How It All Works Together">How It All Works Together</a></h2></div>

<p>
When you run <code>find</code>, it walks the directory tree starting at the specified path(s). For each file or directory, it evaluates the test expressions. Only files that satisfy all specified conditions (or the logically combined conditions) will have the actions applied to them. This gives you enormous flexibility in precisely targeting files.
</p>

<div id="find-How It All Works Together-Where to Learn More"><h4 id="Where to Learn More" class="header"><a href="#find-How It All Works Together-Where to Learn More">Where to Learn More</a></h4></div>

<p>
For in-depth details and more options, you can check out the manual pages with:
</p>

<pre bash>
man find
</pre>

<p>
And Vim's integrated help system (if you use Vim) can also be a good example of detailed help formatting you might follow for command options in general.
</p>

<hr />

<p>
By understanding the building blocks—tests, actions, and logical operators—you can start to craft your own powerful <code>find</code> commands instead of copying them blindly. Experimenting in a safe directory (or using <code>-print</code> instead of destructive actions like <code>-delete</code>) is a good way to learn and get comfortable with its syntax.
</p>


<p>
<a href="unix_tools_index.html">Unix Tools</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
