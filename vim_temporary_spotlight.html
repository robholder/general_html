<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>vim_temporary_spotlight</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="vim_learning.html">vim_learning</a>
</p>

<div id="Vim - Temporary Spotlight for Tips"><h1 id="Vim - Temporary Spotlight for Tips" class="header"><a href="#Vim - Temporary Spotlight for Tips">Vim - Temporary Spotlight for Tips</a></h1></div>

<div id="Vim - Temporary Spotlight for Tips-Activate System Clipboard Integration"><h2 id="Activate System Clipboard Integration" class="header"><a href="#Vim - Temporary Spotlight for Tips-Activate System Clipboard Integration">Activate System Clipboard Integration</a></h2></div>

<pre vim>
set clipboard=unnamed
</pre>

<p>
This seems to allow any yanked or copied text to be pasted in or out of Vim.
</p>

<div id="Vim - Temporary Spotlight for Tips-[[vim_buffers#Delete Buffers|Delete Buffers]]"><h2 id="[[vim_buffers#Delete Buffers|Delete Buffers]]" class="header"><a href="#Vim - Temporary Spotlight for Tips-[[vim_buffers#Delete Buffers|Delete Buffers]]"><a href="vim_buffers.html#Delete Buffers">Delete Buffers</a></a></h2></div>

<p>
<code>:%bd</code> &lt;-- delete all buffers (leaving empty vim session)<br>
<code>:%bd|e#|bd#</code> &lt;-- Delete all buffers, and return to last edited (leave current open only)<br>
</p>

<p>
In Vimrc:
</p>
<pre vim>
</pre>

<div id="Vim - Temporary Spotlight for Tips-[[vim_practical_vim#Add Prefix or Suffix to Lines|Add Prefix or Suffix to Lines]]"><h2 id="[[vim_practical_vim#Add Prefix or Suffix to Lines|Add Prefix or Suffix to Lines]]" class="header"><a href="#Vim - Temporary Spotlight for Tips-[[vim_practical_vim#Add Prefix or Suffix to Lines|Add Prefix or Suffix to Lines]]"><a href="vim_practical_vim.html#Add Prefix or Suffix to Lines">Add Prefix or Suffix to Lines</a></a></h2></div>

<div id="Vim - Temporary Spotlight for Tips-[[vim_random_tips#Create Numbered List (Number Per Line)|Create Numbered List]]"><h2 id="[[vim_random_tips#Create Numbered List (Number Per Line)|Create Numbered List]]" class="header"><a href="#Vim - Temporary Spotlight for Tips-[[vim_random_tips#Create Numbered List (Number Per Line)|Create Numbered List]]"><a href="vim_random_tips.html#Create Numbered List (Number Per Line)">Create Numbered List</a></a></h2></div>

<div id="Vim - Temporary Spotlight for Tips-[[vim_surround_plugin#Practice Text With Answers|Surround Plugin]]"><h2 id="[[vim_surround_plugin#Practice Text With Answers|Surround Plugin]]" class="header"><a href="#Vim - Temporary Spotlight for Tips-[[vim_surround_plugin#Practice Text With Answers|Surround Plugin]]"><a href="vim_surround_plugin.html#Practice Text With Answers">Surround Plugin</a></a></h2></div>

<p>
<code>ysE"</code> &lt;-- Ignore punctuation additions and surround whole word with quotes<br>
</p>
<ul>
<li>
<code>ys</code> --&gt; You surround

<li>
<code>E</code> --&gt; End of word (up to last non-whitespace character)

<li>
<code>"</code> --&gt; Delimiter choice

</ul>
<div id="Vim - Temporary Spotlight for Tips-Delete 'To' [t] and 'To and Including' [f]"><h2 id="Delete 'To' [t] and 'To and Including' [f]" class="header"><a href="#Vim - Temporary Spotlight for Tips-Delete 'To' [t] and 'To and Including' [f]">Delete 'To' [t] and 'To and Including' [f]</a></h2></div>

<ul>
<li>
<code>dt[character]</code> - delete UP to character.

<li>
<code>df[character]</code> - delete UP to and INCLUDING character.

<li>
<code>dT[character]</code> - delete BACK to character.

<li>
<code>dF[character]</code> - delete BACK to and INCLUDING character.

</ul>
<p>
<em>also</em>
</p>
<ul>
<li>
<code>vt[character]</code> - select UP to character.

<li>
<code>vf[character]</code> - select UP to and INCLUDING character.

<li>
<code>vT[character]</code> - select BACK to character.

<li>
<code>vF[character]</code> - select BACK to and INCLUDING character.

</ul>
<p>
<em>bonus</em>
</p>
<ul>
<li>
<code>0vg_</code> - Select to end of line (without newline); from beginning of line.

<li>
<code>^vg_</code> Select to end of line (without newline); from first character of line.

</ul>
  
<p>
<em>Explanation</em>: <code>g_</code> is last 'non-blank' character of a line.
</p>

<div id="Vim - Temporary Spotlight for Tips-Repeat"><h2 id="Repeat" class="header"><a href="#Vim - Temporary Spotlight for Tips-Repeat">Repeat</a></h2></div>

<ul>
<li>
<code>.</code> &lt;-- Repeat last edit in normal mode.

<li>
<code>@:</code> &lt;-- Repeat last command-line command.

</ul>
<div id="Vim - Temporary Spotlight for Tips-Search Count"><h2 id="Search Count" class="header"><a href="#Vim - Temporary Spotlight for Tips-Search Count">Search Count</a></h2></div>

<p>
<code>:%s/&lt;patter&gt;//gn</code> &lt;-- This will search for a term and merely return how many instances and how many lines with the term has been found. (g is global, n is count.)
</p>

<div id="Vim - Temporary Spotlight for Tips-Jump Back &amp; Forth"><h2 id="Jump Back &amp; Forth" class="header"><a href="#Vim - Temporary Spotlight for Tips-Jump Back &amp; Forth">Jump Back &amp; Forth</a></h2></div>

<ul>
<li>
<code>g;</code> &lt;-- jump to last position

<li>
<code>g,</code> &lt;-- jump to next position (if you've already jumped back)

<li>
<code>''</code> &lt;-- jump back to the beginning of the last line in a jump list
<pre>
`` &lt;-- jump back and forth to the last line
</pre>

</ul>
<div id="Vim - Temporary Spotlight for Tips-Move current line to the end"><h2 id="Move current line to the end" class="header"><a href="#Vim - Temporary Spotlight for Tips-Move current line to the end">Move current line to the end</a></h2></div>

<ul>
<li>
<code>:m$</code> &lt;-- moves current line to the end line of the buffer

<li>
<code>:m1</code> &lt;-- moves current line to first empty line number after line 1

</ul>
<div id="Vim - Temporary Spotlight for Tips-Move current line to the end-Removing double (or more) blank lines"><h3 id="Removing double (or more) blank lines" class="header"><a href="#Vim - Temporary Spotlight for Tips-Move current line to the end-Removing double (or more) blank lines">Removing double (or more) blank lines</a></h3></div>

<ul>
<li>
<code>:%s/\n\n/\r/g</code> &lt;-- replace double blank lines with single blank line. This command will search for double newlines and replace them with a single newline.

<li>
<code>:%s/\n\{2,}/\r/g</code> &lt;-- If you want to ensure that any number of consecutive blank lines are reduced to a single blank line, you can use:

<ul>
<li>
<code>\n</code> is newline

<li>
<code>{2,}</code> is "two or more, until blank (forever)" (<code>{n,m}</code> where 'n' is start, 'm' is end.)

<ul>
<li>
In the context of quantifiers, only the opening curly bracket needs to be escaped to indicate the start of a quantifier. The closing curly bracket is understood to be part of the quantifier and does not need to be escaped.

</ul>
<li>
<code>\r</code> is carriage return (<code>\n</code> doesn't function as expected with substitutions)

</ul>
</ul>
<div id="Vim - Temporary Spotlight for Tips-Move current line to the end-The \n and \r weirdness"><h3 id="The \n and \r weirdness" class="header"><a href="#Vim - Temporary Spotlight for Tips-Move current line to the end-The \n and \r weirdness">The \n and \r weirdness</a></h3></div>

<p>
In Vim, <code>\n</code> and <code>\r</code> represent different newline characters based on their context within search and substitution patterns:
</p>

<ul>
<li>
Search Pattern <code>\n</code>: In the search pattern, <code>\n</code> represents a newline character (Line Feed, ASCII 10). When you search for <code>\n</code>, you're looking for actual newline characters in the file's text.

<li>
Substitution Pattern <code>\r</code>: In the substitution pattern, <code>\r</code> is used to represent a newline character. This can be a bit confusing because it corresponds to Carriage Return (ASCII 13) in many contexts, but in Vim's substitution command, it represents inserting a newline.

</ul>
<div id="SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block"><h1 id="SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block" class="header"><a href="#SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block">SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block</a></h1></div>

<div id="SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block-Command"><h2 id="Command" class="header"><a href="#SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block-Command">Command</a></h2></div>

<p>
<code>:'&lt;,'&gt;g/^[0-9]\+$/s/.*/\=submatch(0) + 530/</code>
</p>

<p>
Let's break down the command:
</p>

<p>
<code>vap</code>: Selects a block or paragraph.
</p>

<p>
<code>'&lt;,'&gt;</code>: This specifies the range of selected lines in visual mode.
</p>

<p>
<code>g/^[0-9]\+$/</code>: This part finds lines that consist only of numbers.
</p>

<p>
<code>s/.*/\=submatch(0) + 530/</code>: This replaces each number with its value plus 530.
</p>

<div id="SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block-Record the Macro"><h2 id="Record the Macro" class="header"><a href="#SRT Files - Incrementing The Counter Numbers At The Start Of Each Subtitle Block-Record the Macro">Record the Macro</a></h2></div>

<p>
Start recording the macro by pressing <code>q</code> followed by a letter (e.g., <code>a</code>) to name the macro. Let's use 'a' as the macro name.
</p>

<p>
Enter visual block mode by pressing <code>Ctrl+V</code>. Select the block of lines using the arrow keys. (Or use <code>vap</code> for select all paragraph.)
</p>

<p>
Execute the substitution command: <code>:'&lt;,'&gt;g/^[0-9]\+$/s/.*/\=submatch(0) + 530/</code>
</p>

<p>
Exit visual mode by pressing <code>&lt;esc&gt;</code>.
</p>

<p>
Move the cursor to the beginning of the next block (if needed). <code>jjjj</code>
</p>

<p>
Stop recording the macro by pressing <code>q</code>.
</p>

<p>
Playback the Macro:
</p>

<p>
To execute the macro, move the cursor to the beginning of each block and press <code>@a</code> (where a is the macro name).
</p>

<div id="Showcasing All Available Colorschemes"><h1 id="Showcasing All Available Colorschemes" class="header"><a href="#Showcasing All Available Colorschemes">Showcasing All Available Colorschemes</a></h1></div>

<p>
Cycle through all installed or available colorschemes live in the Vim buffer window:
</p>

<pre vim>
for c in globpath(&amp;rtp, 'colors/*.vim', 0, 1)-&gt;map({_, val -&gt; fnamemodify(val, ':t:r')})-&gt;sort('i')-&gt;uniq('i')
  try
    exec 'colorscheme ' .. c
    redraw
    echo c
  catch
    echo 'ERROR loading colorscheme ' .. c
  finally
    sleep 2
  endtry
endfor
colorscheme default
redraw
echo 'finished. back to default'
</pre>

<p>
...Then:
</p>
<pre>
:so %
</pre>

<p>
The <code>:so</code> is short for <code>:source</code> and the <code>%</code> is 'this file'.
</p>

<div id="Showcasing All Available Colorschemes-Explanation"><h2 id="Explanation" class="header"><a href="#Showcasing All Available Colorschemes-Explanation">Explanation</a></h2></div>

<p>
This script iterates over all available colorschemes in Vim, attempts to load them one by one, and temporarily displays each colorscheme before resetting to the default. Let's break down the globpath call specifically and its arguments:
</p>
<ul>
<li>
<code>globpath(&amp;rtp, 'colors/*.vim', 0, 1)</code>

<ul>
<li>
<code>&amp;rtp</code>: This represents Vim's runtime path. It is a list of directories that Vim searches for plugins, colorschemes, and other runtime files. The script uses &amp;rtp to locate all colorschemes available across the runtime path.

</ul>
<li>
<code>'colors/*.vim'</code>: This specifies the pattern to match. It looks for files with a .vim extension inside the colors subdirectory of each directory in the runtime path. In this case, it targets colorscheme files.

<li>
<code>0</code>: This argument specifies whether to search recursively through subdirectories. A value of 0 means do not search recursively—only look in the colors directory itself.

<li>
<code>1</code>: This argument returns the matches as a list. Without this (0), the results would be returned as a single string with items separated by newlines.

</ul>
<div id="Showcasing All Available Colorschemes-Explanation-Result of globpath"><h3 id="Result of globpath" class="header"><a href="#Showcasing All Available Colorschemes-Explanation-Result of globpath">Result of globpath</a></h3></div>

<p>
The globpath function returns a list of file paths to all .vim files in the colors directories along the runtime path.
</p>

<div id="Showcasing All Available Colorschemes-Explanation-Result of globpath-How the Script Processes These Paths"><h4 id="How the Script Processes These Paths" class="header"><a href="#Showcasing All Available Colorschemes-Explanation-Result of globpath-How the Script Processes These Paths">How the Script Processes These Paths</a></h4></div>

<ul>
<li>
<code>map({_, val -&gt; fnamemodify(val, ':t:r')})</code> This uses the <code>map()</code> function to process each file path returned by globpath.

<li>
<code>fnamemodify(val, ':t:r')</code> extracts just the filename without the extension (the colorscheme name) from the full path.

<li>
<code>:t</code> returns the tail (filename) of the path.

<li>
<code>:r</code> removes the file extension (e.g., gruvbox.vim becomes gruvbox).

<li>
<code>sort('i')</code> Sorts the list of colorscheme names alphabetically in a case-insensitive manner ('i' for "ignore case").

<li>
<code>uniq('i')</code>: Removes duplicate colorscheme names from the sorted list. Again, this is done in a case-insensitive way.

</ul>
<div id="Showcasing All Available Colorschemes-Explanation-Summary of globpath and Subsequent Pipeline"><h3 id="Summary of globpath and Subsequent Pipeline" class="header"><a href="#Showcasing All Available Colorschemes-Explanation-Summary of globpath and Subsequent Pipeline">Summary of globpath and Subsequent Pipeline</a></h3></div>

<ul>
<li>
<code>globpath</code> retrieves all available .vim colorscheme files in the runtime path.

<li>
The pipeline processes these file paths into a list of unique, alphabetically sorted colorscheme names, ready to be iterated over.

</ul>
<div id="Replace All Characters In A Line (Headings?)"><h1 id="Replace All Characters In A Line (Headings?)" class="header"><a href="#Replace All Characters In A Line (Headings?)">Replace All Characters In A Line (Headings?)</a></h1></div>

<ul>
<li>
<code>yypVr=</code> &lt;-- Replace every character with an equals sign

<li>
<code>yypVr=</code> &lt;-- Copy and paste a line, and replace every character with an equals sign

<li>
<code>yypVr"</code> &lt;-- Copy and paste a line, and replace every character with double-quotes.

</ul>
<p>
<code>yypVr=</code> is an elegant and efficient way to achieve headings.
</p>

<p>
Here's how it works:
</p>
<ul>
<li>
<code>yyp</code>: Yank the current line and paste it below to create a duplicate.

<li>
<code>V</code>: Enter Visual Line mode, which selects the entire line.

<li>
<code>r=</code>: Replace all characters in the selected line with the = character.

</ul>
<p>
This method is clean, concise, and doesn't require additional counting or commands. A perfect Vim trick for creating headers!
</p>

<p>
<a href="vim_learning.html">vim_learning</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
