<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>vim_vimrc_and_settings</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="vim_learning.html">Vim Learning</a>
</p>

<div id="Vimrc &amp; Settings"><h2 id="Vimrc &amp; Settings" class="header"><a href="#Vimrc &amp; Settings">Vimrc &amp; Settings</a></h2></div>


<div id="Controlling Line Wrapping (Linebreaks and Visual)"><h1 id="Controlling Line Wrapping (Linebreaks and Visual)" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)">Controlling Line Wrapping (Linebreaks and Visual)</a></h1></div>

<p>
Vim provides a variety of settings to control how lines are displayed and automatically broken or wrapped. Each setting you've mentioned plays a distinct role, and understanding how they interact will help you configure Vim effectively for your needs.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:"><h4 id="Breakdown of Relevant Settings:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:">Breakdown of Relevant Settings:</a></h4></div>

<ul>
<li>
<code>wrap</code> and <code>nowrap</code>: These control how lines are displayed in the editor:

<ul>
<li>
<code>wrap</code> (default): Lines longer than the width of the window are visually "wrapped" onto the next screen line but not actually broken into new lines.

<li>
<code>nowrap</code>: Disables this behavior; longer lines will scroll horizontally instead of wrapping.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: This is purely visual and does not change the actual content of the buffer.
</p>

<ul>
<li>
<code>linebreak</code>: Works alongside wrap to improve how wrapped lines are displayed:

<ul>
<li>
If enabled (<code>set linebreak</code>), Vim wraps lines at "breakable" characters (e.g., after spaces or hyphens) instead of at arbitrary window widths.

<li>
Without this, line wrapping occurs even in the middle of words, which might look awkward.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: This is a display feature and does not affect actual line breaks in the text.
</p>

<ul>
<li>
<code>textwidth</code>: Controls automatic line breaking while editing:

<ul>
<li>
When <code>textwidth</code> is set to a number (e.g., <code>set textwidth=80</code>), lines are automatically broken when they exceed the specified number of characters.

<li>
If unset (<code>set textwidth=0</code>), automatic line breaking does not occur.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: This modifies the content of the buffer, breaking lines while you type or when specific commands (e.g., <code>gq</code>) are used.
</p>

<ul>
<li>
<code>formatoptions</code> (<code>fo</code>): This governs formatting behaviors during text insertion, editing, or reformatting. Some key flags include:

<ul>
<li>
<code>t</code>: Automatically breaks lines at textwidth during typing.

<li>
<code>c</code>: Automatically wraps comments.

<li>
<code>q</code>: Enables gq to reformat text to respect textwidth.

<li>
<code>l</code>: Does not break lines that are longer than textwidth if they already exist.

<li>
<code>n</code>: Recognizes numbered lists when breaking text.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: You can customize <code>formatoptions</code> to fine-tune automatic formatting.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-How These Settings Work Together:"><h4 id="How These Settings Work Together:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-How These Settings Work Together:">How These Settings Work Together:</a></h4></div>

<ul>
<li>
Visual Wrapping (<code>wrap</code>, <code>linebreak</code>): Determines how lines are shown in the editor but doesn’t affect the actual file content.

<li>
Automatic Line Breaking (<code>textwidth</code>, <code>formatoptions</code>): Controls whether lines are actively split during editing or formatting based on a defined width.

<li>
If you enable wrap and <code>linebreak</code>, Vim will visually wrap text at the window’s edge and break at natural points (but won’t change the file).

<li>
If you set <code>textwidth</code> and <code>fo+=t</code>, Vim will automatically insert a newline when you exceed the specified width.

</ul>
<div id="Controlling Line Wrapping (Linebreaks and Visual)-Example Configuration:"><h4 id="Example Configuration:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Example Configuration:">Example Configuration:</a></h4></div>

<p>
If you want Vim to:
</p>
<ul>
<li>
Wrap lines visually without modifying them, and ensure clean wrapping:

</ul>
  
<pre vim>
set wrap
set linebreak
</pre>

<ul>
<li>
Automatically break lines at 80 characters:

</ul>
  
<pre vim>
set textwidth=80
set formatoptions+=t
</pre>

<p>
You can mix these settings based on whether you care about visual wrapping, actual content changes, or both!
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings"><h2 id="Checking If There Are Existing Key Mappings" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings">Checking If There Are Existing Key Mappings</a></h2></div>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-How to find out if a key combination is mapped somewhere:"><h3 id="How to find out if a key combination is mapped somewhere:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-How to find out if a key combination is mapped somewhere:">How to find out if a key combination is mapped somewhere:</a></h3></div>

<p>
To determine if a specific key combination is already mapped in Vim, you can use the <code>:map</code> family of commands. These commands display mappings for different modes and help you track down where a key combination is being used. Here's how:
</p>
 
<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check All Mappings"><h3 id="Check All Mappings" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check All Mappings">Check All Mappings</a></h3></div>

<p>
Use the following command to view all mappings:
</p>
<pre vim>
:map
</pre>

<p>
This displays a list of all defined mappings, regardless of mode. You can scroll through the list to see if your desired key combination is already mapped.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings"><h3 id="Check Specific Mode Mappings" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings">Check Specific Mode Mappings</a></h3></div>

<p>
To narrow it down, you can check mappings for specific modes:
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Normal mode:"><h4 id="Normal mode:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Normal mode:">Normal mode:</a></h4></div>

<pre vim>
:nmap
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Insert mode:"><h4 id="Insert mode:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Insert mode:">Insert mode:</a></h4></div>

<pre vim>
:imap
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Visual mode:"><h4 id="Visual mode:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Visual mode:">Visual mode:</a></h4></div>

<pre vim>
:vmap
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Command-line mode:"><h4 id="Command-line mode:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Command-line mode:">Command-line mode:</a></h4></div>

<pre vim>
:cmap
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Search for a Specific Key Combination"><h3 id="Search for a Specific Key Combination" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Search for a Specific Key Combination">Search for a Specific Key Combination</a></h3></div>

<p>
You can use the <code>:verbose</code> command to check if a specific key combination is mapped and where the mapping is defined:
</p>

<pre vim>
:verbose map &lt;key&gt;
</pre>

<p>
For example, to check if &lt;C-k&gt; is mapped, you would type:
</p>

<pre vim>
:verbose map &lt;C-k&gt;
</pre>

<p>
This will tell you:
</p>
<ul>
<li>
Whether the key is mapped.

<li>
The file or script where the mapping is defined (great for debugging!).

</ul>
<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings"><h3 id="Check for Mode-Specific Mappings" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings">Check for Mode-Specific Mappings</a></h3></div>

<p>
To check mappings for a specific mode and a specific key combination, use:
Normal mode:
</p>

<pre vim>
:verbose nmap &lt;key&gt;
</pre>

<p>
Insert mode:
</p>

<pre vim>
:verbose imap &lt;key&gt;
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings-Example in Practice"><h4 id="Example in Practice" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings-Example in Practice">Example in Practice</a></h4></div>

<p>
If you suspect <code>&lt;C-j&gt;</code> is mapped and want to see its Insert mode mapping, you would use:
</p>

<pre vim>
:verbose imap &lt;C-j&gt;
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys"><h3 id="Bonus: Unmapping Keys" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys">Bonus: Unmapping Keys</a></h3></div>

<p>
If you find an unwanted mapping, you can remove it with the appropriate <code>:unmap</code> command, like:
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Normal mode:"><h4 id="Normal mode:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Normal mode:">Normal mode:</a></h4></div>

<pre vim>
:nunmap &lt;key&gt;
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Insert mode:"><h4 id="Insert mode:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Insert mode:">Insert mode:</a></h4></div>

<pre vim>
:iunmap &lt;key&gt;
</pre>


<div id="Settings Based on OS (MacOS, Linux, Windows)"><h1 id="Settings Based on OS (MacOS, Linux, Windows)" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)">Settings Based on OS (MacOS, Linux, Windows)</a></h1></div>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?"><h2 id="Can I share a vimrc by segregating settings?" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?">Can I share a vimrc by segregating settings?</a></h2></div>

<p>
You can structure your Vimrc configuration to accommodate different operating systems. Vim allows you to use conditional statements to detect the underlying system and apply specific settings accordingly.
</p>

<p>
Here's an example of how you might organize your Vimrc for MacOS, Linux, and Windows:
</p>

<pre vim>
if has("mac")
    " Settings specific to MacOS
    set clipboard=unnamedplus
    set guifont=Monaco:h12
elseif has("unix")
    " Settings specific to Linux
    set clipboard=unnamed
    set guifont=DejaVu\ Sans\ Mono:h12
elseif has("win32")
    " Settings specific to Windows
    set clipboard=unnamedplus
    set guifont=Consolas:h12
endif
</pre>

<p>
In this snippet:
</p>
<ul>
<li>
The <code>has()</code> function checks for system-specific features. For example, <code>"mac"</code> for MacOS, <code>"unix"</code> for Linux, and <code>"win32"</code> for Windows.

<li>
You can include any settings tailored to each operating system within their respective blocks.

</ul>
<p>
By structuring your Vimrc file this way, you ensure that it can be shared across all your environments without requiring manual adjustments each time.
</p>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?"><h3 id="What is the 'has()'function doing?" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?">What is the 'has()'function doing?</a></h3></div>

<p>
The <code>has()</code> function in Vim is used to check for the presence of specific features, capabilities, or characteristics within the current Vim environment. It evaluates a string argument and returns <code>1</code> (true) if the feature exists or <code>0</code> (false) if it doesn't.
</p>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?-In the context of a Vimrc:"><h4 id="In the context of a Vimrc:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?-In the context of a Vimrc:">In the context of a Vimrc:</a></h4></div>

<p>
The <code>has()</code> function is being used to detect the operating system by checking for predefined feature strings such as <code>"mac"</code>, <code>"unix"</code>, or <code>"win32"</code>. Each of these strings corresponds to a specific environment:
</p>
<ul>
<li>
<code>"mac"</code>: Indicates that Vim is running on macOS.

<li>
<code>"unix"</code>: Represents any Unix-like system, including Linux and macOS.

<li>
<code>"win32"</code>: Indicates that Vim is running on Windows.

</ul>
<p>
For example:
</p>
<pre vim>
if has("mac")
    " This block runs only if Vim detects macOS
endif
</pre>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions"><h3 id="Conditional Logic Versions" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions">Conditional Logic Versions</a></h3></div>

<p>
Vim supports conditional logic, including "if NOT" scenarios, using the ! (not) operator. This allows you to apply settings when a certain condition, such as being on macOS, is not true. Here's how you could structure it:
</p>

<pre vim>
if !has("mac")
    " Settings for systems that are NOT macOS
    set clipboard=unnamed
    set guifont=DejaVu\ Sans\ Mono:h12
endif
</pre>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Explanation:"><h4 id="Explanation:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
The <code>!has("mac")</code> evaluates to true only if Vim is not running on macOS.

<li>
Within this block, you can define all settings for other systems, such as Linux or Windows.

</ul>
<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Combining with Other Conditions:"><h4 id="Combining with Other Conditions:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Combining with Other Conditions:">Combining with Other Conditions:</a></h4></div>

<p>
If you'd like to combine this with more specific conditions, you can nest or extend your logic. For example:
</p>

<pre vim>
if !has("mac")
    if has("unix")
        " Settings specific to Linux
        set guifont=DejaVu\ Sans\ Mono:h12
    elseif has("win32")
        " Settings specific to Windows
        set guifont=Consolas:h12
    endif
endif
</pre>

<p>
This approach ensures you handle all non-macOS systems while still being precise about Linux versus Windows settings.
</p>


<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():"><h3 id="More Examples of has():" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():">More Examples of has():</a></h3></div>

<p>
Here are other things you can check using <code>has()</code>:
</p>
<ul>
<li>
<code>"gui"</code>: Checks if Vim is running with a graphical user interface (e.g., GVim).

<li>
<code>"clipboard"</code>: Checks if clipboard support is available.

<li>
<code>"python3"</code>: Checks if Python 3 support is enabled in Vim.

</ul>
<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():-Practical Use:"><h4 id="Practical Use:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():-Practical Use:">Practical Use:</a></h4></div>

<p>
You can use <code>has()</code> in conditional statements to tailor your configuration based on the features available in your Vim setup. This allows you to write more portable and adaptive Vimrc files.
</p>

<div id="Using the has() Function Outside of the Vimrc"><h1 id="Using the has() Function Outside of the Vimrc" class="header"><a href="#Using the has() Function Outside of the Vimrc">Using the has() Function Outside of the Vimrc</a></h1></div>

<p>
The has() function can be used outside of the Vimrc configuration file. It works in any Vim script or even interactively within Vim, making it quite versatile for checking features during runtime.
</p>

<div id="Using the has() Function Outside of the Vimrc-How to use has() outside of Vimrc:"><h4 id="How to use has() outside of Vimrc:" class="header"><a href="#Using the has() Function Outside of the Vimrc-How to use has() outside of Vimrc:">How to use has() outside of Vimrc:</a></h4></div>

<ul>
<li>
Interactive Usage in Command Mode: You can type commands directly into Vim to use the <code>has()</code> function. For example:

</ul>
  
<pre vim>
:if has("mac")
    :echo "You are using MacOS"
:endif
</pre>

<p>
This will check if Vim is running on macOS and display the message if true.
</p>

<ul>
<li>
Custom Functions: You can use has() in your custom Vim script functions to make them adapt to specific environments. For example:

</ul>
  
<pre vim>
function! MyCustomSetup()
    if has("unix")
        echo "Setting up for Unix-like systems"
        " Add your Unix-specific commands here
    elseif has("win32")
        echo "Setting up for Windows"
        " Add your Windows-specific commands here
    endif
endfunction
</pre>

<p>
You can call this function interactively with <code>:call MyCustomSetup()</code> or include it in a script.
</p>

<ul>
<li>
Plugins and Advanced Scripts: When writing plugins or more advanced scripts for Vim, <code>has()</code> can be used to conditionally enable or disable features based on availability. For example:

</ul>
  
<pre vim>
if has("clipboard")
    echo "Clipboard support available!"
else
    echo "Clipboard support is not enabled."
endif
</pre>

<div id="Using the has() Function Outside of the Vimrc-Why Use 'has()' Outside Vimrc?"><h4 id="Why Use 'has()' Outside Vimrc?" class="header"><a href="#Using the has() Function Outside of the Vimrc-Why Use 'has()' Outside Vimrc?">Why Use 'has()' Outside Vimrc?</a></h4></div>

<p>
Using <code>has()</code> interactively or in custom scripts allows you to adapt Vim behavior dynamically, based on the environment or available features. It's particularly useful for debugging, testing, or creating more complex automation workflows within Vim.
</p>

<div id="Lists in the Vimrc"><h1 id="Lists in the Vimrc" class="header"><a href="#Lists in the Vimrc">Lists in the Vimrc</a></h1></div>

<p>
You can declare a list in your Vimrc and split it across multiple lines for better readability. Vim supports this kind of syntax as long as you use a backslash (<code>\</code>) to indicate that the line continues.
</p>

<p>
Here’s an example of how to do it:
</p>
<pre vim>
let my_list = [
      \ 'item1',
      \ 'item2',
      \ 'item3',
      \ 'item4'
      \ ]
</pre>

<div id="Lists in the Vimrc-Explanation:"><h4 id="Explanation:" class="header"><a href="#Lists in the Vimrc-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
The square brackets (<code>[ ]</code>) define the list.

<li>
The backslash (<code>\</code>) at the beginning of each new line tells Vim that the statement continues onto the next line.

<li>
You can add as many items as you like, each separated by a comma.

</ul>
<p>
This approach makes it easy to keep your Vimrc organized and manageable, especially for longer lists.
</p>


<p>
<br><br>
<a href="vim_learning.html">Vim Learning</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
