<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>vim_vimrc_and_settings</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="vim_learning.html">Vim Learning</a>
</p>

<div id="Vimrc &amp; Settings"><h2 id="Vimrc &amp; Settings" class="header"><a href="#Vimrc &amp; Settings">Vimrc &amp; Settings</a></h2></div>

<div id="System Clipboard"><h1 id="System Clipboard" class="header"><a href="#System Clipboard">System Clipboard</a></h1></div>

<p>
There are a number of ways of sharing they System Clipboard and Vim's copy/yank registers.
</p>

<p>
By default you can use the <code>*</code> or <code>+</code> registers to access the System Clipboard:
</p>

<div id="System Clipboard-To copy:"><h4 id="To copy:" class="header"><a href="#System Clipboard-To copy:">To copy:</a></h4></div>

<ul>
<li>
<code>"+y</code> --&gt; Copy TO the System Clipboard from Vim:

<ul>
<li>
e.g., <code>V"+y</code> to copy a line to the System Clipboard.

</ul>
<li>
<code>"+p</code> --&gt; Paste FROM the System Clipboard to Vim:

</ul>
<div id="System Clipboard-To automatically share clipboards"><h4 id="To automatically share clipboards" class="header"><a href="#System Clipboard-To automatically share clipboards">To automatically share clipboards</a></h4></div>

<p>
Add the following to the Vimrc settings:
</p>
<pre vim>
set clipboard=unnamed
</pre>

<p>
Now the System Clipboard should be synonymous with the Vim <code>""</code> register (or <code>p</code>).
</p>

<div id="Tabs (Substitution by Spaces etc.)"><h1 id="Tabs (Substitution by Spaces etc.)" class="header"><a href="#Tabs (Substitution by Spaces etc.)">Tabs (Substitution by Spaces etc.)</a></h1></div>

<p>
Looking at the following useful settings for tabs and their behavior in Vim:
</p>

<pre vim>
set expandtab
set tabstop=4
set softtabstop=4
set shiftwidth=4
set autoindent
</pre>

<p>
Here’s how these settings work individually and together to configure indentation and tab behavior in Vim:
</p>

<div id="Tabs (Substitution by Spaces etc.)-Breakdown of Settings:"><h3 id="Breakdown of Settings:" class="header"><a href="#Tabs (Substitution by Spaces etc.)-Breakdown of Settings:">Breakdown of Settings:</a></h3></div>
<ul>
<li>
<code>set expandtab</code>:

<ul>
<li>
Ensures that pressing <code>&lt;Tab&gt;</code> inserts spaces instead of actual tab characters (<code>\t</code>).

<li>
File content will only contain spaces for indentation rather than hard tabs.

<li>
Ideal for coding environments where spaces are preferred for consistency.

</ul>
<li>
<code>set tabstop=4</code>:

<ul>
<li>
Defines the visual width of a tab character (<code>\t</code>) as 4 spaces.

<li>
Even though <code>expandtab</code> prevents actual tabs from being inserted, this controls how existing tab characters are displayed on the screen.

</ul>
<li>
<code>set softtabstop=4</code>:

<ul>
<li>
Determines how many spaces are inserted or deleted when pressing <code>&lt;Tab&gt;</code> or <code>&lt;BS&gt;</code> (Backspace).

<ul>
<li>
Since it's set to 4 here, pressing <code>&lt;Tab&gt;</code> will add 4 spaces, and <code>&lt;BS&gt;</code> will remove up to 4 spaces (if they were inserted by <code>&lt;Tab&gt;</code>).

</ul>
</ul>
<li>
<code>set shiftwidth=4</code>:

<ul>
<li>
Specifies how many spaces are added or removed when using indentation commands, like <code>&gt;&gt;</code> or <code>&lt;&lt;</code>.

<li>
With this setting, indentation levels align consistently with the 4-space configuration.

</ul>
<li>
<code>set autoindent</code>:

<ul>
<li>
Automatically carries over the indentation of the current line when you start a new one.

<li>
This is useful for maintaining the structure of code or prose without needing to manually adjust indentation for every new line.

</ul>
</ul>
<div id="Tabs (Substitution by Spaces etc.)-How They Work Together:"><h3 id="How They Work Together:" class="header"><a href="#Tabs (Substitution by Spaces etc.)-How They Work Together:">How They Work Together:</a></h3></div>

<p>
This configuration sets up Vim to use 4 spaces per level of indentation consistently:
</p>

<ul>
<li>
Tab Behavior:

<ul>
<li>
When you press <code>&lt;Tab&gt;</code>, Vim inserts 4 spaces (<code>softtabstop=4</code> + <code>expandtab</code>).

</ul>
<li>
Indentation Commands:

<ul>
<li>
Commands like <code>&gt;&gt;</code> and <code>&lt;&lt;</code> adjust indentation levels by 4 spaces (<code>shiftwidth=4</code>).

</ul>
<li>
Visual Display:

<ul>
<li>
Existing tab characters are shown as 4 spaces wide (<code>tabstop=4</code>).

</ul>
<li>
Automatic Indentation:

<ul>
<li>
Indentation is applied automatically for new lines (<code>autoindent</code>).

</ul>
<li>
This setup is ideal for environments like Python, YAML, or other languages where consistent space-based indentation is critical.

</ul>
<div id="Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?"><h3 id="But What Does softtabstop Do?" class="header"><a href="#Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?">But What Does softtabstop Do?</a></h3></div>

<p>
The <code>softtabstop</code> setting in Vim controls how many spaces are used when you press the <code>&lt;Tab&gt;</code> key or use the <code>&lt;BS&gt;</code> (Backspace) key for indentation. This makes it easier to maintain consistent spacing in your code, especially when working with spaces instead of hard tabs.
</p>

<div id="Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-What softtabstop Does:"><h4 id="What softtabstop Does:" class="header"><a href="#Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-What softtabstop Does:">What softtabstop Does:</a></h4></div>

<ul>
<li>
Behavior When Pressing <code>&lt;Tab&gt;</code>:

<ul>
<li>
If <code>softtabstop=#</code> (where # is a number) is set, pressing <code>&lt;Tab&gt;</code> will insert that many spaces instead of a hard tab character.

<li>
For example, <code>set softtabstop=4</code> makes <code>&lt;Tab&gt;</code> insert 4 spaces.

</ul>
<li>
Behavior When Pressing <code>&lt;BS&gt;</code> (Backspace):

<ul>
<li>
When <code>softtabstop</code> is enabled, pressing <code>&lt;BS&gt;</code> will remove up to # spaces at once (if they were inserted by a <code>&lt;Tab&gt;</code>).

</ul>
</ul>
<div id="Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-Special Case: softtabstop=0"><h4 id="Special Case: softtabstop=0" class="header"><a href="#Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-Special Case: softtabstop=0">Special Case: softtabstop=0</a></h4></div>

<p>
If you <code>set softtabstop=0</code>, it disables the effect of soft tab stops and reverts to using the settings defined by <code>tabstop</code> and <code>shiftwidth</code> (if applicable).
</p>

<div id="Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-Interaction With Other Settings:"><h4 id="Interaction With Other Settings:" class="header"><a href="#Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-Interaction With Other Settings:">Interaction With Other Settings:</a></h4></div>

<ul>
<li>
<code>expandtab</code>:

<ul>
<li>
If <code>expandtab</code> is set (<code>set expandtab</code>), Vim will use spaces instead of a hard tab character, and <code>softtabstop</code> defines how many spaces are inserted or deleted with <code>&lt;Tab&gt;</code> and <code>&lt;BS&gt;</code>.

</ul>
<li>
<code>tabstop</code>:

<ul>
<li>
<code>tabstop</code> specifies the width of a tab character when displayed in Vim.

<li>
If <code>softtabstop</code> is not set, Vim defaults to using the <code>tabstop</code> setting.

</ul>
<li>
shiftwidth:

<ul>
<li>
Determines how many spaces are inserted when indenting or unindenting using commands like <code>&gt;&gt;</code> and <code>&lt;&lt;</code>.

</ul>
</ul>
<div id="Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-Example Configuration:"><h4 id="Example Configuration:" class="header"><a href="#Tabs (Substitution by Spaces etc.)-But What Does softtabstop Do?-Example Configuration:">Example Configuration:</a></h4></div>

<p>
Here’s an example setup for using 4 spaces per tab, which is common in many programming languages:
</p>

<pre vim>
set expandtab       " Use spaces instead of tabs
set tabstop=4       " Display width of a tab character
set shiftwidth=4    " Use 4 spaces for indentation
set softtabstop=4   " Insert/delete 4 spaces when pressing &lt;Tab&gt;/&lt;BS&gt;
</pre>

<div id="Controlling Line Wrapping (Linebreaks and Visual)"><h1 id="Controlling Line Wrapping (Linebreaks and Visual)" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)">Controlling Line Wrapping (Linebreaks and Visual)</a></h1></div>

<p>
Vim provides a variety of settings to control how lines are displayed and automatically broken or wrapped. Each setting you've mentioned plays a distinct role, and understanding how they interact will help you configure Vim effectively for your needs.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:"><h4 id="Breakdown of Relevant Settings:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:">Breakdown of Relevant Settings:</a></h4></div>

<ul>
<li>
<code>wrap</code> and <code>nowrap</code>: These control how lines are displayed in the editor:

<ul>
<li>
<code>wrap</code> (default): Lines longer than the width of the window are visually "wrapped" onto the next screen line but not actually broken into new lines.

<li>
<code>nowrap</code>: Disables this behavior; longer lines will scroll horizontally instead of wrapping.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: This is purely visual and does not change the actual content of the buffer.
</p>

<ul>
<li>
<code>linebreak</code>: Works alongside wrap to improve how wrapped lines are displayed:

<ul>
<li>
If enabled (<code>set linebreak</code>), Vim wraps lines at "breakable" characters (e.g., after spaces or hyphens) instead of at arbitrary window widths.

<li>
Without this, line wrapping occurs even in the middle of words, which might look awkward.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: This is a display feature and does not affect actual line breaks in the text.
</p>

<ul>
<li>
<code>textwidth</code>: Controls automatic line breaking while editing:

<ul>
<li>
When <code>textwidth</code> is set to a number (e.g., <code>set textwidth=80</code>), lines are automatically broken when they exceed the specified number of characters.

<li>
If unset (<code>set textwidth=0</code>), automatic line breaking does not occur.

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Breakdown of Relevant Settings:-Key Point"></span><strong id="Key Point">Key Point</strong>: This modifies the content of the buffer, breaking lines while you type or when specific commands (e.g., <code>gq</code>) are used.
</p>

<ul>
<li>
<code>wrapmargin</code>: controls how close to the right edge of the screen Vim will start wrapping text into a new line.

<ul>
<li>
When set, it defines the number of columns from the right margin where the wrapping occurs.

</ul>
</ul>
<div id="Controlling Line Wrapping (Linebreaks and Visual)-For example:"><h4 id="For example:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-For example:">For example:</a></h4></div>

<pre vim>
set wrapmargin=10
</pre>
<p>
This means that Vim will automatically break lines 10 columns before the right edge of the window, starting a new line when you type past that point.
</p>

<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-For example:-Key Point"></span><strong id="Key Point">Key Point</strong>: The wrapping caused by <code>wrapmargin</code> modifies the content of the buffer, as it inserts actual line breaks into your text (unlike the visual-only wrap option, which doesn’t affect the file content).
</p>

<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-For example:-NOTE"></span><strong id="NOTE">NOTE</strong>: <code>wrapmargin</code> works well with <code>set textwidth=0</code> (i.e., no global limit on text width), as it ensures wrapping happens based on the window width instead of a fixed column width.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-How It Differs From textwidth:"><h4 id="How It Differs From textwidth:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-How It Differs From textwidth:">How It Differs From textwidth:</a></h4></div>

<ul>
<li>
<code>wrapmargin</code>: Dynamically adjusts to the current window size.

<ul>
<li>
For example, if you resize your Vim window, the effective wrapping will change based on the new window width.

</ul>
<li>
<code>textwidth</code>: A fixed width limit for wrapping text, independent of window size.

</ul>
<div id="Controlling Line Wrapping (Linebreaks and Visual)-Example Use Case:"><h4 id="Example Use Case:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Example Use Case:">Example Use Case:</a></h4></div>

<p>
If you're working with text in a narrow Vim window and want wrapping to occur dynamically at a specific margin, you might set:
</p>

<pre vim>
set wrapmargin=5
</pre>

<p>
This ensures that lines are broken 5 columns before the window’s edge, which can be especially helpful for formatting plain text or prose.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Format Options"><h2 id="Format Options" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Format Options">Format Options</a></h2></div>

<ul>
<li>
<code>formatoptions</code> (<code>fo</code>): This governs formatting behaviors during text insertion, editing, or reformatting. Some key flags include:

<ul>
<li>
<code>t</code>: Automatically breaks lines at textwidth during typing.

<li>
<code>c</code>: Automatically wraps comments.

<li>
<code>q</code>: Enables gq to reformat text to respect textwidth.

<li>
<code>l</code>: Does not break lines that are longer than textwidth if they already exist.

<li>
<code>n</code>: Recognizes numbered lists when breaking text.

<li>
<code>r</code>: Automatic insertion of a comment leader when pressing Enter while editing. 

</ul>
</ul>
<p>
<span id="Controlling Line Wrapping (Linebreaks and Visual)-Format Options-Key Point"></span><strong id="Key Point">Key Point</strong>: You can customize <code>formatoptions</code> to fine-tune automatic formatting.
</p>

<div id="Controlling Line Wrapping (Linebreaks and Visual)-Format Options-How These Settings Work Together:"><h4 id="How These Settings Work Together:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Format Options-How These Settings Work Together:">How These Settings Work Together:</a></h4></div>

<ul>
<li>
Visual Wrapping (<code>wrap</code>, <code>linebreak</code>): Determines how lines are shown in the editor but doesn’t affect the actual file content.

<li>
Automatic Line Breaking (<code>textwidth</code>, <code>formatoptions</code>): Controls whether lines are actively split during editing or formatting based on a defined width.

<li>
If you enable wrap and <code>linebreak</code>, Vim will visually wrap text at the window’s edge and break at natural points (but won’t change the file).

<li>
If you set <code>textwidth</code> and <code>fo+=t</code>, Vim will automatically insert a newline when you exceed the specified width.

</ul>
<div id="Controlling Line Wrapping (Linebreaks and Visual)-Format Options-Example Configuration:"><h4 id="Example Configuration:" class="header"><a href="#Controlling Line Wrapping (Linebreaks and Visual)-Format Options-Example Configuration:">Example Configuration:</a></h4></div>

<p>
If you want Vim to:
</p>
<ul>
<li>
Wrap lines visually without modifying them, and ensure clean wrapping:

</ul>
  
<pre vim>
set wrap
set linebreak
</pre>

<ul>
<li>
Automatically break lines at 80 characters:

</ul>
  
<pre vim>
set textwidth=80
set formatoptions+=t
</pre>

<p>
You can mix these settings based on whether you care about visual wrapping, actual content changes, or both!
</p>

<div id="Backspace Settings"><h1 id="Backspace Settings" class="header"><a href="#Backspace Settings">Backspace Settings</a></h1></div>

<p>
The <code>set backspace=</code> option in Vim controls how the <code>&lt;BS&gt;</code> (Backspace) key behaves when editing text. Specifically, it determines where you can backspace over text. By default, backspacing can be somewhat limited, so this setting is very useful for customizing Backspace behavior.
</p>

<div id="Backspace Settings-Default Behavior"><h4 id="Default Behavior" class="header"><a href="#Backspace Settings-Default Behavior">Default Behavior</a></h4></div>

<p>
Without setting any flags (i.e., set backspace=), Vim's Backspace may not work in certain cases, such as:
</p>
<ul>
<li>
Over auto-indented spaces.

<li>
Over line breaks.

<li>
Over text inserted before entering insert mode.

</ul>
<div id="Backspace Settings-Flags Available for backspace:"><h4 id="Flags Available for backspace:" class="header"><a href="#Backspace Settings-Flags Available for backspace:">Flags Available for backspace:</a></h4></div>

<p>
You can specify one or more of the following flags, separated by commas:
</p>
<ul>
<li>
<code>indent</code>:

<ul>
<li>
Allows Backspace to delete over spaces that were inserted automatically for indentation.

<li>
Useful when working with indented code or text.

</ul>
<li>
<code>eol</code>:

<ul>
<li>
Allows Backspace to delete the newline character at the end of a line, effectively joining the current line with the previous one.

</ul>
<li>
<code>start</code>:

<ul>
<li>
Allows Backspace to delete characters inserted before you switched to insert mode.

<li>
Without this flag, you may be restricted from backspacing over text entered in the current edit session.

</ul>
</ul>
<div id="Backspace Settings-Example Configuration:"><h4 id="Example Configuration:" class="header"><a href="#Backspace Settings-Example Configuration:">Example Configuration:</a></h4></div>

<p>
For a more intuitive Backspace behavior, it's common to set all three flags:
</p>

<pre vim>
set backspace=indent,eol,start
</pre>

<p>
This configuration enables Backspace to:
</p>
<ul>
<li>
Remove auto-indents.

<li>
Delete over line breaks.

<li>
Delete text inserted in the current editing session.

</ul>
<p>
You can also simplify the command with:
</p>
<pre vim>
set backspace=2
</pre>

<p>
This is shorthand for enabling all three flags (indent,eol,start).
</p>

<div id="Backspace Settings-Practical Tip:"><h4 id="Practical Tip:" class="header"><a href="#Backspace Settings-Practical Tip:">Practical Tip:</a></h4></div>

<p>
Adding this setting to your Vimrc ensures consistent and predictable Backspace functionality:
</p>

<pre vim>
set backspace=indent,eol,start
</pre>

<p>
This setting helps make editing smoother, especially if you're new to Vim's quirks.
</p>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings"><h2 id="Checking If There Are Existing Key Mappings" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings">Checking If There Are Existing Key Mappings</a></h2></div>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-How to find out if a key combination is mapped somewhere:"><h3 id="How to find out if a key combination is mapped somewhere:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-How to find out if a key combination is mapped somewhere:">How to find out if a key combination is mapped somewhere:</a></h3></div>

<p>
To determine if a specific key combination is already mapped in Vim, you can use the <code>:map</code> family of commands. These commands display mappings for different modes and help you track down where a key combination is being used. Here's how:
</p>
 
<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check All Mappings"><h3 id="Check All Mappings" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check All Mappings">Check All Mappings</a></h3></div>

<p>
Use the following command to view all mappings:
</p>
<pre vim>
:map
</pre>

<p>
This displays a list of all defined mappings, regardless of mode. You can scroll through the list to see if your desired key combination is already mapped.
</p>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings"><h3 id="Check Specific Mode Mappings" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings">Check Specific Mode Mappings</a></h3></div>

<p>
To narrow it down, you can check mappings for specific modes:
</p>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Normal mode:"><h4 id="Normal mode:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Normal mode:">Normal mode:</a></h4></div>

<pre vim>
:nmap
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Insert mode:"><h4 id="Insert mode:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Insert mode:">Insert mode:</a></h4></div>

<pre vim>
:imap
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Visual mode:"><h4 id="Visual mode:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Visual mode:">Visual mode:</a></h4></div>

<pre vim>
:vmap
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Command-line mode:"><h4 id="Command-line mode:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check Specific Mode Mappings-Command-line mode:">Command-line mode:</a></h4></div>

<pre vim>
:cmap
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Search for a Specific Key Combination"><h3 id="Search for a Specific Key Combination" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Search for a Specific Key Combination">Search for a Specific Key Combination</a></h3></div>

<p>
You can use the <code>:verbose</code> command to check if a specific key combination is mapped and where the mapping is defined:
</p>

<pre vim>
:verbose map &lt;key&gt;
</pre>

<p>
For example, to check if &lt;C-k&gt; is mapped, you would type:
</p>

<pre vim>
:verbose map &lt;C-k&gt;
</pre>

<p>
This will tell you:
</p>
<ul>
<li>
Whether the key is mapped.

<li>
The file or script where the mapping is defined (great for debugging!).

</ul>
<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings"><h3 id="Check for Mode-Specific Mappings" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings">Check for Mode-Specific Mappings</a></h3></div>

<p>
To check mappings for a specific mode and a specific key combination, use:
Normal mode:
</p>

<pre vim>
:verbose nmap &lt;key&gt;
</pre>

<p>
Insert mode:
</p>

<pre vim>
:verbose imap &lt;key&gt;
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings-Example in Practice"><h4 id="Example in Practice" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Check for Mode-Specific Mappings-Example in Practice">Example in Practice</a></h4></div>

<p>
If you suspect <code>&lt;C-j&gt;</code> is mapped and want to see its Insert mode mapping, you would use:
</p>

<pre vim>
:verbose imap &lt;C-j&gt;
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys"><h3 id="Bonus: Unmapping Keys" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys">Bonus: Unmapping Keys</a></h3></div>

<p>
If you find an unwanted mapping, you can remove it with the appropriate <code>:unmap</code> command, like:
</p>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Normal mode:"><h4 id="Normal mode:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Normal mode:">Normal mode:</a></h4></div>

<pre vim>
:nunmap &lt;key&gt;
</pre>

<div id="Backspace Settings-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Insert mode:"><h4 id="Insert mode:" class="header"><a href="#Backspace Settings-Checking If There Are Existing Key Mappings-Bonus: Unmapping Keys-Insert mode:">Insert mode:</a></h4></div>

<pre vim>
:iunmap &lt;key&gt;
</pre>


<div id="Settings Based on OS (MacOS, Linux, Windows)"><h1 id="Settings Based on OS (MacOS, Linux, Windows)" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)">Settings Based on OS (MacOS, Linux, Windows)</a></h1></div>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?"><h2 id="Can I share a vimrc by segregating settings?" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?">Can I share a vimrc by segregating settings?</a></h2></div>

<p>
You can structure your Vimrc configuration to accommodate different operating systems. Vim allows you to use conditional statements to detect the underlying system and apply specific settings accordingly.
</p>

<p>
Here's an example of how you might organize your Vimrc for MacOS, Linux, and Windows:
</p>

<pre vim>
if has("mac")
    " Settings specific to MacOS
    set clipboard=unnamedplus
    set guifont=Monaco:h12
elseif has("unix")
    " Settings specific to Linux
    set clipboard=unnamed
    set guifont=DejaVu\ Sans\ Mono:h12
elseif has("win32")
    " Settings specific to Windows
    set clipboard=unnamedplus
    set guifont=Consolas:h12
endif
</pre>

<p>
In this snippet:
</p>
<ul>
<li>
The <code>has()</code> function checks for system-specific features. For example, <code>"mac"</code> for MacOS, <code>"unix"</code> for Linux, and <code>"win32"</code> for Windows.

<li>
You can include any settings tailored to each operating system within their respective blocks.

</ul>
<p>
By structuring your Vimrc file this way, you ensure that it can be shared across all your environments without requiring manual adjustments each time.
</p>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?"><h3 id="What is the 'has()'function doing?" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?">What is the 'has()'function doing?</a></h3></div>

<p>
The <code>has()</code> function in Vim is used to check for the presence of specific features, capabilities, or characteristics within the current Vim environment. It evaluates a string argument and returns <code>1</code> (true) if the feature exists or <code>0</code> (false) if it doesn't.
</p>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?-In the context of a Vimrc:"><h4 id="In the context of a Vimrc:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-What is the 'has()'function doing?-In the context of a Vimrc:">In the context of a Vimrc:</a></h4></div>

<p>
The <code>has()</code> function is being used to detect the operating system by checking for predefined feature strings such as <code>"mac"</code>, <code>"unix"</code>, or <code>"win32"</code>. Each of these strings corresponds to a specific environment:
</p>
<ul>
<li>
<code>"mac"</code>: Indicates that Vim is running on macOS.

<li>
<code>"unix"</code>: Represents any Unix-like system, including Linux and macOS.

<li>
<code>"win32"</code>: Indicates that Vim is running on Windows.

</ul>
<p>
For example:
</p>
<pre vim>
if has("mac")
    " This block runs only if Vim detects macOS
endif
</pre>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions"><h3 id="Conditional Logic Versions" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions">Conditional Logic Versions</a></h3></div>

<p>
Vim supports conditional logic, including "if NOT" scenarios, using the ! (not) operator. This allows you to apply settings when a certain condition, such as being on macOS, is not true. Here's how you could structure it:
</p>

<pre vim>
if !has("mac")
    " Settings for systems that are NOT macOS
    set clipboard=unnamed
    set guifont=DejaVu\ Sans\ Mono:h12
endif
</pre>

<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Explanation:"><h4 id="Explanation:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
The <code>!has("mac")</code> evaluates to true only if Vim is not running on macOS.

<li>
Within this block, you can define all settings for other systems, such as Linux or Windows.

</ul>
<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Combining with Other Conditions:"><h4 id="Combining with Other Conditions:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-Conditional Logic Versions-Combining with Other Conditions:">Combining with Other Conditions:</a></h4></div>

<p>
If you'd like to combine this with more specific conditions, you can nest or extend your logic. For example:
</p>

<pre vim>
if !has("mac")
    if has("unix")
        " Settings specific to Linux
        set guifont=DejaVu\ Sans\ Mono:h12
    elseif has("win32")
        " Settings specific to Windows
        set guifont=Consolas:h12
    endif
endif
</pre>

<p>
This approach ensures you handle all non-macOS systems while still being precise about Linux versus Windows settings.
</p>


<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():"><h3 id="More Examples of has():" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():">More Examples of has():</a></h3></div>

<p>
Here are other things you can check using <code>has()</code>:
</p>
<ul>
<li>
<code>"gui"</code>: Checks if Vim is running with a graphical user interface (e.g., GVim).

<li>
<code>"clipboard"</code>: Checks if clipboard support is available.

<li>
<code>"python3"</code>: Checks if Python 3 support is enabled in Vim.

</ul>
<div id="Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():-Practical Use:"><h4 id="Practical Use:" class="header"><a href="#Settings Based on OS (MacOS, Linux, Windows)-Can I share a vimrc by segregating settings?-More Examples of has():-Practical Use:">Practical Use:</a></h4></div>

<p>
You can use <code>has()</code> in conditional statements to tailor your configuration based on the features available in your Vim setup. This allows you to write more portable and adaptive Vimrc files.
</p>

<div id="Using the has() Function Outside of the Vimrc"><h1 id="Using the has() Function Outside of the Vimrc" class="header"><a href="#Using the has() Function Outside of the Vimrc">Using the has() Function Outside of the Vimrc</a></h1></div>

<p>
The has() function can be used outside of the Vimrc configuration file. It works in any Vim script or even interactively within Vim, making it quite versatile for checking features during runtime.
</p>

<div id="Using the has() Function Outside of the Vimrc-How to use has() outside of Vimrc:"><h4 id="How to use has() outside of Vimrc:" class="header"><a href="#Using the has() Function Outside of the Vimrc-How to use has() outside of Vimrc:">How to use has() outside of Vimrc:</a></h4></div>

<ul>
<li>
Interactive Usage in Command Mode: You can type commands directly into Vim to use the <code>has()</code> function. For example:

</ul>
  
<pre vim>
:if has("mac")
    :echo "You are using MacOS"
:endif
</pre>

<p>
This will check if Vim is running on macOS and display the message if true.
</p>

<ul>
<li>
Custom Functions: You can use has() in your custom Vim script functions to make them adapt to specific environments. For example:

</ul>
  
<pre vim>
function! MyCustomSetup()
    if has("unix")
        echo "Setting up for Unix-like systems"
        " Add your Unix-specific commands here
    elseif has("win32")
        echo "Setting up for Windows"
        " Add your Windows-specific commands here
    endif
endfunction
</pre>

<p>
You can call this function interactively with <code>:call MyCustomSetup()</code> or include it in a script.
</p>

<ul>
<li>
Plugins and Advanced Scripts: When writing plugins or more advanced scripts for Vim, <code>has()</code> can be used to conditionally enable or disable features based on availability. For example:

</ul>
  
<pre vim>
if has("clipboard")
    echo "Clipboard support available!"
else
    echo "Clipboard support is not enabled."
endif
</pre>

<div id="Using the has() Function Outside of the Vimrc-Why Use 'has()' Outside Vimrc?"><h4 id="Why Use 'has()' Outside Vimrc?" class="header"><a href="#Using the has() Function Outside of the Vimrc-Why Use 'has()' Outside Vimrc?">Why Use 'has()' Outside Vimrc?</a></h4></div>

<p>
Using <code>has()</code> interactively or in custom scripts allows you to adapt Vim behavior dynamically, based on the environment or available features. It's particularly useful for debugging, testing, or creating more complex automation workflows within Vim.
</p>

<div id="Lists in the Vimrc"><h1 id="Lists in the Vimrc" class="header"><a href="#Lists in the Vimrc">Lists in the Vimrc</a></h1></div>

<p>
You can declare a list in your Vimrc and split it across multiple lines for better readability. Vim supports this kind of syntax as long as you use a backslash (<code>\</code>) to indicate that the line continues.
</p>

<p>
Here’s an example of how to do it:
</p>
<pre vim>
let my_list = [
      \ 'item1',
      \ 'item2',
      \ 'item3',
      \ 'item4'
      \ ]
</pre>

<p>
<span id="Lists in the Vimrc-NOTE"></span><strong id="NOTE">NOTE</strong>: To declare the list as a global variable/list, prefix the name with <code>g:</code> (g:my_list).
</p>

<div id="Lists in the Vimrc-Explanation:"><h4 id="Explanation:" class="header"><a href="#Lists in the Vimrc-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
The square brackets (<code>[ ]</code>) define the list.

<li>
The backslash (<code>\</code>) at the beginning of each new line tells Vim that the statement continues onto the next line.

<li>
You can add as many items as you like, each separated by a comma.

</ul>
<p>
This approach makes it easy to keep your Vimrc organized and manageable, especially for longer lists.
</p>

<div id="Dictionaries in the Vimrc"><h1 id="Dictionaries in the Vimrc" class="header"><a href="#Dictionaries in the Vimrc">Dictionaries in the Vimrc</a></h1></div>

<p>
Just as with lists, you can declare and split dictionaries.
</p>

<p>
Here's an example of how to declare a dictionary:
</p>
<pre vim>
let my_dict = {
    \ 'one': 'il',
    \ 'two': 'i',
    \ 'three': 'sam',
    \ 'four': 'sa',
    \ 'five': 'oh'
    \}
</pre>

<p>
<span id="Dictionaries in the Vimrc-NOTE"></span><strong id="NOTE">NOTE</strong>: To declare the dictionary as a global variable/list, prefix the name with <code>g:</code> (g:my_dict).
</p>

<div id="Dictionaries in the Vimrc-Explanation:"><h4 id="Explanation:" class="header"><a href="#Dictionaries in the Vimrc-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
The curly braces (<code>{ }</code>) define the dictionary.

<li>
The backslash (<code>\</code>) at the beginning of each new line tells Vim that the statement continues onto the next line.

<li>
You can add as many keys &amp; values as you like, each separated by a comma.

</ul>
<div id="Setting Options Programmatically"><h1 id="Setting Options Programmatically" class="header"><a href="#Setting Options Programmatically">Setting Options Programmatically</a></h1></div>

<p>
Initial example:
</p>
<pre vim>
let &amp;background = strftime("%H") &lt; 10 ? "light" : "dark"
</pre>

<div id="Setting Options Programmatically-Setting Options Programmatically"><h3 id="Setting Options Programmatically" class="header"><a href="#Setting Options Programmatically-Setting Options Programmatically">Setting Options Programmatically</a></h3></div>

<p>
In Vim, most settings (or options) can be set with the <code>:set</code> command. However, when you use a let statement with the ampersand prefix (e.g., <code>&amp;background</code>), you’re directly assigning a value to a Vim option. This is useful when you want the value to be determined programmatically rather than hardcoded. These settings are evaluated at Vim's launch, and do not update on changing conditions (like time). (See dynamic options below.)
</p>

<ul>
<li>
<code>let &amp;background = ...</code> This assigns a value to the background option. Normally, you might set it manually by doing <code>:set background=light</code> or <code>:set background=dark</code>, but here we’re calculating it on the fly.

</ul>
<div id="Setting Options Programmatically-Using strftime(&quot;%H&quot;)"><h3 id="Using strftime(&quot;%H&quot;)" class="header"><a href="#Setting Options Programmatically-Using strftime(&quot;%H&quot;)">Using strftime("%H")</a></h3></div>

<ul>
<li>
<code>strftime("%H")</code> This function returns the current hour in a 24-hour format (from "00" to "23"). For example, if it's 9 AM, <code>strftime("%H")</code> will yield <code>"09"</code> (a string).

<li>
Vim automatically converts this string to a number when you use it in a numeric comparison (like <code>&lt; 10</code>).

</ul>
<div id="Setting Options Programmatically-The Ternary Operator"><h3 id="The Ternary Operator" class="header"><a href="#Setting Options Programmatically-The Ternary Operator">The Ternary Operator</a></h3></div>

<p>
Looking at the initial example above:
</p>
<ul>
<li>
<code>? "light" : "dark"</code> Vim supports a ternary conditional operator, which is similar to those found in languages like C, Python (using a different syntax), or JavaScript.

<ul>
<li>
Syntax: <code>condition ? value_if_true : value_if_false</code>

<li>
In this example, the expression evaluates whether the current hour is less than 10.

<ul>
<li>
If true (i.e., before 10 AM), the expression returns <code>"light"</code>.

<li>
If false (i.e., 10 AM or later), it returns <code>"dark"</code>.

</ul>
</ul>
</ul>
<div id="Setting Options Programmatically-What the Entire Expression Does"><h3 id="What the Entire Expression Does" class="header"><a href="#Setting Options Programmatically-What the Entire Expression Does">What the Entire Expression Does</a></h3></div>

<div id="Setting Options Programmatically-What the Entire Expression Does-Evaluation of Time:"><h4 id="Evaluation of Time:" class="header"><a href="#Setting Options Programmatically-What the Entire Expression Does-Evaluation of Time:">Evaluation of Time:</a></h4></div>

<ul>
<li>
<code>strftime("%H")</code> fetches the current hour.

</ul>
<div id="Setting Options Programmatically-What the Entire Expression Does-Comparison:"><h4 id="Comparison:" class="header"><a href="#Setting Options Programmatically-What the Entire Expression Does-Comparison:">Comparison:</a></h4></div>

<ul>
<li>
The <code>&lt;10</code> expression checks if the current hour (as a number) is less than 10.

</ul>
<div id="Setting Options Programmatically-What the Entire Expression Does-Conditional Assignment:"><h4 id="Conditional Assignment:" class="header"><a href="#Setting Options Programmatically-What the Entire Expression Does-Conditional Assignment:">Conditional Assignment:</a></h4></div>

<ul>
<li>
If it is earlier than 10 AM, the ternary operator produces <code>"light"</code>.

<li>
Otherwise, it produces <code>"dark"</code>.

</ul>
<div id="Setting Options Programmatically-What the Entire Expression Does-Setting the Option:"><h4 id="Setting the Option:" class="header"><a href="#Setting Options Programmatically-What the Entire Expression Does-Setting the Option:">Setting the Option:</a></h4></div>

<ul>
<li>
That resulting value is then used to set the <code>background</code> option.

<ul>
<li>
When background is <code>"light"</code>, many color schemes switch to colors that work better on bright backgrounds.

<li>
When <code>"dark"</code>, color schemes that expect a dark background are used.

</ul>
</ul>
<p>
Thus, your Vim environment automatically adjusts based on the time of day, making the interface easier on your eyes according to ambient lighting.
</p>

<div id="Setting Options Programmatically-Other Ideas for Dynamic Settings"><h3 id="Other Ideas for Dynamic Settings" class="header"><a href="#Setting Options Programmatically-Other Ideas for Dynamic Settings">Other Ideas for Dynamic Settings</a></h3></div>

<p>
You can use similar techniques to programmatically set other options based on conditions. Here are some ideas:
</p>
<ul>
<li>
Enable Mouse Selection Only in the GUI

</ul>
  
<pre vim>
let &amp;mouse = has("gui_running") ? "a" : ""
</pre>

<div id="Setting Options Programmatically-Other Ideas for Dynamic Settings-Explanation:"><h4 id="Explanation:" class="header"><a href="#Setting Options Programmatically-Other Ideas for Dynamic Settings-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
<code>has("gui_running")</code> checks if you're running a GUI version of Vim.

<li>
If true, it sets <code>mouse</code> to <code>"a"</code> (enabling the mouse in all modes).

<li>
Otherwise, it leaves the mouse disabled.

</ul>
<div id="Setting Options Programmatically-Choose a Shell Based on Operating System"><h3 id="Choose a Shell Based on Operating System" class="header"><a href="#Setting Options Programmatically-Choose a Shell Based on Operating System">Choose a Shell Based on Operating System</a></h3></div>

<pre vim>
let &amp;shell = has("win32") ? "powershell.exe" : "/bin/bash"
</pre>

<div id="Setting Options Programmatically-Choose a Shell Based on Operating System-Explanation:"><h4 id="Explanation:" class="header"><a href="#Setting Options Programmatically-Choose a Shell Based on Operating System-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
This checks if Vim is running on Windows.

<li>
If so, it sets the shell to <code>PowerShell</code>; otherwise, it defaults to <code>/bin/bash</code>.

</ul>
<div id="Setting Options Programmatically-Set the Tab Width Based on File Type"><h3 id="Set the Tab Width Based on File Type" class="header"><a href="#Setting Options Programmatically-Set the Tab Width Based on File Type">Set the Tab Width Based on File Type</a></h3></div>

<p>
You can use an <code>autocmd</code> with a conditional check:
</p>

<pre vim>
autocmd FileType python let &amp;tabstop = (&amp;expandtab ? 4 : 8)
</pre>

<div id="Setting Options Programmatically-Set the Tab Width Based on File Type-Explanation:"><h4 id="Explanation:" class="header"><a href="#Setting Options Programmatically-Set the Tab Width Based on File Type-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
For Python files, this example conditionally sets <code>tabstop</code> depending on whether the <code>expandtab</code> option is on.

<li>
(While the logic here is more contrived, it shows the idea of dynamically adjusting options based on context.)

</ul>
<div id="Setting Options Programmatically-Adjusting the Status Line Based on Terminal Size"><h3 id="Adjusting the Status Line Based on Terminal Size" class="header"><a href="#Setting Options Programmatically-Adjusting the Status Line Based on Terminal Size">Adjusting the Status Line Based on Terminal Size</a></h3></div>

<pre vim>
let &amp;statusline = (winwidth(0) &lt; 80 ? '%f' : '%f %h%m%r %= %l,%c')
</pre>

<div id="Setting Options Programmatically-Adjusting the Status Line Based on Terminal Size-Explanation:"><h4 id="Explanation:" class="header"><a href="#Setting Options Programmatically-Adjusting the Status Line Based on Terminal Size-Explanation:">Explanation:</a></h4></div>

<ul>
<li>
<code>winwidth(0)</code> returns the width of the current window.

<li>
If the window is narrow (less than 80 columns), the status line is simplified to just show the filename (<code>%f</code>).

<li>
Otherwise, it uses a fuller status line with various details.

</ul>
<div id="Setting Options Programmatically-Principles Illustrated by This Technique"><h3 id="Principles Illustrated by This Technique" class="header"><a href="#Setting Options Programmatically-Principles Illustrated by This Technique">Principles Illustrated by This Technique</a></h3></div>

<div id="Setting Options Programmatically-Principles Illustrated by This Technique-Dynamic Configuration:"><h4 id="Dynamic Configuration:" class="header"><a href="#Setting Options Programmatically-Principles Illustrated by This Technique-Dynamic Configuration:">Dynamic Configuration:</a></h4></div>

<ul>
<li>
You’re not stuck with static settings; you can adapt the environment based on time, system attributes, file type, or even the contents of your buffer.

</ul>
<div id="Setting Options Programmatically-Principles Illustrated by This Technique-Ternary Operator:"><h4 id="Ternary Operator:" class="header"><a href="#Setting Options Programmatically-Principles Illustrated by This Technique-Ternary Operator:">Ternary Operator:</a></h4></div>

<ul>
<li>
Provides a compact way to choose between values without writing a longer if–else construct.

</ul>
<div id="Setting Options Programmatically-Principles Illustrated by This Technique-Built-In Functions:"><h4 id="Built-In Functions:" class="header"><a href="#Setting Options Programmatically-Principles Illustrated by This Technique-Built-In Functions:">Built-In Functions:</a></h4></div>

<ul>
<li>
Functions like <code>strftime()</code>, <code>has()</code>, and others enable you to write more context-sensitive configurations.

</ul>
<div id="Setting Options Programmatically-Principles Illustrated by This Technique-Customization &amp; Flexibility:"><h4 id="Customization &amp; Flexibility:" class="header"><a href="#Setting Options Programmatically-Principles Illustrated by This Technique-Customization &amp; Flexibility:">Customization &amp; Flexibility:</a></h4></div>

<p>
This approach exemplifies how Vim’s scripting allows you to fine-tune your environment to your personal workflow and context, making your editing experience more productive and comfortable.
</p>

<div id="Setting Options Programmatically-In Summary"><h3 id="In Summary" class="header"><a href="#Setting Options Programmatically-In Summary">In Summary</a></h3></div>

<p>
The command:
</p>
<pre vim>
let &amp;background = strftime("%H") &lt; 10 ? "light" : "dark"
</pre>
<p>
...demonstrates how you can use Vimscript's built-in functions, conditional (ternary) operators, and direct option assignment to create a dynamic configuration. You can extend this idea to many other settings in your Vimrc to automatically adjust your environment based on time of day, system properties, or other criteria.
</p>

<div id="Setting Dynamic Settings Programmatically"><h1 id="Setting Dynamic Settings Programmatically" class="header"><a href="#Setting Dynamic Settings Programmatically">Setting Dynamic Settings Programmatically</a></h1></div>

<div id="Setting Dynamic Settings Programmatically-Making It Dynamic"><h2 id="Making It Dynamic" class="header"><a href="#Setting Dynamic Settings Programmatically-Making It Dynamic">Making It Dynamic</a></h2></div>

<p>
If you want the setting to update dynamically, you'll need to trigger a re-evaluation. Here are a couple of strategies:
</p>

<div id="Setting Dynamic Settings Programmatically-Making It Dynamic-Manual Update:"><h4 id="Manual Update:" class="header"><a href="#Setting Dynamic Settings Programmatically-Making It Dynamic-Manual Update:">Manual Update:</a></h4></div>

<p>
You could define a function and manually call it when needed:
</p>
<pre vim>
function! UpdateBackground()
    let &amp;background = strftime("%H") &lt; 10 ? "light" : "dark"
endfunction
</pre>

<p>
Then run <code>:call UpdateBackground()</code> whenever you want to refresh the background.
</p>

<div id="Setting Dynamic Settings Programmatically-Making It Dynamic-Using Autocommands / Timers (Vim 8+):"><h4 id="Using Autocommands / Timers (Vim 8+):" class="header"><a href="#Setting Dynamic Settings Programmatically-Making It Dynamic-Using Autocommands / Timers (Vim 8+):">Using Autocommands / Timers (Vim 8+):</a></h4></div>

<p>
Vim 8 introduced timers which can be used to run functions periodically:
</p>
<pre vim>
function! UpdateBackground()
    let &amp;background = strftime("%H") &lt; 10 ? "light" : "dark"
endfunction

" Run the function every 10 minutes (600000 milliseconds)
call timer_start(600000, { -&gt; UpdateBackground() }, {'repeat': -1})
</pre>

<p>
This setup will check and update the background setting every 10 minutes.
</p>

<div id="Setting Dynamic Settings Programmatically-Making It Dynamic-Summary"><h3 id="Summary" class="header"><a href="#Setting Dynamic Settings Programmatically-Making It Dynamic-Summary">Summary</a></h3></div>

<div id="Setting Dynamic Settings Programmatically-Making It Dynamic-Summary-Default Behavior:"><h4 id="Default Behavior:" class="header"><a href="#Setting Dynamic Settings Programmatically-Making It Dynamic-Summary-Default Behavior:">Default Behavior:</a></h4></div>
<p>
The setting is determined at startup and remains unchanged during that session.
</p>
<div id="Setting Dynamic Settings Programmatically-Making It Dynamic-Summary-Dynamic Behavior:"><h4 id="Dynamic Behavior:" class="header"><a href="#Setting Dynamic Settings Programmatically-Making It Dynamic-Summary-Dynamic Behavior:">Dynamic Behavior:</a></h4></div>
<p>
To have it updated dynamically, you must explicitly set up a mechanism (like a timer or manual function calls).
</p>

<p>
This approach gives you flexibility depending on how "dynamic" you need your configuration to be.
</p>

<div id="Example Vimrc (250405)"><h1 id="Example Vimrc (250405)" class="header"><a href="#Example Vimrc (250405)">Example Vimrc (250405)</a></h1></div>
<pre vim>
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" START OF .VIMRC
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"__author__ = "noddy"
"__date__ = "2025/4/5"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
"               ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗
"               ██║   ██║██║████╗ ████║██╔══██╗██╔════╝
"               ██║   ██║██║██╔████╔██║██████╔╝██║
"               ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║
"                ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗
"                 ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" zo to open folded lines
" zc to close folder lines
" za to open/close folded lines
" zr to open one level of all folded lines
" zR to open ALL levels of lines
" zm to close one level of all folded lines
" zM to close ALL levels of lines
" zn disable folding
" zN enable folding
" zi toggle disable/enable folding
" zf create
" zd delete fold markers
" zj, zk - next and last fold - custom function

" Vimscript Introduction &amp; Notes --------------------------------------------{{{

"----------------------- INVENTORY OF MAPPINGS - START ------------------------"
" Inventory Of Mappings:
" jk  --&gt; &lt;esc&gt; (Insert, Visual).
" cp  --&gt; Copy filename (buffer) to clipboard (reg +).
" ccp --&gt; Copy full path name of file (buffer) to clipboard (reg +).
" cx  --&gt; Copy whole buffer contents to clipboard (reg +).
"
" Leader Key Is Space:
" &lt;leader&gt;l  --&gt; Show invisibles.
" &lt;leader&gt;ev --&gt; Vertical Split.
" &lt;leader&gt;sv --&gt; Reload Vimrc.
" &lt;leader&gt;tc --&gt; Selection to Title Case (very spotty).
" &lt;leader&gt;cc --&gt; Selection to CamelCase.
" &lt;leader&gt;s  --&gt; Surround a selected words with quotes and commas as in a list
" (doesn't work on 'line' selections).
"
" &lt;F5&gt;      --&gt; Delete trailing white space.
" &lt;BS&gt;      --&gt; Backspace - Highlight search on/off.
" &lt;leader&gt;k --&gt; Show Column guide (at column 80).
" &lt;tab&gt;        --&gt; Invoke autocomplete, and Tab through possibilities.
" &lt;Shift&gt;&lt;tab&gt; --&gt; Invoke autocomplete, and Tab through possibilities backwards.
"
" &lt;leader&gt;` --&gt; (Back-tick) Shortcut to surround word with `word` (via Surround)
"
" Window Navigation:
" &lt;ctrl&gt;h --&gt; move to window on left
" &lt;ctrl&gt;j --&gt; move to window bellow
" &lt;ctrl&gt;k --&gt; move to window above
" &lt;ctrl&gt;l --&gt; move to window on right
"
" &lt;leader&gt;th --&gt; change horizontal split to vertical split
" &lt;leader&gt;tk --&gt; change vertical split to horizontal split
"
" SRT Subtitle Tools:
" :Go #     --&gt; Jump to the same line number on a numbered buffer.
" &lt;leader&gt;h --&gt; Remove Hard of Hearing elements in an SRT subtitle file.
" &lt;leader&gt;t --&gt; Retime preceding timecodes to 10th of second increments.
" :ShiftSrt #&lt;unit&gt; --&gt; Adjust timecodes accordingly (via vim-srt-sync)
"
" Colorschemes And AirlineTheme Shortcuts:
" &lt;leader&gt;r --&gt; Set random Colorscheme
" &lt;leader&gt;a --&gt; Set random AirlineTheme
"
" Python And C:
" &lt;F9&gt;  --&gt; Compile (via SingleCompile Plugin).
" &lt;F10&gt; --&gt; Compile &amp; Run (via SingleCompile Plugin).
"
" Abbreviations:
" rrr     --&gt; Code Date &amp; Author header.
" ccc     --&gt; Comment Header.
" ifmain  --&gt; Python 'if __name__ == '__main__": line
" shebang --&gt; Python: '#!/usr/bin/env python3'.
" thetime --&gt; Example: Sat Apr  5 16:17:51 2025
"
" Fold &lt;String or Phrase&gt; --&gt; Create empty labeled fold (like in this Vimrc).
" Header &lt;String or Phrase&gt; --&gt; Create single labeled horizontal header/break.
"
" Vimwiki:
" &lt;leader&gt;ww --&gt; Open Vimwiki in current buffer window
" www        --&gt; Run VimwikiAll2HTML (convert to html)
" gwww       --&gt; Run !mvwdeploy - Git commit changes (Mac)
" mwww       --&gt; Run !mvwdeploy - Git commit changes (Mac)
" lwww       --&gt; Run !vwdeploy - Git commit changes (Linux)
"------------------------ INVENTORY OF MAPPINGS - END -------------------------"
"

" }}}

" Vimscript Basic Settings  -------------------------------------------------{{{

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SETTINGS:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Display line numbers on left margin:
set number         " long form of set nu
" Display numbers above and below cursor line with relative-to-cursor numbering
set relativenumber " long form of set rnu
"set nu rnu " to set both the same time
"
" set hidden will prevent vim from offering to save buffers as you switch
set hidden
" set mouse active - allows navigation with mouse (works on touch screens)
set mouse=a
"
" Suppress the introduction page when launching Vim:
" This has to come AFTER 'set nocompatible' if present.
" (Otherwise 'set nocompatible' restores the defaults.)
set shortmess+=I
"
" Connect the system clipboard to the regular copy/yank register (register "):
set clipboard=unnamed
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT WRAPPING - START
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"------------------------ TEXT WRAPPING - VISUAL ONLY -------------------------"
" VISUAL ONLY:
"
set wrap              " Visual wrapping enabled (for display only)
"set nowrap
" Line break on spaces and word boundaries (not mid-word)
set linebreak "set lbr
"
" When there is a (visual) linebreak, show the symbol "&gt; " (backslash
" escapes space)
set showbreak=&gt;\ "note white space before quotes to give visual breathing room!
"
"--------------------- TEXT WRAPPING - TEXT MODIFICATION ----------------------"
" ACTUAL TEXT MANIPULATION:
"
set textwidth=0       " No wrapping for normal text when zero
" Overwriting 'textwidth' for Vim filetypes:
autocmd FileType vim setlocal textwidth=78
"
"set wrapmargin=5     " This works best if textwidth is set to zero
"
" NOTES: FORMAT OPTIONS:
" Format options for auto-formatting and comment handling
" `formatoptions` (`fo`): This governs formatting behaviors during text
" insertion, editing, or reformatting. Some key flags include:
"    * `t`: Automatically breaks lines at textwidth during typing.
"    * `c`: Automatically wraps comments.
"    * `q`: Enables gq to reformat text to respect textwidth.
"    * `l`: Does not break lines that are longer than textwidth if they already exist.
"    * `n`: Recognizes numbered lists when breaking text.
"    * `r`: Automatic insertion of a comment leader when pressing Enter while editing. 
"    * `o`: Automatic insertion of a comment leader when pressing 'o' or 'O'
set formatoptions+=cro
"
" Overwriting 'formatoptions' for Vim filetypes:
autocmd FileType vim setlocal formatoptions+=cro
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT WRAPPING - END
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CONFIGURE TAB ENTRY AND NICE STUFF... START
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab       " Use spaces instead of tabs
set tabstop=4       " Display width of a tab character
set shiftwidth=4    " Use 4 spaces for indentation
set softtabstop=4   " Insert/delete 4 spaces when pressing &lt;tab&gt;/&lt;BS&gt;
"
set autoindent       " Copy indent from current line when starting a new line
"set highlight ColorColumn ctermbg=magenta
" make backspaces more powerfull
set backspace=indent,eol,start
" Syntax On needs to load after filetype and Polyglot settings: adding it later
"syntax on               " syntax highlighting
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CONFIGURE TAB ENTRY AND NICE STUFF... END
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
" The 'nrformats' (number formats) option in Vim controls which types of
" numbers are incremented and decremented using commands like Ctrl-a and Ctrl-x.
set nrformats=bin,hex,octal,alpha
"
" Spell checker ON
set spell spelllang=en_us
" Spell check OFF
"set nospell
" Toggle spell on/off:
"set spell!
"
" NOTES: SPELLING SHORTCUTS: 
" zg # add word to dictionary
" zw # remove word from dictionary (mark as bad)
" z= # show list of suggestions
" ]s # next mis-spelled word
" [s # previous mis-spelled word
"
" Auto change directory to the file opened:
set autochdir
"
" Comments setting for Vimscript (or your preferred language)
" This example shows comment markers for Vimscript, where " is used to
" start comments.
set comments="sO:\"\\ -,mO:\"\\ ,eO:\"\\"
"
" COMMANDLINE INTERACTION SEARCHES:
set wildmenu         " Tab completion in command-line mode (:e, :find, etc.)
" Setting showcmd AFTER plugins later in the Vimrc
"set showcmd          " Display incomplete command (e.g., d3w)
set incsearch        " Incremental Search - highlight matches as you type
set ignorecase       " Makes searches case-insensitive
" smartcase works with ignorecase setting. If search is all lowercase, the
" search is case-insensitive, if any uppercase letters are typed it becomes a
" case-sensitive search.
set smartcase
"
" CURSOR FEEDBACK:
" Add horizontal highlight along current line:
set cursorline
"set cursorcolumn
set showcmd          " Display (partial) command in status line
set showmatch        " Display matching brackets
set ruler            " Display cursor postion (line &amp; column) bottom-right
"
" AUTOMATIC CODE FORMATTING:
"set smartindent     " Try to adjust indentation based on code structure
set cindent          " Indentation based on C-style code; like {} and if
set cinkeys-=0#      " Removes 0# shortcut from cinkeys setting (for C-style)
set indentkeys-=0#   " Removes 0# shortcut from generic indentation (all styles)
"
" Trigger scrolling when this many lines from the top or bottom of the page
set scrolloff=5
"
"" Apparently, 'nocompatible' is not needed 'these days'. Commenting out:
"" https://vi.stackexchange.com/questions/25149/advice-to-add-set-nocompatible-as-first-line-of-vimrc
"set nocompatible
"

" }}}

" Vimscript Invisibles --------------------------------------{{{

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Invisibles - START
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" http://vimcasts.org/episodes/show-invisibles/
" Use the same symbols as TextMate for tabstops and EOLs
" Note: ▸ won't show up if you have expandtab set (since tabs are spaces)
" set listchars=tab:▸\ ,eol:¬
"https://www.youtube.com/watch?v=M-IqFOjY7Pk"
"Use the same symbols as TheFrugalComputerGuy for tabstops and EOLs
"set listchars=tab:→\ ,eol:↲
" show tab and eol chars by default
"set list
set nohls
"
" When using :set list (to show invisibles), these settings customize
" representations and also include Non-breaking-spaces, and
" Narrow-non-breaking-spaces (both covered by the nbsp assignment).
" (Note that tab needs two chars, but since I'm using an escape
" to use 'space', there are three)
set listchars=eol:¬,tab:▸\ ,trail:~,extends:&gt;,precedes:&lt;,space:␣,nbsp:⸤
" To allow for the showing of the nbsp substitute character "⸤":
set conceallevel=1
" These two syn lines don't survive the vimrc load, and only work
" interactively:
" syn match NBSP '\%xa0' conceal cchar=⸤
" syn match NarrowNBSP '\%u202F' conceal cchar=⸤
"
" Shortcut to rapidly toggle `set list` (to show invisible characters)
nmap &lt;leader&gt;l :set list!&lt;CR&gt;
"
"Invisible character colors
"highlight NonText guifg=#4a4a59
"highlight SpecialKey guifg=#4a4a59
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Invisibles - END
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" }}}

" Vimscript Custom Mappings and Remappings ----------------------------------{{{

" Remapping:
"-----------
" set jk to replace escape key for insert mode
inoremap jk &lt;esc&gt;
" set jk to replace escape key for visual mode
vnoremap jk &lt;esc&gt;
"
" Remove mapping from &lt;Space&gt; then map as leader:
nnoremap &lt;Space&gt; &lt;nop&gt;
" Adding &lt;Space&gt; as the leader key (two options):
"let mapleader=" "
" or:
let mapleader = "\&lt;Space&gt;"
"
"" Open vimrc file in a split window:
nnoremap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt;
"" Source vimrc file
nnoremap &lt;leader&gt;sv :source $MYVIMRC&lt;cr&gt;
"
"" Surround a word with quotes: (not using since vim-surround plugin is on)
"nnoremap &lt;leader&gt;" viw&lt;esc&gt;a"&lt;esc&gt;bi"&lt;esc&gt;lel
"
" &lt;Backspace&gt; to toggle Highlighting on Search (and show status after toggle):
nnoremap &lt;BS&gt; :set hlsearch! hlsearch?&lt;CR&gt;
"
" Add keystroke (F5) to delete all trailing white space:
nnoremap &lt;silent&gt; &lt;F5&gt; :let _s=@/ &lt;Bar&gt; :%s/\s\+$//e &lt;Bar&gt; :let @/=_s &lt;Bar&gt; :nohl &lt;Bar&gt; :unlet _s &lt;CR&gt;
"
" For Linux, this disables the Ctrl-Z keys - to stop gvim minimizing.
nnoremap &lt;c-z&gt; &lt;nop&gt;
"
"" This vimrc is currently setting linespace in the airline section below.
" Set the 'linespace' for spacing BETWEEN lines:
" set linespace=0 " This is 'normal'
" set linespace=6 " This setting of '3' is more like GitHub's 'look'
"
" # I needed to map this to a key to allow OSX copy paste:
" (However, I now use "+y instead to copy to the system clipboard.)
":call system("pbcopy",@")
"vnoremap &lt;silent&gt;&lt;leader&gt;y "yy &lt;Bar&gt; :call system('xclip', @y)&lt;CR&gt;
"vnoremap &lt;silent&gt; ,&lt;space&gt;  &lt;Bar&gt; :call system("pbcopy",@")&lt;CR&gt;
"
" Copy buffer (file) name to the system clipboard:
nnoremap cp :let @+ = expand("%")&lt;cr&gt;
"
" Copy buffer (file) name AND FULL PATH to the system clipboard:
nnoremap cpp :let @+ = expand("%:p")&lt;cr&gt;
"
" Copy whole buffer text to system clipboard:
" Switching off &lt;c-x&gt; due to conflict with decrement numbers:
"nnoremap &lt;c-x&gt; ggVG"+y
" Same as above with different mapping: cx ('c' followed by 'x' key)
nnoremap cx ggVG"+y
"
" Convert selected text to Title Case
vnoremap &lt;leader&gt;tc :s/\&lt;\w\+/\u\0/g&lt;CR&gt;gv:s/\(\&lt;\w\)\(\w\+\)/\1\L\2/g&lt;CR&gt;gv
"
" Convert selected text to CamelCase
vnoremap &lt;leader&gt;cc :s/\&lt;./\u&amp;/g&lt;CR&gt;gv:s/\s\+\(\w\)/\u\1/g&lt;CR&gt;gv:s/\s//g&lt;CR&gt;gvnorm gUiW&lt;CR&gt;
"
" Function to remember the current line and jump to the same line number in
" a given buffer #
function! GotoSameLineInBuffer(bufnum)
    let linenum = line(".")
    execute "buffer" a:bufnum
    execute linenum
endfunction
" Mapping to call the function above:
command! -nargs=1 Go call GotoSameLineInBuffer(&lt;f-args&gt;)
"
" Function to surround each word in a selected list with quotes, and add a
" dividing comma.
" Issues with full line selections - it duplicates before substitutions.
function! SurroundWordsWithQuotesAndCommas()
  " Get the start and end positions of the visual selection
  let start_pos = getpos("'&lt;")
  let end_pos = getpos("'&gt;")
  " Extract the text within the visual selection
  let start_line = start_pos[1]
  let start_col = start_pos[2]
  let end_line = end_pos[1]
  let end_col = end_pos[2]
  " Iterate through each line in the selection
  for line_num in range(start_line, end_line)
    let line_text = getline(line_num)
    " Handle partial lines for the start and end of the selection
    if line_num == start_line &amp;&amp; line_num == end_line
      let selected_text = line_text[start_col - 1:end_col - 1]
      " Surround words with quotes, and ensure proper commas
      let modified_text = substitute(selected_text, '\(\&lt;\w\+\(-\w\+\)*\&gt;\)', "'&amp;'", 'g')
      let modified_text = substitute(modified_text, '\s\+', ', ', 'g')
      let modified_text = substitute(modified_text, ',\s*,', ',', 'g')
      let line_text = line_text[:start_col - 2] . modified_text . line_text[end_col:]
    elseif line_num == start_line
      let selected_text = line_text[start_col - 1:]
      let modified_text = substitute(selected_text, '\(\&lt;\w\+\(-\w\+\)*\&gt;\)', "'&amp;'", 'g')
      let modified_text = substitute(modified_text, '\s\+', ', ', 'g')
      let modified_text = substitute(modified_text, ',\s*,', ',', 'g')
      let line_text = line_text[:start_col - 2] . modified_text
    elseif line_num == end_line
      let selected_text = line_text[:end_col - 1]
      let modified_text = substitute(selected_text, '\(\&lt;\w\+\(-\w\+\)*\&gt;\)', "'&amp;'", 'g')
      let modified_text = substitute(modified_text, '\s\+', ', ', 'g')
      let modified_text = substitute(modified_text, ',\s*,', ',', 'g')
      let line_text = modified_text . line_text[end_col:]
    else
      " Modify the whole line for lines in between
      let line_text = substitute(line_text, '\(\&lt;\w\+\(-\w\+\)*\&gt;\)', "'&amp;'", 'g')
      let line_text = substitute(line_text, '\s\+', ', ', 'g')
      let line_text = substitute(line_text, ',\s*,', ',', 'g')
    endif
    " Update the line in the buffer
    call setline(line_num, line_text)
  endfor
endfunction
" Mapping to call the function above:
vnoremap &lt;leader&gt;s :call SurroundWordsWithQuotesAndCommas()&lt;CR&gt;
"
" Function to clean Hard of Hearing subtitles to be regular subtitles.
" Removes everything inside square brackets (and the brackets).
" Removes any orphaned non-alphabetical non-numeric characters.
" Removes {\an#} tags (which trip up some video apps).
" Reduces consecutive empty lines to a single empty line.
function! CleanUpSubtitles()
    silent! execute '%s/\[.*\]\s*//g'
    silent! execute '%s/^[^a-zA-Z0-9]*$//g'
    silent! execute '%s/{\\an\d}//g'
    silent! execute '%s!\n\n\n\+!\r\r!g'
endfunction
" Mapping CleanUpSubtitles() to
nnoremap &lt;leader&gt;h :call CleanUpSubtitles()&lt;CR&gt;
"
" Function to add a suffix to open files (buffers) and write.
function! AppendToFileNames()
    let suffix = input("Enter suffix to append: ")
    bufdo execute "file " . expand('%:p:r') . suffix . "." . expand('%:e') | w
endfunction
" Mapping to call the function above:
nnoremap &lt;leader&gt;f :call AppendToFileNames()&lt;CR&gt;

" }}}

" Vimscript Folding Settings ------------------------------------------------{{{

"set foldmethod=indent "Set explicitly below for Python files
"set foldmethod=manual "Set explicitly below for Vimrc file
"set foldmethod=marker "Set explicitly below for Python files
"set foldmethod=syntax
"
" Displays the folding status to the left of the number column
set foldcolumn=2
"
" Set folds to only be one level deep (not nested)
set foldnestmax=2
" set fnm=2
"
" This should make fresh files open without closed folds
" (unless the restore folding status overrides the file).
"set foldlevelstart=99
"
" Save and restore folding status in a file:
augroup save_folds
    autocmd!
    autocmd BufWinLeave *.* silent! mkview
    autocmd BufWinEnter *.* silent! loadview
augroup END
"
" Set .vimrc to use 'marker' folds by default
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
"
" Set python files to use 'indent' folds by default
augroup filetype_python
    autocmd!
    autocmd FileType python setlocal foldmethod=indent
augroup END
"
" Set markdown files to use 'manual' folds by default
augroup filetype_markdown
    autocmd!
    autocmd FileType markdown setlocal foldmethod=manual
augroup END
"

"}}}

" Vimscript Swap Backup and Undo Setting ------------------------------------{{{

"
" Backup Settings Block:
" ----------------------
" Ensure backups are created and stored in designated directories.
" - Creates the ~/.vim/backup directory if it doesn't exist.
" - Prioritizes local .vim-backup/ directory for project-specific backups.
" - Falls back to ~/.vim/backup for centralized backups.
" - Prevents clutter by avoiding backups in the working directory or home folder.
if isdirectory($HOME . '/.vim/backup') == 0
    :silent !mkdir -p ~/.vim/backup &gt;/dev/null 2&gt;&amp;1
endif
if isdirectory($HOME . '/.vim/backup')
    set backupdir+=.
    set backupdir-=~/
    set backupdir^=~/.vim/backup/
    set backupdir^=./.vim-backup/
    set backup
    set backupext=.bak " set backup file extension to .bak
endif
"
"
" Writebackup Settings Block:
" ----------------------------
" Configures writebackup to temporarily save the original file in the same directory
" during write operations. Ensures safety against data loss during save failures.
if exists("+writebackup")
    set writebackup
endif
"
" Swap File Settings Block:
" --------------------------
" Configures directories for storing swap files, which help recover unsaved changes
" in the event of a crash or unexpected shutdown.
" - Creates ~/.vim/swap if it doesn't exist.
" - Uses .vim-swap/ for project-specific swap files if present in the working directory.
" - Falls back to ~/.vim/swap for centralized swap storage.
" - Includes ~/tmp/ and current directory as additional options for compatibility.
" Ensure the swap directory exists
if isdirectory($HOME . '/.vim/swap') == 0
    :silent !mkdir -p ~/.vim/swap &gt;/dev/null 2&gt;&amp;1
endif
if isdirectory($HOME . '/.vim/swap')
    set directory=./.vim-swap//
    set directory+=~/.vim/swap//
    set directory+=~/tmp//
    set directory+=.
    set swapfile
endif
"
" Viminfo Settings Block:
" ------------------------
" Enables Viminfo to store the state of your previous editing session, including:
" - Marks, command history, search history, registers, and more.
" - Saves the session state to project-specific .vim-viminfo/ if available.
" - Falls back to ~/.vim/viminfo for global session storage.
" - The n flag specifies the file where Viminfo data should be stored.
"
" Ensure the Viminfo directory exists
if isdirectory($HOME . '/.vim') == 0
    :silent !mkdir -p ~/.vim &gt;/dev/null 2&gt;&amp;1
endif
" Set Viminfo file locations
if isdirectory($HOME . '/.vim')
    " Project specific relative path (optional)
    set viminfo+=n./.vim-viminfo/viminfo
    " Global path
    set viminfo+=n~/.vim/viminfo
endif
"
" Settings:
" Retain marks for last 100 file.
" Limit command history to last 100.
" Save search patterns for last 50 patterns.
" Keep file marks (cursor positions).
" Retain registers.
set viminfo='100,&lt;100,s50,h,r
"
"
" Persistent Undo Settings Block:
" -------------------------------
" Enables undo history to persist across Vim sessions.
" - Creates the ~/.vim/undo directory if it doesn't exist.
" - Stores undo files in .vim-undo/ for local project-specific history.
" - Falls back to ~/.vim/undo for global undo history.
" - Requires Vim 7.3+ with undofile feature for persistent undo functionality.
if exists("+undofile")
    " Ensure the undo directory exists
    if isdirectory($HOME . '/.vim/undo') == 0
        :silent !mkdir -p ~/.vim/undo &gt; /dev/null 2&gt;&amp;1
    endif
    " Set undo directory paths and enable persistent undo
    if isdirectory($HOME . '/.vim/undo')
        set undodir=./.vim-undo//
        set undodir+=~/.vim/undo//
        set undofile
    endif
endif
"
" Set undo levels:
set undolevels=1000
"

"}}}

" Vimscript Faster Navigation -----------------------------------------------{{{

" Faster up and down movement bindings.
" https://gist.github.com/VernonGrant/2fc3c81191f2ff9bbe97c158da45ae5c
" Control-&lt;direction&gt; to move 5 lines at a time. (Not great on MacOS)
" 250114 - new discovery: this block of mappings was causing my macros to move
" +5 lines down after each run of the macro. Weird. That's which it precludes
" MacOS by the conditional. (NOTE: Untested on Linux &amp; Windows.)
if !has("mac")
    inoremap &lt;C-k&gt; &lt;esc&gt;:-5&lt;CR&gt; i
    nnoremap &lt;C-j&gt; :+5&lt;CR&gt;
    inoremap &lt;C-j&gt; &lt;esc&gt;:+5&lt;CR&gt; i
    nnoremap &lt;C-up&gt; :-5&lt;CR&gt;
    inoremap &lt;C-up&gt; &lt;esc&gt;:-5&lt;CR&gt; i
    nnoremap &lt;C-down&gt; :+5&lt;CR&gt;
    inoremap &lt;C-down&gt; &lt;esc&gt;:+5&lt;CR&gt; i
endif
"
" This is not a Vimrc setting - it's advice for the shell in MacOS:
" Shell settings for the MacOS Terminal:
" Run the following commands in your terminal (Mac OS) to increase the key
" repeat rate.
" Normal minimum is 15 (225 ms)
"defaults write -g InitialKeyRepeat -int 10
" Normal minimum is 2 (30 ms)
"defaults write -g KeyRepeat -int 1
"
" This next tip had the greatest effect on MacOS (the Delay Until Repeat setting):
"https://stackoverflow.com/questions/23078078/speed-up-vim-cursor-moving-through-j-k
" The problem might be the difference in your keyboard settings instead of Vim.
" Try changing the Key Repeat setting in OS X keyboard settings and see what
" happens. On my MacBook this setting affects the cursor movement speed when
" holding h, j, k or l.
" As mentioned in comments some software such as KeyRemap4Macbook can override
" the system settings. Also consider using commands ^U, ^D and G instead of
" hjkl when navigating around longer files.

" }}}

" Vimscript Syntax &amp; File Templates -----------------------------------------{{{

"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILE templates
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Imports templates stored in .vim/templates based on file extensions
au BufNewFile * silent! 0r ~/.vim/templates/%:e.tpl
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILE template - end
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
" Add syntax highlighting to my alias file (by name)
augroup syntax_robsaliases
    autocmd!
    autocmd VimEnter .robsaliases set filetype=conf
augroup END
"
" Add syntax highlighting for USD files
" https://github.com/superfunc/usda-syntax
augroup syntax_usd
    au BufRead,BufNewFile *.usd set filetype=usda
    au BufRead,BufNewFile *.usda set filetype=usda
    autocmd FileType usda source ~/.vim/syntax/usda.vim
    autocmd FileType usda colorscheme slate
augroup END
"
" Make qss (Qt) stylesheets use css syntax highlighting
augroup syntax_qss
    autocmd!
    " Associate filetype ".qss" with CSS mode.
    autocmd BufNewFile,BufRead *.qss set filetype=css
augroup END
"
" To bypass an error with setting filetype for HTML - using silent to suppress:
augroup html_ft
  au!
  autocmd BufNewFile,BufRead *.html silent! set filetype=html
augroup END
"
"""""""""
" PYTHON:
"""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" config for python tabs and syntax
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" configure expanding of tabs for various file types
au BufRead,BufNewFile *.py set expandtab
au BufRead,BufNewFile *.c set noexpandtab
au BufRead,BufNewFile *.h set noexpandtab
au BufRead,BufNewFile Makefile* set noexpandtab
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" config for python tabs and syntax - end
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
" Comment current line (in python file)
au FileType python nnoremap &lt;buffer&gt; &lt;leader&gt;c I#&lt;esc&gt;
"
" Remove Trailing Whitespace (with Python filetype)
" Autocommand to remove trailing whitespace in Python files
" (The /e at the end of the substitution suppresses errors):
augroup python_save
    autocmd!
    autocmd BufWrite *.py %s/\s\+$//e
augroup END
"
" }}}

" Vimscript Netrw -----------------------------------------------------------{{{

" :Lex messes with netrw_chgwin, and so this is to reset at each invocation
" of netrw:
autocmd FileType netrw let g:netrw_chgwin = -1
"
" Switch off the top banner.
" (Interactively, you can bring it back temporarily with '&lt;shift&gt; i'.
let g:netrw_banner = 0
"
" Set list view style:
" (Interactively, switch between the views with 'i'.
let g:netrw_liststyle = 3
"Here are the possible options:
" 0: A detailed listing (default view), showing file sizes, modification times, and permissions.
" 1: A simple, one-column list of filenames.
" 2: A two-column list of filenames.
" 3: A tree-style view, showing directories and their contents hierarchically.
" 4: Another tree-style view, but only displays the directory structure without the files."
"
" Opening files:
" Open in same window (default behavior)
"let g:netrw_browse_split = 0
" Open in Horizontal split
"let g:netrw_browse_split = 1
" Open in Vertical split
"let g:netrw_browse_split = 2
" Open in new tab
"let g:netrw_browse_split = 3
" Open in previous window
let g:netrw_browse_split = 4
"
" Set percentage of window space used for netrw.
" (25 is 25% of the window space.)
let g:netrw_winsize = 25
"
" Set netrw to always create a new vertical split
":let g:netrw_altv = 1
"
" netrw keeps the working directory unchanged when you navigate through directories.
" However, with g:netrw_keepdir set to 0, netrw will update the working directory to
" match the directory you are currently browsing in the file explorer.
let g:netrw_keepdir = 0
"
" Checks if there is a file open after Vim starts up,
" and if not, open the current working directory in Netrw.
" augroup InitNetrw
"   autocmd!
"   autocmd VimEnter * if expand("%") == "" | edit . | endif
" augroup END
"
" Combine :Ex with Vsplit to mimic running :Le (without messing up chgwin)
" Use &lt;leader&gt;e (&lt;space&gt;e) to open netrw to the left of the original
" buffer window.
" Map &lt;leader&gt;e to open Netrw in a vertical split at 30% width
nnoremap &lt;leader&gt;e :leftabove vsplit \| :vertical resize 30% \| :Explore&lt;CR&gt;
"
" Use the &lt;enter&gt; key to open the file under the cursor into the
" window/buffer of next to netrw (if using the shortcut above).
autocmd FileType netrw nnoremap &lt;buffer&gt; o &lt;Cmd&gt;call netrw#BrowseX(expand("&lt;cfile&gt;"), 0)&lt;CR&gt;
"

" }}}

" Vimscript Split Pane Tools ------------------------------------------------{{{

"--------------------- Split pane tools ----------------------------------------
"
" vimrc for opening a new buffer below and right
"set splitbelow splitright

" vimrc for navigating between panes
nnoremap &lt;C-h&gt; &lt;C-w&gt;h
nnoremap &lt;C-j&gt; &lt;C-w&gt;j
nnoremap &lt;C-k&gt; &lt;C-w&gt;k
nnoremap &lt;C-l&gt; &lt;C-w&gt;l

" vimrc for adjusting pane sizes (No good on macOS and Desktops)
if !has("mac")
    noremap &lt;silent&gt; &lt;C=Left&gt; :vertical resize +3&lt;CR&gt;
    noremap &lt;silent&gt; &lt;C=Right&gt; :vertical resize -3&lt;CR&gt;
    noremap &lt;silent&gt; &lt;C-Up&gt; :resize +3&lt;CR&gt;
    noremap &lt;silent&gt; &lt;C-Down&gt; :resize -3&lt;CR&gt;
endif
"
" vimrc Change 2 split windows from vertical to horizontal or horizontal to vertical
" Change horizontal split to vertical split
map &lt;leader&gt;tk &lt;C-w&gt;t&lt;C-w&gt;H
" Change vertical split to horizontal split
map &lt;leader&gt;th &lt;C-w&gt;t&lt;C-w&gt;K

" Removes pipes | that act as separators on splits (escape space):
set fillchars+=vert:\ " Notice the space AFTER the '\' ('\' escapes the space).
"------------------- End of Split pane tools -----------------------------------
"
" }}}

" Vimscript 'vim-plug' &amp; Plugins --------------------------------------------{{{

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-plug : start
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-plug : The 'if block' below auto installs vim-plug plugin manager if not
" present:
" see - https://github.com/junegunn/vim-plug/wiki/tips#automatic-installation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-plug: between the 'call plug#begin' &amp; 'call plug#end', we can add plugins
" https://github.com/junegunn/vim-plug
" (added "plugged" dir in home, here: ~/.vim/plugged)
"PlugInstall # install plugins (restart vim before running)
"PlugUpdate # update the installed plugins
"PlugClean # remove commented out plugins
"PlugUpgrade # upgrade vim-plug
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
call plug#begin('~/.vim/plugged')
"" add plugins below """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
"" Comfortable-Motion
"" https://github.com/yuttie/comfortable-motion.vim
"" settings are applied further down in the vimrc
"" &lt;Ctrl-d&gt; &lt;Ctrl-u&gt;
"" NOT WORKING ON LINUX
"Plug 'yuttie/comfortable-motion.vim'
"
"" Cool banner across base of window:
" Install fonts and stuff too if not present.
" (See Airline Font Helpers section later in the vimrc.)
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
"
" Polyglot causing issues with shell scripts:
"Plug 'sheerun/vim-polyglot'
"" polyglot override to disable trailing whitespace error highlighting:
"let g:python_highlight_space_errors = 0
"" polyglot changes commas to pipes - this will override that behavior
"let g:csv_no_conceal = 1
"
"" Surround - for surrounding text with ("{' &lt;tags&gt; or anything!
Plug 'http://github.com/tpope/vim-surround' " Surrounding ysw)
" Custom surround back-tick shortcut
nmap &lt;leader&gt;` ysiw`
"nnoremap &lt;leader&gt;` :normal ysiw`&lt;CR&gt; "Non recursive method
"
"" Commentary - for adding " Comment gc[motion]
Plug 'tpope/vim-commentary'
"" Adding '//' for cpp (c++) comments; since I was getting %% (?).
autocmd FileType c,cpp,java setlocal commentstring=//\ %s
"
"" Git integration
" https://github.com/tpope/vim-fugitive
Plug 'tpope/vim-fugitive'
"
"" Compile and run C++/Python (and more) single source files.
"" https://www.vim.org/scripts/script.php?script_id=3115
Plug 'xuhdev/SingleCompile'
nmap &lt;F9&gt; :SCCompile&lt;cr&gt;
nmap &lt;F10&gt; :SCCompileRun&lt;cr&gt;
"
"
"------------------------------- Vimwiki Start --------------------------------"
" Vimwiki:
"" Vimwiki prerequisites
"set nocompatible "Not needed? It resets defaults of some Vimrc settings
filetype plugin on
syntax on
"" Vimwiki
Plug 'vimwiki/vimwiki'
"
" Glyphs for chechboxes:
let g:vimwiki_listsyms = '✗○◐●✓'
"
"" setup for multiple wikis:
let wiki_1 = {}
let wiki_1.path = '~/vimwiki_dir/general/'
let wiki_1.path_html = '~/vimwiki_dir/general_html/'
"
let wiki_2 = {}
let wiki_2.path = '~/vimwiki_dir/alt/'
let wiki_2.path_html = '~/vimwiki_dir/alt_html/'
"
let g:vimwiki_list = [wiki_1, wiki_2]
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" The following didn't work for me (colored syntax in html).
""https://github.com/vimwiki/vimwiki/issues/1311
"" Vimwiki: HTML with color syntax highlighting
"" Needs 'pygmentize' installed to work
"" on OSX:
"" pip3 install pygments
"" export PATH=/Users/&lt;username&gt;/Library/Python/3.9/bin:$PATH
""
" let g:vimwiki_automatic_nested_syntaxes = 1
" let g:vimwiki_listing_hl = 1
""let g:vimwiki_listing_hl_command = 'pygmentize -g -v -f html -O style=colorful -O noclasses=True'
""let g:vimwiki_listing_hl_command = 'pygmentize -O style=colorful -O noclasses=True'
""let g:vimwiki_listing_hl_command = 'pygmentize -f html -O style=default -O noclasses=True'
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Also see the Vimwiki GitHub Pull and Push section later in the Vimrc
"-------------------------------- Vimwiki End ---------------------------------"
"
Plug 'mattn/calendar-vim'
"
" Vim_SRT_Sync:
" USAGE: for adjusting SRT time stamps:
":ShiftSrt &lt;time shift&gt;
" Examples:
":ShiftSrt 750
":ShiftSrt 3s
":ShiftSrt -2m 25s
" https://github.com/ggandor/vim-srt-sync
Plug 'ggandor/vim-srt-sync', {'branch': 'main'}
"
" VIM_Speeddating:
" vim-speeddating (for incrementing and decrementing dates and times)
"https://github.com/tpope/vim-speeddating
Plug 'tpope/vim-speeddating'
"
" Python_Syntax:
"" More thorough python syntax highlighting
"" https://github.com/vim-python/python-syntax
Plug 'vim-python/python-syntax'
"" All on:
let g:python_highlight_all = 1
"" All off:
"let g:python_highlight_all = 0
let g:python_highlight_space_errors = 0
let g:python_highlight_func_calls = 1
"
"
"------------------------ Color Scheme Plugins - Start ------------------------"
"VimScript plugin for Vim8 or later - makes it easy to develop color schemes.
" https://github.com/lifepillar/vim-colortemplate
" :help colortemplate.txt
Plug 'lifepillar/vim-colortemplate'
"
"ALLOMANCER
Plug 'Nequo/vim-allomancer'
"https://github.com/Nequo/vim-allomancer
"
"EVERGREEN
Plug 'sainnhe/everforest'
"
"GITHUB
"https://github.com/cormacrelf/vim-colors-github
Plug 'cormacrelf/vim-colors-github'
"
"NORD VIM
"https://github.com/arcticicestudio/nord-vim
Plug 'arcticicestudio/nord-vim'
"
"POOLSIDE
"https://github.com/sabrinagannon/vim-poolside
"Plug 'sabrinagannon/vim-poolside'
Plug 'sabrinagannon/vim-poolside', { 'branch': 'release' }
"
"Plug 'dracula/vim', { 'as': 'dracula' }
"Plug 'doums/darcula Smooth scrolling:
"
"Iceberg
"https://github.com/cocopon/iceberg.vim/
Plug 'cocopon/iceberg.vim'
"
"Wombat256grf
"https://github.com/gryf/wombat256grf
Plug 'gryf/wombat256grf'
"------------------------- Color Scheme Plugins - End -------------------------"
"
"" Initialize plugin system
call plug#end()
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-plug : end
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" }}}

" Vimscript Colors and Schemes ----------------------------------------------{{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Color and Schemes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" notermguicolors prevents the terminal colorscheme overriding the
" vim colorscheme
"set notermguicolors
"set termguicolors

"if &amp;term =~ '256color'
"    set t_ut=
"endif

"set t_Co=256
set background=dark

" Colorscheme fix for Vimwiki (for some colorschemes)
" From Copilot: This effectively cures Vimwiki highlighting on VimwikiLinks
" and VimwikiDelimiters:
autocmd ColorScheme * highlight Conceal guifg=NONE guibg=NONE guisp=NONE gui=NONE cterm=NONE
autocmd FileType vimwiki highlight Conceal guifg=NONE guibg=NONE guisp=NONE gui=NONE cterm=NONE
"
"EVERFOREST COLORS
"https://github.com/sainnhe/everforest
"Airline; Enable airline theme in airline section (this is set by Vimrc now).
"colorscheme everforest
"let g:everforest_better_performance = 1
"Options are: soft, medium, hard
"let g:everforest_background = 'soft'

"GITHUB COLORS
"https://github.com/cormacrelf/vim-colors-github
"Airline; Enable airline theme in airline section (this is set by Vimrc now).
" Uncomment the next three lines to activate:
"colorscheme github
let g:github_colors_soft = 1
let g:github_colors_block_diffmark = 0
"
"NORD VIM
"https://github.com/arcticicestudio/nord-vim
"Airline; Disable other airline themes to inherit nord scheme
"colorscheme nord
"
"POOLSIDE COLORS
"colorscheme poolside
"enable italicized comments
"let g:poolside_terminal_italics=1
"
" "" Attempt to show comments as italics
"" Only works if the colorscheme is using font with italics
highlight Comment cterm=italic gui=italic

"" from https://github.com/morhetz/gruvbox/wiki/Terminal-specific
"Use 24-bit (true-color) mode in Vim/Neovim when outside tmux.
"If you're using tmux version 2.2 or later, you can remove the outermost
" $TMUX check and use tmux's 24-bit color support
"http://sunaku.github.io/tmux-24bit-color.html#usage for more information.
if (empty($TMUX))
  if (has("nvim"))
    "For Neovim 0.1.3 and 0.1.4 &lt; https://github.com/neovim/neovim/pull/2198 &gt;
    let $NVIM_TUI_ENABLE_TRUE_COLOR=1
  endif
  "For Neovim &gt; 0.1.5 and Vim &gt; patch 7.4.1799 &lt; https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 &gt;
  "Based on Vim patch 7.4.1770 (`guicolors` option) &lt; https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd &gt;
  " &lt; https://github.com/neovim/neovim/wiki/Following-HEAD#20160511 &gt;
  if (has("termguicolors"))
    set termguicolors
  endif
endif

" Hack to use regular colorscheme if in shell
if has("gui_running")
else
    colo slate
endif
"
" SCHEMES AVAILABLE:
"
"DEFAULT COLORS
"
"colorscheme blue
"colorscheme darkblue
"colorscheme default
"colorscheme delek
"colorscheme desert
"colorscheme elford
"colorscheme evening
"colorscheme koehler
"colorscheme morning
"colorscheme murphy
"colorscheme pablo
"colorscheme peachpuff
"colorscheme ron
"colorscheme shine
"colorscheme slate
"colorscheme torte
"colorscheme zellner
"
"CUSTOM COLORS
"
"" https://github.com/AlessandroYorba/Alduin/blob/master/colors/alduin.vim
"colorscheme alduin
"colorscheme allomancer
"" https://github.com/sainnhe/archived-colors/blob/master/colors/atlantis.vim
"colorscheme atlantis
"" https://github.com/sainnhe/archived-colors/blob/master/colors/cryslominsa.vim
"colorscheme cryslominsa
"colorscheme fogbell "fogbell_light | fogbell_lite
"colorscheme github
"
" This sets one colorscheme when using MVim and another for regular shell vim:
if has("gui_running")
    colorscheme atlantis
else
    colorscheme alduin
endif
"

"---------------------- Call Random Colorscheme - Start -----------------------"
" CALL RANDOM COLORSCHEME
" Define a list of favorite colorschemes. You can generate a list of
" available colorschemes like this:
":let @a = join(getcompletion('', 'color'), ', ')
" then block select the first char of the vertical list (&lt;ctrl&gt;v &lt;motion&gt;)
" then '$' then 'A, &lt;esc&gt;'
let g:colorschemes = ['alduin', 'allomancer', 'atlantis', 'blue', 'cryslominsa',
            \ 'darkblue', 'default', 'delek', 'desert', 'desert-night',
            \ 'elflord', 'evening', 'everforest', 'fairy-garden', 'fogbell',
            \ 'fogbell_light', 'fogbell_lite', 'github', 'grimoire', 'habamax',
            \ 'ice-age', 'iceberg', 'industry', 'koehler', 'lost-shrine',
            \ 'lunaperche', 'macvim', 'metalheart', 'morning', 'murphy', 'nord',
            \ 'pablo', 'peachpuff', 'plastic', 'poolside', 'pythonista',
            \ 'quiet', 'retrobox', 'ron', 'september', 'shine', 'slate',
            \ 'sorbet', 'torte', 'unokai', 'vanilla-cake', 'vimcolor_pintovim',
            \ 'wildcharm', 'wombat256grf', 'zaibatsu', 'zellner']
" Function to randomly select a colorscheme
function! RandomColorscheme()
    let g:random_index = rand() % len(g:colorschemes)
    let g:random_colorscheme = g:colorschemes[g:random_index]
    try
        execute 'colorscheme ' . g:random_colorscheme
        set background=dark
        redraw | echom "Random colorscheme loaded: " . g:random_colorscheme
    catch
        colorscheme atlantis
        redraw | echom "Failed to load colorscheme (" . g:random_colorscheme . "). Reverted to default."
    endtry
endfunction
"
" Create a command for random colorscheme selection
command! RandomColorscheme call RandomColorscheme()
" Map the RandomColorscheme function to a key, for example, &lt;leader&gt;r
nnoremap &lt;leader&gt;r :call RandomColorscheme()&lt;CR&gt;
"----------------------- Call Random Colorscheme - End ------------------------"
"

" }}}

" Vimscript Airline Font Helpers --------------------------------------------{{{

"-------------------  Airline Font helpers  start -----------------------------"
" https://vi.stackexchange.com/questions/3359/how-do-i-fix-the-status-bar-symbols-in-the-airline-plugin
" And for font installs:
"https://vi.stackexchange.com/questions/3359/how-do-i-fimx-the-status-bar-symbols-in-the-airline-plugin
"" To add the correct patched fonts:
"" Install in terminal like so...
"git clone https://github.com/powerline/fonts.git --depth=1
"cd fonts
"./install.sh
"cd ..
"rm -rf fonts
"
let g:airline_powerline_fonts = 1
"
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
"
" unicode symbols
let g:airline_left_sep = '»'
let g:airline_left_sep = '▶'
let g:airline_right_sep = '«'
let g:airline_right_sep = '◀'
let g:airline_symbols.linenr = '␊'
let g:airline_symbols.linenr = '␤'
let g:airline_symbols.linenr = '¶'
let g:airline_symbols.branch = '⎇'
let g:airline_symbols.paste = 'ρ'
let g:airline_symbols.paste = 'Þ'
let g:airline_symbols.paste = '∥'
let g:airline_symbols.whitespace = 'Ξ'
"
" airline symbols
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = ''
"
"" Set up to set the powerline font for airline:
"" https://vi.stackexchange.com/questions/22313/settings-for-the-font-in-vimrc-are-not-working
"set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ 10
"" This is the same as the line above, but it only sets if using gui (GVim)
"" linespace adds spacing between lines.
if has("gui_running")
 if has("gui_gtk2")
  set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ 10
 elseif has("gui_macvim")
  set guifont=DejaVuSansMonoPowerline:h12
  set linespace=4
 endif
endif
"set guifont=DejaVuSansMonoPowerline:h14
"
"-------------------  Airline Font helpers  end -------------------------------"

" }}}

" Vimscript Airline Theme Settings ------------------------------------------{{{

"
"--------------------- AirlineTheme Manual Choice - Start ---------------------"
let g:airline_powerline_fonts = 1
let g:airline_theme='base16'
"let g:airline_theme='zenburn'
"let g:airline_theme='luna'
"let g:airline_solarized_bg='dark'
"let g:airline_theme='bubblegum'
"let g:airline_theme='github'
"let g:airline_theme='everforest'
"---------------------- AirlineTheme Manual Choice - End ----------------------"
"
"------------------------ Random Airlinetheme - Start -------------------------"
let g:airlinethemes = ['dark', 'alduin', 'angr', 'apprentice', 'atomic',
            \ 'ayu_dark', 'ayu_light', 'ayu_mirage', 'badwolf', 'base16',
            \ 'base16color', 'base16_3024', 'base16_adwaita', 'base16_apathy',
            \ 'base16_ashes', 'base16_atelierdune', 'base16_atelierforest',
            \ 'base16_atelierheath', 'base16_atelierlakeside',
            \ 'base16_atelierseaside', 'base16_atelier_cave',
            \ 'base16_atelier_cave_light', 'base16_atelier_dune',
            \ 'base16_atelier_dune_light', 'base16_atelier_estuary',
            \ 'base16_atelier_estuary_light', 'base16_atelier_forest',
            \ 'base16_atelier_forest_light', 'base16_atelier_heath',
            \ 'base16_atelier_heath_light', 'base16_atelier_lakeside',
            \ 'base16_atelier_lakeside_light', 'base16_atelier_plateau',
            \ 'base16_atelier_plateau_light', 'base16_atelier_savanna',
            \ 'base16_atelier_savanna_light', 'base16_atelier_seaside',
            \ 'base16_atelier_seaside_light', 'base16_atelier_sulphurpool',
            \ 'base16_atelier_sulphurpool_light', 'base16_atlas',
            \ 'base16_bespin', 'base16_black_metal',
            \ 'base16_black_metal_bathory', 'base16_black_metal_burzum',
            \ 'base16_black_metal_dark_funeral', 'base16_black_metal_gorgoroth',
            \ 'base16_black_metal_immortal', 'base16_black_metal_khold',
            \ 'base16_black_metal_marduk', 'base16_black_metal_mayhem',
            \ 'base16_black_metal_nile', 'base16_black_metal_venom',
            \ 'base16_brewer', 'base16_bright', 'base16_brogrammer',
            \ 'base16_brushtrees', 'base16_brushtrees_dark', 'base16_chalk',
            \ 'base16_circus', 'base16_classic', 'base16_classic_dark',
            \ 'base16_classic_light', 'base16_codeschool', 'base16_colors',
            \ 'base16_cupcake', 'base16_cupertino', 'base16_darktooth',
            \ 'base16_decaf', 'base16_default', 'base16_default_dark',
            \ 'base16_default_light', 'base16_dracula', 'base16_edge_dark',
            \ 'base16_edge_light', 'base16_eighties', 'base16_embers',
            \ 'base16_espresso', 'base16_flat', 'base16_framer',
            \ 'base16_fruit_soda', 'base16_gigavolt', 'base16_github',
            \ 'base16_google', 'base16_google_dark', 'base16_google_light',
            \ 'base16_grayscale', 'base16_grayscale_dark',
            \ 'base16_grayscale_light', 'base16_greenscreen',
            \ 'base16_gruvbox_dark_hard', 'base16_gruvbox_dark_medium',
            \ 'base16_gruvbox_dark_pale', 'base16_gruvbox_dark_soft',
            \ 'base16_gruvbox_light_hard', 'base16_gruvbox_light_medium',
            \ 'base16_gruvbox_light_soft', 'base16_harmonic16',
            \ 'base16_harmonic_dark', 'base16_harmonic_light', 'base16_heetch',
            \ 'base16_heetch_light', 'base16_helios', 'base16_hopscotch',
            \ 'base16_horizon_dark', 'base16_horizon_light',
            \ 'base16_horizon_terminal_dark', 'base16_horizon_terminal_light',
            \ 'base16_ia_dark', 'base16_ia_light', 'base16_icy',
            \ 'base16_irblack', 'base16_isotope', 'base16_londontube',
            \ 'base16_macintosh', 'base16_marrakesh', 'base16_materia',
            \ 'base16_material', 'base16_material_darker',
            \ 'base16_material_lighter', 'base16_material_palenight',
            \ 'base16_material_vivid', 'base16_mellow_purple',
            \ 'base16_mexico_light', 'base16_mocha', 'base16_monokai',
            \ 'base16_nord', 'base16_nova', 'base16_ocean',
            \ 'base16_oceanicnext', 'base16_onedark', 'base16_one_light',
            \ 'base16_outrun_dark', 'base16_papercolor_dark',
            \ 'base16_papercolor_light', 'base16_paraiso', 'base16_phd',
            \ 'base16_pico', 'base16_pop', 'base16_porple', 'base16_railscasts',
            \ 'base16_rebecca', 'base16_sandcastle', 'base16_seti',
            \ 'base16_shapeshifter', 'base16_shell', 'base16_snazzy',
            \ 'base16_solarflare', 'base16_solarized', 'base16_solarized_dark',
            \ 'base16_solarized_light', 'base16_spacemacs',
            \ 'base16_summerfruit', 'base16_summerfruit_dark',
            \ 'base16_summerfruit_light', 'base16_synth_midnight_dark',
            \ 'base16_tomorrow', 'base16_tomorrow_night',
            \ 'base16_tomorrow_night_eighties', 'base16_tube',
            \ 'base16_twilight', 'base16_unikitty_dark',
            \ 'base16_unikitty_light', 'base16_vim', 'base16_woodland',
            \ 'base16_xcode_dusk', 'base16_zenburn', 'behelit', 'biogoo',
            \ 'blood_red', 'bubblegum', 'cobalt2', 'cool', 'cyberpunk',
            \ 'dark_minimal', 'desertink', 'deus', 'distinguished', 'durant',
            \ 'fairyfloss', 'fruit_punch', 'google_dark', 'google_light',
            \ 'hybrid', 'hybridline', 'jellybeans', 'jet', 'kalisi', 'kolor',
            \ 'laederon', 'lessnoise', 'light', 'lighthaus', 'lucius', 'luna',
            \ 'minimalist', 'molokai', 'monochrome', 'murmur', 'night_owl',
            \ 'nord_minimal', 'onedark', 'ouo', 'owo', 'papercolor', 'peaksea',
            \ 'powerlineish', 'qwq', 'raven', 'ravenpower', 'seagull',
            \ 'selenized', 'selenized_bw', 'seoul256', 'serene', 'sierra',
            \ 'silver', 'simple', 'soda', 'sol', 'solarized', 'solarized_flood',
            \ 'supernova', 'term', 'term_light', 'tomorrow', 'transparent',
            \ 'ubaryd', 'understated', 'violet', 'wombat', 'xtermlight',
            \ 'zenburn', 'everforest', 'github', 'nord', 'iceberg']
" Function to randomly select an AirlineTheme
function! RandomAirlineThemes()
    let g:random_index = rand() % len(g:airlinethemes)
    let g:random_airlinetheme= g:airlinethemes[g:random_index]
    try
        execute 'AirlineTheme ' . g:random_airlinetheme
        set background=dark
        redraw | echom "Random AirlineTheme loaded: " . g:random_airlinetheme
    catch
        AirlineTheme base16
        redraw | echom "Failed to load AirlineTheme (" . g:random_airlinetheme . "). Reverted to default."
    endtry
endfunction
"
" Create a command for random colorscheme selection
command! RandomAirlineThemes call RandomAirlineThemes()
" Map the RandomAirlinethemes function to a key, for example, &lt;leader&gt;a
nnoremap &lt;leader&gt;a :call RandomAirlineThemes()&lt;CR&gt;
"------------------------- Random AirlineTheme - End --------------------------"
"
"----------------- Match Airline Theme To Colorscheme - Start -----------------"
let g:color_airline_map = {
            \ 'default': 'base16', 'alduin': 'alduin',
            \ 'everforest': 'everforest', 'github': 'github',
            \ 'iceberg': 'iceberg', 'nord': 'nord',
            \ 'wombat256grf': 'wombat'
            \ }
"
" Autocommand to detect colorscheme changes and set Airline theme
"autocmd ColorScheme * call UpdateAirlineTheme()
autocmd VimEnter * autocmd ColorScheme * call UpdateAirlineTheme()
"
" Function to update the Airline theme dynamically
function! UpdateAirlineTheme()
    " Get the current colorscheme
    let current_colorscheme = g:colors_name
"
    " Check if the current colorscheme is in the dictionary
    if has_key(g:color_airline_map, current_colorscheme)
        " Set the corresponding Airline theme
        execute 'AirlineTheme ' . g:color_airline_map[current_colorscheme]
    else
        " Set a default Airline theme if no match is found
        execute 'AirlineTheme ' . g:color_airline_map['default']
    endif
endfunction
"------------------ Match Airline Theme To Colorscheme - End ------------------"

" }}}

" Vimscript Custom Abbreviations --------------------------------------------{{{
"
"---------------------- Abbrev -------------------------------"
" Script header:
inoreabbrev &lt;expr&gt; rrr strftime("#####################################################################################&lt;cr&gt;# Description:&lt;cr&gt;# &lt;cr&gt;# Created by noddy&lt;cr&gt;#&lt;cr&gt;&lt;cr&gt;&lt;cr&gt;__author__ = \"noddy\"&lt;cr&gt;__date__ = \"%y/%m/%d\"&lt;cr&gt;__version__ = \"0.0.1\"&lt;cr&gt;&lt;cr&gt;")
"
inoreabbrev &lt;expr&gt; ccc "##################################################&lt;cr&gt;#  COMMENT&lt;cr&gt;"
"
" 'if main' with 'ifmain'
inoreabbrev ifmain if __name__ == "__main__":
"
" Add python shebang line for python scripts with 'shebang'
inoreabbrev shebang #!/usr/bin/env python3
"
inoreabbrev &lt;expr&gt; thetime strftime("%c")
"
" For Vimwiki html:
cnoreabbrev www VimwikiAll2HTML
" for Mac:
cnoreabbrev gwww !mvwdeploy
cnoreabbrev mwww !mvwdeploy
" for Linux:
cnoreabbrev lwww !vwdeploy
" }}}

" Vimscript Vimwiki GitHub Pull ---------------------------------------------{{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"  VIMWIKI GITHUB PULL
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vimwiki settings to pull from github when opening the index file
augroup vimwiki_group
  autocmd!
  " On opening of general/index.wiki - git pull general and general_html files
  "au! BufRead ~/vimwiki_dir/general/index.wiki lcd ~/vimwiki_dir/general_html
  au BufRead ~/vimwiki_dir/general/index.wiki !git -C ~/vimwiki_dir/general_html pull
  "au BufRead ~/vimwiki_dir/general/index.wiki lcd ~/vimwiki_dir/general
  au BufRead ~/vimwiki_dir/general/index.wiki !git -C ~/vimwiki_dir/general pull
  "au! BufRead ~/vimwiki_dir/general/index.wiki lcd ~/vimwiki
  " Also do a git pull whenever home.md is opened
  "au BufRead ~/vimwiki_dir/general/index.wiki !git pull
  " After writing to any file in the wiki dir, add all files in the repo, commit
  " and push
  "au BufWritePost ~/vimwiki_dir/general/* !git -C ~/vimwiki_dir/general
  " add .;git -C ~/vimwiki_dir/general commit -m "auto commit `date`";git -C ~/vimwiki_dir/general push;
  "au BufWritePost ~/vimwiki_dir/general/* !git -C ~/vimwiki_dir/general_html add .;git -C ~/vimwiki_dir/general_html commit -m "auto commit `date`";git -C ~/vimwiki_dir/general_html push;
augroup END
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"  VIMWIKI GITHUB PULL - END
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" }}}

" Vimscript Run Python scripts ----------------------------------------------{{{
" Hotkey to run python scripts: F9
augroup runpython
  autocmd!
  autocmd FileType python nnoremap &lt;buffer&gt; &lt;F9&gt; :w&lt;CR&gt;:exec '!python3' shellescape(@%, 1)&lt;CR&gt;
  autocmd FileType python inoremap &lt;buffer&gt; &lt;F9&gt; &lt;esc&gt;:w&lt;CR&gt;:exec '!python3' shellescape(@%, 1)&lt;CR&gt;
augroup END
" }}}

" Vimscript Comfortable Motion ----------------------------------------------{{{

"------------------Comfortable Motion - Start ---------------------------------"
let g:comfortable_motion_interval = 100.0
let g:comfortable_motion_friction = 100.0
let g:comfortable_motion_air_drag = 1.0
"------------------Comfortable Motion - End -----------------------------------"

" }}}

" Vimscript Visual Linelimit Guide with Toggle ------------------------------{{{

"--------------- Linelimit and Line and Toggle Start---------------------------"
"https://gist.github.com/jphenow/4437248
"with default &lt;leader&gt; "\+k"
"let mapleader=","
nnoremap &lt;leader&gt;k :call&lt;SID&gt;EightyLine()&lt;cr&gt;
fun! s:EightyLine()
 if !exists('w:eightyline')
  let w:eightyline = 1
  :set colorcolumn=80  " highlight three columns after 'textwidth'
  :highlight ColorColumn ctermbg=16 guibg=#000000
 else
  unl w:eightyline
  :set colorcolumn=80  " highlight three columns after 'textwidth'
  :highlight ColorColumn NONE
 endif
endfunction
"------------------ Linelimit &amp; Toggle- End -----------------------------------"

" }}}

" Vimscript Tab Autocompletion Function -------------------------------------{{{

"-------------------------- TAB AUTOCOMPLETE - START --------------------------"
" Function to allow for tabbing to autocomplete a word based on the initial
" typed characters. Tab is just Tab if on empty line or start of line.
function! InsertTabWrapper()
    " Set variable 'col' equal to current column in current line (".") minus 1
    " (so that column 1 is zero, or false)
    let col = col(".") - 1
    " If col is zero, get character before the cursor, and check it's
    " whitespace (\k - keyword)
    if !col || getline(".")[col - 1] !~ '\k'
        " If whitespace (non-character) just add Tab:
        return "\&lt;tab&gt;"
    else
        " If NOT whitespace, map control-n to the tab key:
        return "\&lt;c-n&gt;"
endfunction
" Map the tab key to the function above:
inoremap &lt;tab&gt; &lt;c-r&gt;=InsertTabWrapper()&lt;cr&gt;
" Map shift-tab to control-p (to allow for reversing up a list of
" autocompletions):
inoremap &lt;s-tab&gt; &lt;c-p&gt;
"--------------------------- TAB AUTOCOMPLETE - END ---------------------------"

" }}}

" Vimscript Remember Position -----------------------------------------------{{{

"------------------- Remember position ---------------------
" To enable the saving and restoring of screen positions.
let g:screen_size_restore_pos = 1
"
" To save and restore screen for each Vim instance.
" This is useful if you routinely run more than one Vim instance.
" For all Vim to use the same settings, change this to 0.
let g:screen_size_by_vim_instance = 1"

if has("gui_running")
  function! ScreenFilename()
    if has('amiga')
      return "s:.vimsize"
    elseif has('win32')
      return $HOME.'\_vimsize'
    else
      return $HOME.'/.vimsize'
    endif
  endfunction
"
  function! ScreenRestore()
    " Restore window size (columns and lines) and position
    " from values stored in vimsize file.
    " Must set font first so columns and lines are based on font size.
    let f = ScreenFilename()
    if has("gui_running") &amp;&amp; g:screen_size_restore_pos &amp;&amp; filereadable(f)
      let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
      for line in readfile(f)
        let sizepos = split(line)
        if len(sizepos) == 5 &amp;&amp; sizepos[0] == vim_instance
          silent! execute "set columns=".sizepos[1]." lines=".sizepos[2]
          silent! execute "winpos ".sizepos[3]." ".sizepos[4]
          return
        endif
      endfor
    endif
  endfunction
"
  function! ScreenSave()
    " Save window size and position.
    if has("gui_running") &amp;&amp; g:screen_size_restore_pos
      let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
      let data = vim_instance . ' ' . &amp;columns . ' ' . &amp;lines . ' ' .
            \ (getwinposx()&lt;0?0:getwinposx()) . ' ' .
            \ (getwinposy()&lt;0?0:getwinposy())
      let f = ScreenFilename()
      if filereadable(f)
        let lines = readfile(f)
        call filter(lines, "v:val !~ '^" . vim_instance . "\\&gt;'")
        call add(lines, data)
      else
        let lines = [data]
      endif
      call writefile(lines, f)
    endif
  endfunction
"
  if !exists('g:screen_size_restore_pos')
    let g:screen_size_restore_pos = 1
  endif
  if !exists('g:screen_size_by_vim_instance')
    let g:screen_size_by_vim_instance = 1
  endif
  autocmd VimEnter * if g:screen_size_restore_pos == 1 | call ScreenRestore() | endif
  autocmd VimLeavePre * if g:screen_size_restore_pos == 1 | call ScreenSave() | endif
endif
"
"------------------- Remember position (End) ---------------------

" }}}

" Vimscript Create Named Folder Mark ----------------------------------------{{{

" Run by :Fold &lt;myTitle&gt; (&lt;enter&gt;)
" Example:
" :Fold My Lovely Fold
" yields:
" " My Lovely Fold -------------- etc -------[[[
" " ]]]
"
" Structured with square brackets to prevent fold happening on this comment!
" And added a new line to prevent the mark encapsulating the whole file:
" Note: foldmethod=marker defaults to recognizing {{{ to open and }}} to close.
" Remember to :set foldmethod=marker - already set in this vimrc with autocmd
" for 'vim'
"
function! FolderBanner(word)
    let b:width = 76
    let b:inserted_word = ' ' . a:word . ' '
    let b:word_width = strlen(b:inserted_word)
    let b:length = (b:width - b:word_width)
    let b:hashes = repeat('-', b:length)
    let b:start = '"'
    let b:finisha = '{{'
    let b:finishb = '{'
    let b:finish = b:finisha . b:finishb
    "let b:word_line = b:start . b:inserted_word . b:hashes . b:finish
    let b:enda = '" }}'
    let b:endb = '}'
    let b:end = b:enda . b:endb
    " Stating the string variables as a list allows for ',' to make a new line
    let b:word_line = [b:start . b:inserted_word . b:hashes . b:finish , b:end]
    :put =b:word_line
    ":put =b:end
endfunction
"
command! -nargs=1 Fold :call FolderBanner(&lt;q-args&gt;)
" :call FolderBanner("my header")
" Call the FolderBanner function with :Fold &lt;string&gt; &lt;string&gt; etc.

" }}}

" Vimscript Create Header(word) ---------------------------------------------{{{

" :call CreateHeader("my header")
function! CreateHeader(word)
    let b:width = 78
    let b:inserted_word = ' ' . a:word . ' '
    let b:word_width = strlen(b:inserted_word)
    let b:length_before = (b:width - b:word_width) / 2
    let b:hashes_before = repeat('-', b:length_before)
    let b:hashes_after = repeat('-', b:width - (b:word_width + b:length_before))
    let b:start = '#'
    let b:finish = '#'
    let b:word_line = b:start . b:hashes_before . b:inserted_word . b:hashes_after . b:finish
"
    :put =b:word_line
endfunction
"
command! -nargs=1 Header :call CreateHeader(&lt;q-args&gt;)

" }}}

" Vimscript Things To Add Last ----------------------------------------------{{{
"
" Syntax added AFTER polyglot to stop whitespace highlighting:
syntax on               " syntax highlighting
"
"" Adding showmds after plugins
set showcmd " Display (partial) commands in status line (right)
"
" Make comments italic
"https://rsapkf.xyz/weblog/enabling-italics-vim-tmuxi
highlight Comment cterm=italic
"
" Strategy to stop colorcolumn being set to 'on' when switching colorschemes:
autocmd ColorScheme * set colorcolumn=
"
" Strategy to keep bad spelling's visual highlighting quite plain (from Copilot)
augroup CustomSpellBad
  autocmd!
  autocmd ColorScheme * call SetSpellBad()
augroup END
"
function! SetSpellBad()
    highlight SpellBad gui=bold,italic guifg=NONE guibg=NONE guisp=NONE
endfunction
"
"
" }}}

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" END OF .VIMRC
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
</pre>



<p>
<br><br>
<a href="vim_learning.html">Vim Learning</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
