<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>blinkscript_fillcells_code</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="nuke_blinkscript_index.html">Nuke - Blinkscript</a>
</p>

<div id="BlinkScript - FillCells - My First BlinkScript"><h1 id="BlinkScript - FillCells - My First BlinkScript" class="header"><a href="#BlinkScript - FillCells - My First BlinkScript">BlinkScript - FillCells - My First BlinkScript</a></h1></div>

<p>
This BlinkScript takes in an Animation 'cell' (with inklines removed, revealing underlying flat cell colors) and fills the gaps where the inklines would be with surrounding colors.
</p>

<pre cpp>
// BlinkScript FillCells
//
//   - Robert Holder
//
// version 1.0.0 - 250807
//   - initial release.
// version 1.0.1 - 250807
//   - reduced MAX_UNIQUE_COLORS constant to 64;
//   - omit colors with a black alpha from color candidates.

kernel FillCellsKernel : ImageComputationKernel&lt;ePixelWise&gt;
{
  Image&lt;eRead, eAccessRanged2D, eEdgeClamped&gt; src;
  Image&lt;eWrite&gt; dst;
  
  param:
    //int spread;
    float spreadSlider;
  
  local:
    int spread;

  void define() {
    defineParam(spreadSlider, "Spread", 10.0f);
  }
  
  void init() {
      src.setRange(-spread, spread, -spread, spread);
  }
  
void process(int2 pos) {
    int spread = int(spreadSlider); //Cast slider to integer
    spread = max(1, spread); //Ensure minimum value is 1


    float4 output = 0;
    float alpha = src(0,0).w; // Get the alpha of the current pixel

    // Using a constant for array size, consider if this is always sufficient
    const int MAX_UNIQUE_COLORS = 64;
    float4 uniqueColors[MAX_UNIQUE_COLORS];
    int colorCounts[MAX_UNIQUE_COLORS];
    int numUniqueColors = 0;

    const float EPSILON = 0.001f; // For floating-point comparisons

    if (spread &gt; 0) {
        // Iterate through the neighborhood
        for(int Y = -spread; Y &lt;= spread; Y++) {
            for(int X = -spread; X &lt;= spread; X++) {

                // Only examine surrounding pixels IF the current pixel's alpha is 0
                if (fabs(alpha) &lt; EPSILON) { // Using epsilon for alpha check

                    // Access the pixel within the neighborhood at offset (X, Y)
                    float4 neighborhoodPixel = src(X,Y);

                    if (neighborhoodPixel.w &gt; EPSILON) {

                        // Check if this neighborhood pixel has already been recorded
                        bool found = false;
                        for (int i = 0; i &lt; numUniqueColors; ++i) {
                            if (fabs(uniqueColors[i].x - neighborhoodPixel.x) &lt; EPSILON &amp;&amp;
                                fabs(uniqueColors[i].y - neighborhoodPixel.y) &lt; EPSILON &amp;&amp;
                                fabs(uniqueColors[i].z - neighborhoodPixel.z) &lt; EPSILON &amp;&amp;
                                fabs(uniqueColors[i].w - neighborhoodPixel.w) &lt; EPSILON) {

                                colorCounts[i]++;
                                found = true;
                                break;
                            }
                        }
                   

                        // If it's a new unique color, add it to our list
                        if (!found &amp;&amp; numUniqueColors &lt; MAX_UNIQUE_COLORS) {
                            uniqueColors[numUniqueColors] = neighborhoodPixel; // Assign all components at once
                            colorCounts[numUniqueColors] = 1;
                            numUniqueColors++;
                        }
                    }
                }
            }
        }
    } else {
        // If spread is 0, just pass through the current pixel
        output = src(0,0);
    }

    // Find the most frequent color among the unique colors found
    float4 mostFrequentColor = src(0,0); // Initialize with current pixel, to handle cases with no surrounding colors
    int maxCount = -1;

    // Handle case where no unique colors were found in the neighborhood
    // (e.g., if the alpha was not 0 or spread was 0)
    if (numUniqueColors &gt; 0) {
        for (int i = 0; i &lt; numUniqueColors; ++i) {
            if (colorCounts[i] &gt; maxCount) {
                maxCount = colorCounts[i];
                mostFrequentColor = uniqueColors[i];
            }
        }
    }

    dst() = mostFrequentColor;
  }
};
</pre>

<div id="Explanation (Google AI's analysis of my script)"><h1 id="Explanation (Google AI's analysis of my script)" class="header"><a href="#Explanation (Google AI's analysis of my script)">Explanation (Google AI's analysis of my script)</a></h1></div>

<p>
The FillCellsKernel is a BlinkScript image processing kernel that aims to "fill in" pixels with a zero alpha (fully transparent) by analyzing the surrounding non-transparent pixels. 
</p>

<p>
Here's a breakdown of the overall concept and flow, including how colors and their counts are tracked:
</p>

<ul>
<li>
<span id="Explanation (Google AI's analysis of my script)-Goal"></span><strong id="Goal">Goal</strong>: The core purpose is to replace transparent pixels (alpha close to 0) with the most frequently occurring color within a defined "spread" (neighborhood) of that pixel.

</ul>
<div id="Explanation (Google AI's analysis of my script)-Kernel Structure:"><h3 id="Kernel Structure:" class="header"><a href="#Explanation (Google AI's analysis of my script)-Kernel Structure:">Kernel Structure:</a></h3></div>
<ul>
<li>
Image&lt;eRead, eAccessRanged2D, eEdgeClamped&gt; src;: Declares an input image named src.

<ul>
<li>
eRead: Indicates read-only access to the image.

<li>
eAccessRanged2D: Allows the kernel to access pixels in a 2D range around the current pixel, which is necessary to examine the neighborhood.

<li>
eEdgeClamped: Specifies that when accessing pixels outside the image boundaries, the edge pixels should be repeated, preventing unexpected results.

</ul>
<li>
Image&lt;eWrite&gt; dst;: Declares an output image named dst, where the processed pixels will be written.

<li>
param: float spreadSlider;: Declares a public parameter spreadSlider that will be exposed as a knob in Nuke's BlinkScript node interface. This allows the user to control the size of the neighborhood to examine.

<li>
local: int spread;: Declares a local variable spread that will not be exposed to the user.

<li>
void define() { defineParam(spreadSlider, "Spread", 10.0f); }: The define() function is called once when the kernel is created to set the label and default value for the spreadSlider knob.

<li>
void init() { src.setRange(-spread, spread, -spread, spread); }: The init() function is called once before any pixel processing. It sets the 2D range for accessing the src image based on the spread value.

<li>
void process(int2 pos): This is the core function, executed for every pixel in the output image (pixel by pixel).

</ul>
<div id="Explanation (Google AI's analysis of my script)-Core Logic and Color Tracking (process function):"><h3 id="Core Logic and Color Tracking (process function):" class="header"><a href="#Explanation (Google AI's analysis of my script)-Core Logic and Color Tracking (process function):">Core Logic and Color Tracking (process function):</a></h3></div>

<ul>
<li>
int spread = int(spreadSlider); spread = max(1, spread);: The spreadSlider (float) is cast to an integer, and the spread value is ensured to be at least 1, defining the neighborhood size.

<li>
float4 output = 0; float alpha = src(0,0).w;: Initializes the output pixel to black (all components 0) and gets the alpha value of the current pixel.

<li>
const int MAX_UNIQUE_COLORS = 64; float4 uniqueColors[MAX_UNIQUE_COLORS]; int colorCounts[MAX_UNIQUE_COLORS]; int numUniqueColors = 0;: These lines declare arrays to store the unique colors found in the neighborhood and their respective counts. numUniqueColors keeps track of how many unique colors have been identified.

<li>
const float EPSILON = 0.001f;: Defines a small value used for floating-point comparisons to account for potential inaccuracies.

<li>
if (spread &gt; 0): Only performs the neighborhood analysis if the spread is greater than 0.

<ul>
<li>
if (fabs(alpha) &lt; EPSILON): If the current pixel's alpha is close to 0 (meaning it's transparent), the code proceeds to examine its neighborhood.

<li>
Neighborhood Iteration: Nested loops iterate through the pixels within the spread range around the current pixel.

<ul>
<li>
float4 neighborhoodPixel = src(X,Y);: Accesses the pixel in the neighborhood at the current X,Y offset.

<li>
if (neighborhoodPixel.w &gt; EPSILON): Only considers neighborhood pixels that are not fully transparent.
        === Unique Color Check: ===

<li>
The code iterates through the uniqueColors array to see if the current neighborhoodPixel has already been recorded.

<li>
fabs(uniqueColors[i].x - neighborhoodPixel.x) &lt; EPSILON performs a float comparison using epsilon to determine if the color components are approximately equal.

<li>
If a match is found, its colorCounts is incremented.

</ul>
<li>
New Unique Color: If the neighborhoodPixel is a new unique color and there's space in the uniqueColors array, it's added, and its colorCounts is initialized to 1.

</ul>
<li>
else { output = src(0,0); }: If spread is 0, the current pixel's color is simply passed through to the output.

<li>
float4 mostFrequentColor = src(0,0); int maxCount = -1;: Initializes the mostFrequentColor with the current pixel's value (to handle cases where no surrounding colors are found) and maxCount to -1.

<li>
if (numUniqueColors &gt; 0): If any unique colors were found in the neighborhood, the code proceeds to find the most frequent one.

<ul>
<li>
The loop iterates through uniqueColors, comparing colorCounts[i] to maxCount.

<li>
If colorCounts[i] is greater than maxCount, mostFrequentColor is updated to uniqueColors[i], and maxCount is updated.

</ul>
<li>
dst() = mostFrequentColor;: The output pixel at the current position (pos) is set to the mostFrequentColor. 

</ul>
<div id="Explanation (Google AI's analysis of my script)-Overall Flow:"><h3 id="Overall Flow:" class="header"><a href="#Explanation (Google AI's analysis of my script)-Overall Flow:">Overall Flow:</a></h3></div>

<ul>
<li>
Setup: The define() function sets up the spreadSlider knob for user interaction in Nuke.

<li>
Initialization: The init() function is called once to configure the src image to access a 2D range of pixels defined by the spread parameter.

<li>
Pixel-wise Processing: The process() function is executed for every pixel in the output image.

<ul>
<li>
For each pixel, it checks if it's transparent (alpha near 0).

<li>
If transparent, it iterates through its neighborhood (defined by spread).

<li>
For each non-transparent neighbor, it checks if the color is unique.

<ul>
<li>
If unique, it's added to the uniqueColors array with a count of 1.

<li>
If not unique, its count in the colorCounts array is incremented.

</ul>
</ul>
<li>
After checking all neighbors, the pixel's color is set to the mostFrequentColor found in the neighborhood.

<li>
If the pixel was not transparent, its original color is passed through. 

</ul>
<p>
In essence, the BlinkScript kernel effectively samples the colors surrounding a transparent pixel within a user-defined area and then fills that transparent pixel with the color that appears most frequently among the samples. This simulates a "fill" operation based on the dominant surrounding color. 
</p>

<div id="AI Suggested Improvements"><h1 id="AI Suggested Improvements" class="header"><a href="#AI Suggested Improvements">AI Suggested Improvements</a></h1></div>

<p>
Here are some potential performance improvements for your BlinkScript, ranging from minor tweaks to more significant structural changes:
Potential Optimizations for FillCellsKernel
</p>

<div id="AI Suggested Improvements-Early Exit for Non-Transparent Pixels"><h2 id="Early Exit for Non-Transparent Pixels" class="header"><a href="#AI Suggested Improvements-Early Exit for Non-Transparent Pixels">Early Exit for Non-Transparent Pixels</a></h2></div>

<p>
Observation: The current code processes the entire neighborhood, even if the current pixel (src(0,0)) is not transparent.
Improvement: Move the neighborhood processing inside the if (fabs(alpha) &lt; EPSILON) block.
Rationale: If a pixel is not transparent, there is no need to analyze its neighbors. Output the original value immediately. This reduces computation for opaque areas of the image. 
</p>

<div id="AI Suggested Improvements-Early Exit for Non-Transparent Pixels-Current Code Snippet:"><h4 id="Current Code Snippet:" class="header"><a href="#AI Suggested Improvements-Early Exit for Non-Transparent Pixels-Current Code Snippet:">Current Code Snippet:</a></h4></div>
<pre c++>
void process(int2 pos) {
    int spread = int(spreadSlider); //Cast slider to integer
    spread = max(1, spread); //Ensure minimum value is 1

    float4 output = 0;
    float alpha = src(0,0).w; // Get the alpha of the current pixel

    // ... (color tracking variables)

    if (spread &gt; 0) {
        // Iterate through the neighborhood
        for(int Y = -spread; Y &lt;= spread; Y++) {
            for(int X = -spread; X &lt;= spread; X++) {

                // Only examine surrounding pixels IF the current pixel's alpha is 0
                if (fabs(alpha) &lt; EPSILON) { // Using epsilon for alpha check

                    // ... (color tracking logic)

                }
            }
        }
    } else {
        // If spread is 0, just pass through the current pixel
        output = src(0,0);
    }
    // ... (find most frequent color and assign to dst)
}
</pre>
<p>
Use code with caution.
</p>

<div id="AI Suggested Improvements-Early Exit for Non-Transparent Pixels-Optimized Code Snippet:"><h4 id="Optimized Code Snippet:" class="header"><a href="#AI Suggested Improvements-Early Exit for Non-Transparent Pixels-Optimized Code Snippet:">Optimized Code Snippet:</a></h4></div>

<pre c++>
void process(int2 pos) {
    int spread = int(spreadSlider); //Cast slider to integer
    spread = max(1, spread); //Ensure minimum value is 1

    float4 output = src(0,0); // Initialize output with the current pixel's value

    if (spread &gt; 0 &amp;&amp; fabs(output.w) &lt; EPSILON) { // Only proceed if spread &gt; 0 AND the pixel is transparent
        // ... (color tracking variables)

        // Iterate through the neighborhood
        for(int Y = -spread; Y &lt;= spread; Y++) {
            for(int X = -spread; X &lt;= spread; X++) {
                float4 neighborhoodPixel = src(X,Y);
                if (neighborhoodPixel.w &gt; EPSILON) {
                    // ... (color tracking logic - same as before)
                }
            }
        }

        // Find the most frequent color among the unique colors found
        // ... (most frequent color logic - same as before)
        if (numUniqueColors &gt; 0) { // Only update if unique colors found in neighborhood
            // ... (find most frequent color)
            output = mostFrequentColor;
        }
    }

    dst() = output;
}
</pre>

<p>
Use code with caution.
</p>

<div id="AI Suggested Improvements-Optimized Color Comparison (If Possible)"><h2 id="Optimized Color Comparison (If Possible)" class="header"><a href="#AI Suggested Improvements-Optimized Color Comparison (If Possible)">Optimized Color Comparison (If Possible)</a></h2></div>

<p>
Observation: The code performs four float comparisons (x, y, z, w) for each color comparison in the inner loop.
Potential Improvement: In some cases, using the raw integer representation of floats for comparison can be faster, but this is highly dependent on the architecture. It is best to use direct float comparisons unless profiling shows a bottleneck here and the implications are understood.
Alternative Consideration: If the colors are always normalized (0-1), calculating the squared Euclidean distance between colors could be a simpler approach. This can be more robust and potentially faster if the underlying math library has optimized distance functions or SIMD instructions can be leveraged. 
</p>

<p>
Example (Using Squared Euclidean Distance for Comparison):
</p>

<pre c++>
// Function to calculate squared Euclidean distance
float colorDistanceSq(float4 color1, float4 color2) {
    float dx = color1.x - color2.x;
    float dy = color1.y - color2.y;
    float dz = color1.z - color1.z;
    float dw = color1.w - color2.w; // Include alpha in distance calculation
    return dx*dx + dy*dy + dz*dz + dw*dw;
}

// Inside the neighborhood loop:
// Check if this neighborhood pixel has already been recorded
bool found = false;
for (int i = 0; i &lt; numUniqueColors; ++i) {
    if (colorDistanceSq(uniqueColors[i], neighborhoodPixel) &lt; (EPSILON * EPSILON)) { // Compare squared distances
        colorCounts[i]++;
        found = true;
        break;
    }
}
</pre>
<p>
Use code with caution.
</p>

<div id="AI Suggested Improvements-Array Size and Early Exit for MAX_UNIQUE_COLORS"><h2 id="Array Size and Early Exit for MAX_UNIQUE_COLORS" class="header"><a href="#AI Suggested Improvements-Array Size and Early Exit for MAX_UNIQUE_COLORS">Array Size and Early Exit for MAX_UNIQUE_COLORS</a></h2></div>

<p>
Observation: Iteration occurs up to MAX_UNIQUE_COLORS (64) each time the code checks if a color is unique.
Improvement: Consider the distribution of colors in the images. If many unique colors are expected in a small spread, MAX_UNIQUE_COLORS might be necessary or require a larger value. However, if the images are relatively flat or have fewer colors in a given neighborhood, MAX_UNIQUE_COLORS could potentially be reduced to save memory, although this might not provide a significant speedup.
Improvement (early exit for unique colors): An early exit with break already exists once a color is found, which is beneficial. Also, the check if (!found &amp;&amp; numUniqueColors &lt; MAX_UNIQUE_COLORS) ensures the array bounds are not exceeded. 
</p>

<div id="AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)"><h2 id="Loop Unrolling (Manual or Compiler-Driven)" class="header"><a href="#AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)">Loop Unrolling (Manual or Compiler-Driven)</a></h2></div>

<p>
Observation: The inner loops for iterating through the neighborhood and finding unique colors are small and predictable.
Potential Improvement: For small spread values (e.g., 1 or 2), the loops could be manually unrolled. This might reduce loop overhead and potentially allow the compiler to generate more efficient SIMD instructions.
Rationale: This reduces the overhead of loop control and can expose opportunities for instruction-level parallelism.
Consideration: Compilers are often very good at loop unrolling automatically. It is often best to trust the compiler first. If profiling indicates a bottleneck, manual unrolling could be investigated. 
</p>

<p>
Example (for spread = 1):
</p>

<pre c++>
// Instead of nested loops, directly access the 9 pixels:
float4 neighborhoodPixel = src(-1,-1); // ... process
neighborhoodPixel = src(0,-1);    // ... process
// ... and so on for all 9 pixels
</pre>
<p>
Use code with caution.
</p>

<div id="AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-SIMD Optimization (BlinkScript and Compiler)"><h3 id="SIMD Optimization (BlinkScript and Compiler)" class="header"><a href="#AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-SIMD Optimization (BlinkScript and Compiler)">SIMD Optimization (BlinkScript and Compiler)</a></h3></div>

<p>
Observation: BlinkScript is designed to leverage SIMD (Single Instruction, Multiple Data) on CPUs and GPUs through OpenCL/CUDA.
Improvement: Ensure the data is laid out efficiently to help with SIMD. Using float4 for colors is already a good practice. The compiler often handles SIMD vectorization automatically.
Consideration: Avoid complex branching or memory access patterns that might hinder automatic vectorization. The color comparison loop with if statements could be a target for manual optimization if the compiler struggles, but this is advanced and often not necessary. Foundry Community discusses optimizing code for BlinkScript mentions that the sort sequence in a BlinkScript is so explicit it could be flattened for each member. 
</p>

<div id="AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-Reduce setRange Calls (If Applicable)"><h3 id="Reduce setRange Calls (If Applicable)" class="header"><a href="#AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-Reduce setRange Calls (If Applicable)">Reduce setRange Calls (If Applicable)</a></h3></div>

<p>
Observation: src.setRange(-spread, spread, -spread, spread); is called inside init().
Improvement: This is already the correct place. Since init() is called only once per kernel, calling setRange here is efficient. If the spread parameter were changed dynamically inside the process() function and the range recalculated, that would be inefficient. 
</p>

<div id="AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-Pre-calculate (EPSILON * EPSILON)"><h3 id="Pre-calculate (EPSILON * EPSILON)" class="header"><a href="#AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-Pre-calculate (EPSILON * EPSILON)">Pre-calculate (EPSILON * EPSILON)</a></h3></div>

<p>
Observation: The code compares colorDistanceSq(uniqueColors[i], neighborhoodPixel) &lt; (EPSILON * EPSILON).
Minor Improvement: Pre-calculate EPSILON_SQ = EPSILON * EPSILON once, perhaps as a const or in init(), to avoid recomputing it for every comparison. A good compiler will likely optimize this anyway. 
</p>

<div id="AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-General BlinkScript Performance Considerations"><h3 id="General BlinkScript Performance Considerations" class="header"><a href="#AI Suggested Improvements-Loop Unrolling (Manual or Compiler-Driven)-General BlinkScript Performance Considerations">General BlinkScript Performance Considerations</a></h3></div>

<p>
Hardware: Set Nuke preferences to utilize the GPU if possible. Foundry Support mentions increasing the VRAM Nuke can use.
Memory Access: BlinkScript performs well when memory access is coherent. Accessing pixels in a predictable pattern is generally good.
Profiling: Utilize the built-in profiler to identify bottlenecks, if you have NukeX. This will indicate which parts of the code are taking the most time and guide optimization efforts. Optimizely notes that preview mode in Optimizely uses a different snippet than the one in production and is often slower.
Complexity: Be aware of the complexity of the operations inside the inner loops. More complex calculations will take longer.
Image Size: The larger the image, the longer it will take to process. 
</p>

<p>
Implementing some of these suggestions, especially the early exit for non-transparent pixels, should result in a performance boost in your FillCellsKernel. Always test and profile the changes to confirm they improve performance for your specific use cases.
</p>

<p>
<a href="nuke_blinkscript_index.html">Nuke - Blinkscript</a>
</p>

<p>
<a href="nuke_index.html">Nuke Index</a>
</p>

<p>
<a href="index.html">index</a>
</p>

</body>
</html>
