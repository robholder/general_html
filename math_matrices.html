<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>math_matrices</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
<a href="index.html">index</a>  
</p>

<p>
<a href="math_index.html">Math - Index</a>
</p>

<div id="Matrices"><h2 id="Matrices" class="header"><a href="#Matrices">Matrices</a></h2></div>


<div id="Multiplying Matrices"><h1 id="Multiplying Matrices" class="header"><a href="#Multiplying Matrices">Multiplying Matrices</a></h1></div>

<p>
This is a great explanation of the steps and strategy to work through matrix multiplications:
</p>
<ul>
<li>
<a href="https://www.youtube.com/watch?v=re9g9MYS_d0">YouTube - Matrix Multiplication with two 3x3 matrices</a>

</ul>
<p>
The biggest thing I got from the video above: to find the item on row# and column#, run the row number from the first 3x3 matrix with the column number of the second 3x3 matrix.
</p>

<p>
So to find the center result of the end matrix, row two of the first matrix against the column two of the second matrix.
</p>

<div id="Multiplying Matrices-The Rule for Matrix Multiplication"><h2 id="The Rule for Matrix Multiplication" class="header"><a href="#Multiplying Matrices-The Rule for Matrix Multiplication">The Rule for Matrix Multiplication</a></h2></div>

<p>
<span id="Multiplying Matrices-The Rule for Matrix Multiplication-Compatibility:"></span><strong id="Compatibility:">Compatibility:</strong> If you have two matrices, say <code>A</code> and <code>B</code>, you can multiply them if the number of columns in <code>A</code> is equal to the number of rows in <code>B</code>.
</p>
<ul>
<li>
For example, if <code>A</code> is an <code>m × n</code> matrix and <code>B</code> is an <code>r × p</code> matrix, then multiplication <code>A ⋅ B</code> is only defined when:

<ul>
<li>
<code>n = r</code>

</ul>
<li>
If this condition fails, the product is undefined.

<li>
Dimensions of the Result: When the multiplication is defined, the resulting matrix will have the dimensions of the number of rows from <code>A</code> by the number of columns from <code>B</code> . In the example above, the product <code>C = A ⋅ B</code> will be an <code>m × p</code> matrix.

</ul>
<div id="Multiplying Matrices-The Rule for Matrix Multiplication-Diagram - Compatibility"><h4 id="Diagram - Compatibility" class="header"><a href="#Multiplying Matrices-The Rule for Matrix Multiplication-Diagram - Compatibility">Diagram - Compatibility</a></h4></div>

<pre plaintext>
                             MATRIX ONE     MATRIX TWO
        ┌      ┐
        │ 1  0 │            Rows  Columns  Rows  Columns
        │      │             │          │  │        │
        │ 0  1 │             └──────┐   │  │   ┌────┘
        └      ┘                    ▼   ▼  ▼   ▼
       Matrix One                   2 x 2  2 x 4
                                    ▲   ▲  ▲   ▲
    ┌              ┐                │   └──┘   │
    │ -1  3  2  1  │                │   MUST   │
    │              │                │  MATCH!  │
    │  2  0 -2  2  │                │          │
    └              ┘                │          │
       Matrix Two                   └──────────┘
                                       RESULT
                                       MATRIX
                                        SIZE
                                        2 x 4
</pre>

<div id="Multiplying Matrices-Example"><h2 id="Example" class="header"><a href="#Multiplying Matrices-Example">Example</a></h2></div>
<p>
Let’s say we have a 2×3 matrix A and a 3×2 matrix B:
</p>
<pre plaintext>
A = | 1 2 3 |   B = | 7  8  | 
    | 4 5 6 | ,     | 9  10 |
                    | 11 12 |
</pre>

<div id="Multiplying Matrices-Example-Check Compatibility:"><h4 id="Check Compatibility:" class="header"><a href="#Multiplying Matrices-Example-Check Compatibility:">Check Compatibility:</a></h4></div>

<p>
<code>A</code> has 3 columns and <code>B</code> has 3 rows, so <code>A ⋅ B</code> is defined.
</p>

<div id="Multiplying Matrices-Example-Dimensions of the Result:"><h4 id="Dimensions of the Result:" class="header"><a href="#Multiplying Matrices-Example-Dimensions of the Result:">Dimensions of the Result:</a></h4></div>

<p>
The result will be a 2×2 matrix (2 rows from <code>A</code> and 2 columns from <code>B</code>).
</p>

<div id="Multiplying Matrices-Example-Computations:"><h4 id="Computations:" class="header"><a href="#Multiplying Matrices-Example-Computations:">Computations:</a></h4></div>


<pre>
cᵢⱼ = ∑ₖ₌₁ⁿ aᵢₖ · bₖⱼ
</pre>

<p>
Explanation:
</p>
<ul>
<li>
<code>cᵢⱼ</code>: Represents the element in the <code>i‑th</code> row and <code>j‑th</code> column of the resulting matrix.

<li>
<code>∑ₖ₌₁ⁿ</code>: This is the summation symbol with the index <code>k</code> running from <code>1</code> to <code>n</code> (and <code>n</code> would be 3 in this case).

<li>
<code>aᵢₖ</code>: Represents the element in the <code>i‑th</code> row and <code>k‑th</code> column of the first matrix.

<li>
<code>bₖⱼ</code>: Represents the element in the <code>k‑th</code> row and <code>j‑th</code> column of the second matrix.

<li>
<code>·</code>: Indicates multiplication.

</ul>
<p>
This notation compactly expresses that each element <code>cᵢⱼ</code> is computed by summing the products of corresponding elements in the <code>i‑th</code> row of the first matrix and the <code>j‑th</code> column of the second matrix.
Element at (1,1):
</p>

<ul>
<li>
c 1,1 = (1 × 7) + (2 × 9) + (3 × 11) = 7 + 18 + 33 = 58.

</ul>
<p>
Element at (1,2):
</p>
<ul>
<li>
c 1,2 = (1 × 8) + (2 × 10) + (3 × 12) = 8 + 20 + 36 = 64.

</ul>
<p>
Element at (2,1):
</p>
<ul>
<li>
c 2,1 = (4 × 7) + (5 × 9) + (6 × 11) = 28 + 45 + 66 = 139.

</ul>
<p>
Element at (2,2):
</p>
<ul>
<li>
c 2,2 = (4 × 8) + (5 × 10) + (6 × 12) = 32 + 50 + 72 = 154.

</ul>
<p>
Resulting Matrix:
</p>

<pre plaintext>
C = A ⋅ B = | 58  64  |
            | 139 154 |
</pre>


<div id="Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember"><h2 id="Summary and the &quot;Trick&quot; to Remember" class="header"><a href="#Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember">Summary and the "Trick" to Remember</a></h2></div>

<div id="Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember-Trick for Defined vs. Undefined:"><h4 id="Trick for Defined vs. Undefined:" class="header"><a href="#Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember-Trick for Defined vs. Undefined:">Trick for Defined vs. Undefined:</a></h4></div>

<ul>
<li>
<span id="Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember-Trick for Defined vs. Undefined:-Defined:"></span><strong id="Defined:">Defined:</strong> If the number of columns in the first matrix equals the number of rows in the second matrix, you can multiply the matrices.

<li>
<span id="Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember-Trick for Defined vs. Undefined:-Undefined:"></span><strong id="Undefined:">Undefined:</strong> If not, the matrices cannot be multiplied.

</ul>
<div id="Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember-Key Steps:"><h4 id="Key Steps:" class="header"><a href="#Multiplying Matrices-Summary and the &quot;Trick&quot; to Remember-Key Steps:">Key Steps:</a></h4></div>

<ul>
<li>
Check dimensions: If <code>A</code> is <code>m × n</code> and <code>B</code> is <code>r × p</code>, multiplication is only defined if <code>n = r</code>.

<li>
The product matrix will have dimensions <code>m × p</code>.

<li>
To compute each element, take the dot product of the corresponding row of <code>A</code> with the corresponding column of <code>B</code>.

</ul>
<p>
This process not only tells you whether the multiplication is defined but also provides a clear method for performing the operation when it is possible.
</p>

<div id="Transforms"><h1 id="Transforms" class="header"><a href="#Transforms">Transforms</a></h1></div>

<p>
This is the best explanation of the transform process!
</p>
<ul>
<li>
<a href="https://youtu.be/kYB8IZa5AuE?si=4waKdJErbjwE3P2a">YouTube - Linear Transformations</a>

</ul>
  
<p>
My own explorations with Python (Copilot help) and transforms:
</p>
<ul>
<li>
<a href="math_matrices_transforms_with_python.html">Vimwiki Link - Transforms with Python</a>

</ul>
  
<p>
Example of process:
</p>
<pre plaintext>
                    Y
                    ▲
        ┌─ ─┐       │
   ──►  │ 2 │       │
    P = │   │       │
        │ 1 │       │
        └─ ─┘       │
                    │
        ┌─    ─┐    │
    T = │ 2  1 │    │     ─►
        │      │    │     P
        │-1  2 │    │     •         ─►
        └─    ─┘    │               P2
                   ─┼───────────────•──────► X
                   O│

      ─►  ┌─    ─┐ ┌─ ─┐   ┌─ ─┐
   T • p  │ 2  1 │ │ 2 │ = │ 5 │ = P2
          │      │ │   │   │   │
          │-1  2 │ │ 1 │   │ 0 │
          └─    ─┘ └─ ─┘   └─ ─┘
</pre>

<div id="Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix"><h2 id="Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix" class="header"><a href="#Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix">Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix</a></h2></div>

<div id="Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix-Representation:"><h3 id="Representation:" class="header"><a href="#Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix-Representation:">Representation:</a></h3></div>
<ul>
<li>
Transformation Matrix (2x2):

</ul>
  
<pre plaintext>
T = [ a  b ]
    [ c  d ]
</pre>

<ul>
<li>
Point Coordinate (as a column vector, 2x1):

</ul>
  
<pre plaintext>
v = [ x ]
    [ y ]
</pre>

<div id="Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix-The Multiplication Process:"><h3 id="The Multiplication Process:" class="header"><a href="#Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix-The Multiplication Process:">The Multiplication Process:</a></h3></div>

<p>
When you multiply a matrix by a vector—i.e., compute <code>T · v</code> you perform the following:
</p>
<ul>
<li>
For the first element of the result:

<ul>
<li>
Take the first row of the transformation matrix: <code>[a, b]</code>

<li>
Compute its dot product with the column vector <code>[x, y]</code>:

</ul>
</ul>
  
<pre plaintext>
new_x = a * x + b * y
</pre>

<ul>
<li>
For the second element of the result:

<ul>
<li>
Take the second row of the transformation matrix: <code>[c, d]</code>

<li>
Compute its dot product with <code>[x, y]</code>:

</ul>
</ul>
  
<pre plaintext>
new_y = c * x + d * y
</pre>

<div id="Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix-Result:"><h3 id="Result:" class="header"><a href="#Transforms-Standard Matrix-Vector Multiplication for a 2x2 Transform Matrix-Result:">Result:</a></h3></div>

<p>
The resulting vector (transformed coordinates) will be:
</p>
<pre plaintext>
v' = [ new_x ]
     [ new_y ]
   = [ a*x + b*y ]
     [ c*x + d*y ]
</pre>

<p>
A good way to visualize this is:
</p>

<pre plaintext>
| a  b | * | x | = x * | a | + y * | b | = | a*x + b*y |
| c  d |   | y |       | c |       | d |   | c*x + d*y |
</pre>

<div id="Transforms-Another Look"><h2 id="Another Look" class="header"><a href="#Transforms-Another Look">Another Look</a></h2></div>

<p>
Let's say you have a 2D point represented as a <code>2×1</code> column vector (its position) and you want to apply a transformation (like rotation, scaling, or even translation). There are two common scenarios:
</p>

<div id="Transforms-Scenario 1:"><h2 id="Scenario 1:" class="header"><a href="#Transforms-Scenario 1:">Scenario 1:</a></h2></div>

<div id="Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only"><h3 id="Linear Transformation (Rotation, Scaling, Shear) Only" class="header"><a href="#Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only">Linear Transformation (Rotation, Scaling, Shear) Only</a></h3></div>

<div id="Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Represent the 2D Point:"><h4 id="Represent the 2D Point:" class="header"><a href="#Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Represent the 2D Point:">Represent the 2D Point:</a></h4></div>

<p>
Write the point as a 2×1 column vector:
</p>
<pre plaintext>
p = [ x ]
    [ y ]
</pre>

<div id="Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Define the 2×2 Transformation Matrix:"><h4 id="Define the 2×2 Transformation Matrix:" class="header"><a href="#Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Define the 2×2 Transformation Matrix:">Define the 2×2 Transformation Matrix:</a></h4></div>

<p>
The transformation matrix (which handles rotation, scaling, shear, etc.) is written as:
</p>
<pre plaintext>
T = [ a  b ]
    [ c  d ]
</pre>

<ul>
<li>
Here, <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are the transformation coefficients.

</ul>
<div id="Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Multiply the Transformation Matrix with the Point:"><h4 id="Multiply the Transformation Matrix with the Point:" class="header"><a href="#Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Multiply the Transformation Matrix with the Point:">Multiply the Transformation Matrix with the Point:</a></h4></div>

<p>
Calculate the new point p' by multiplying T by p. The multiplication is done by taking the dot product of each row of T with the column vector p.
</p>
<ul>
<li>
First Row Calculation (New x-coordinate):

</ul>
  
<pre plaintext>
new_x = a*x + b*y
</pre>

<ul>
<li>
Second Row Calculation (New y-coordinate):

</ul>
  
<pre plaintext>
new_y = c*x + d*y
</pre>

<div id="Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Result:"><h4 id="Result:" class="header"><a href="#Transforms-Scenario 1:-Linear Transformation (Rotation, Scaling, Shear) Only-Result:">Result:</a></h4></div>

<p>
The transformed point is:
</p>

<pre plaintext>
p' = [ new_x ]
     [ new_y ]
   = [ a*x + b*y ]
     [ c*x + d*y ]
</pre>

<p>
In other words, the new Cartesian coordinates are:
</p>

<pre plaintext>
(new_x, new_y) = (a*x + b*y,  c*x + d*y)
</pre>

<div id="Transforms-Scenario 1:-Formula for Rotation Matrix"><h3 id="Formula for Rotation Matrix" class="header"><a href="#Transforms-Scenario 1:-Formula for Rotation Matrix">Formula for Rotation Matrix</a></h3></div>

<div id="Transforms-Scenario 1:-Formula for Rotation Matrix-[[https://erwanleroy.com/vector-tools-for-nuke-tutorials-and-math/|External Link - Erwan Leroy]]"><h4 id="[[https://erwanleroy.com/vector-tools-for-nuke-tutorials-and-math/|External Link - Erwan Leroy]]" class="header"><a href="#Transforms-Scenario 1:-Formula for Rotation Matrix-[[https://erwanleroy.com/vector-tools-for-nuke-tutorials-and-math/|External Link - Erwan Leroy]]"><a href="https://erwanleroy.com/vector-tools-for-nuke-tutorials-and-math/">External Link - Erwan Leroy</a></a></h4></div>
<div id="Transforms-Scenario 1:-Formula for Rotation Matrix-[[https://www.guillemramisadesoto.com/blink-101| External Link - Guillem Ramisa de Soto]]"><h4 id="[[https://www.guillemramisadesoto.com/blink-101| External Link - Guillem Ramisa de Soto]]" class="header"><a href="#Transforms-Scenario 1:-Formula for Rotation Matrix-[[https://www.guillemramisadesoto.com/blink-101| External Link - Guillem Ramisa de Soto]]"><a href="https://www.guillemramisadesoto.com/blink-101">External Link - Guillem Ramisa de Soto</a></a></h4></div>

<p>
So, here is the formula with a language that we can actually understand:
</p>

<pre plaintext>
X = pos.x * cos(radians) - pos.y * sin(radians)
Y = pos.x * sin(radians) + pos.y * cos(radiasn)
</pre>

<div id="Transforms-Scenario 1:-Copilot's Breakdown Of Rotation Calculation"><h3 id="Copilot's Breakdown Of Rotation Calculation" class="header"><a href="#Transforms-Scenario 1:-Copilot's Breakdown Of Rotation Calculation">Copilot's Breakdown Of Rotation Calculation</a></h3></div>

<p>
Let's break it down with a concrete example and a bit of pseudocode to show how the math turns into actual transformation steps.
</p>

<div id="Transforms-Scenario 1:-Copilot's Breakdown Of Rotation Calculation-Recap: The Core Math"><h4 id="Recap: The Core Math" class="header"><a href="#Transforms-Scenario 1:-Copilot's Breakdown Of Rotation Calculation-Recap: The Core Math">Recap: The Core Math</a></h4></div>

<p>
If you want to rotate a point ( x , y) by an angle θ , the formulas are:
</p>

<pre plaintext>
x′ = x ⋅ cos θ − y ⋅ sin  θ
y′ = x ⋅ sin θ + y ⋅ cos  θ
</pre>
 
<p>
This is encapsulated in the rotation matrix:
</p>

<pre plaintext>

R ( θ) = [ cos θ  −sin θ ]
         [ sin θ   cos θ ]

When you multiply this matrix by the column vector [ x ], you get the new coordinates 
                                                   [ y ]
[ x′ ]
[ y′ ] .

=== A Step-by-Step Walkthrough ===

Suppose you have a point (2 , 3) and you want to rotate it by 45∘. Here’s how you’d do that:
* Convert Degrees to Radians Many programming languages use radians for trigonometric functions, so 45 ∘ becomes:

θ = π/4 ≈ 0.7854 radians

* Compute Sine and Cosine

cos θ ≈ 0.7071 and sin θ ≈ 0.7071

* Form the Rotation Matrix

R (45∘) = [ 0.7071 −0.7071 ]
          [ 0.7071  0.7071 ]
 
* Apply the Transformation Multiply the matrix by the point [ 2 ]
                                                            [ 3 ]
 
[ 0.7071 − 0.7071] [2] = [ 2 * 0.7071 – 3 * 0.7071 ] = [ –0.7071 ]
[ 0.7071   0.7071] [3]   [ 2 * 0.7071 + 3 * 0.7071 ]   [  3.5355 ]
 
So, the new coordinates are approximately ( −0.71, 3.54).

== A Practical Implementation in Python ==

Here’s how you could code this in Python using NumPy:

{{{python
import math
import numpy as np

# Define the rotation angle in degrees, then convert to radians
angle_degrees = 45
theta = math.radians(angle_degrees)

# Calculate cosine and sine of the angle
cos_theta = math.cos(theta)
sin_theta = math.sin(theta)

# Construct the rotation matrix
R = np.array([
    [cos_theta, -sin_theta],
    [sin_theta, cos_theta]
])

# Define the point to rotate, say (2, 3)
point = np.array([2, 3])

# Multiply the rotation matrix by the point vector
rotated_point = R.dot(point)

print("Original Point:", point)
print("Rotated Point:", rotated_point)
</pre>

<p>
This script:
</p>
<ul>
<li>
Converts the rotation angle from degrees to radians.

<li>
Computes the sine and cosine values.

<li>
Constructs the 2 × 2 rotation matrix.

<li>
Applies it to the point (2, 3) via matrix multiplication.

</ul>
<p>
When you run this code, you’ll get the transformed coordinates as shown in our math above.
</p>

<div id="Transforms-Visualizing the Process"><h2 id="Visualizing the Process" class="header"><a href="#Transforms-Visualizing the Process">Visualizing the Process</a></h2></div>

<p>
Imagine you have a coordinate system:
</p>

<ul>
<li>
The original point (2, 3) lies somewhere in the first quadrant.

<li>
After rotation, the point (−0.71, 3.54) still lives in the upper half of the diagram.

</ul>
<p>
A simple ASCII diagram might look like this (note: not to scale):
</p>
<pre plaintext>
       y
       |  
   3.5 *       &lt;- rotated point (-0.71, 3.54)
       |
       |        Original point (2,3) would be further right
-------*--------- x
       |
       |
</pre>

<p>
Here, the transformation has “spun” the point around the origin while preserving its distance from the origin.
</p>

<div id="Transforms-Broader Insights"><h2 id="Broader Insights" class="header"><a href="#Transforms-Broader Insights">Broader Insights</a></h2></div>

<p>
Understanding 2D rotation matrices is fundamental in various fields such as computer graphics, robotics, and game development. They offer a straightforward way to manipulate objects by changing their orientations. Once you grasp this, combining it with translation (moving points around) leads to creating transformation pipelines for more complex operations.
</p>


<div id="Transforms-Scenario 2"><h2 id="Scenario 2" class="header"><a href="#Transforms-Scenario 2">Scenario 2</a></h2></div>

<div id="Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point"><h3 id="Affine Transformation (Including Translation) for a 2D Point" class="header"><a href="#Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point">Affine Transformation (Including Translation) for a 2D Point</a></h3></div>

<div id="Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Represent the Point in Homogeneous Coordinates:"><h4 id="Represent the Point in Homogeneous Coordinates:" class="header"><a href="#Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Represent the Point in Homogeneous Coordinates:">Represent the Point in Homogeneous Coordinates:</a></h4></div>

<p>
Instead of representing a point as (x, y), we add a third coordinate to form a 3x1 column vector:
</p>

<pre plaintext>
p_h = [ x ]
      [ y ]
      [ 1 ]
</pre>

<div id="Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Define the 3x3 Transformation Matrix:"><h4 id="Define the 3x3 Transformation Matrix:" class="header"><a href="#Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Define the 3x3 Transformation Matrix:">Define the 3x3 Transformation Matrix:</a></h4></div>

<p>
The transformation that includes rotation, scaling, and translation is written as a 3x3 matrix:
</p>

<pre plaintext>
T_h = [ a   b   tx ]
      [ c   d   ty ]
      [ 0   0    1 ]
</pre>

<ul>
<li>
Here, <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are the coefficients for scaling, rotation, or shearing.

<li>
<code>tx</code> and <code>ty</code> are the translation amounts (shifts) in the <code>x</code> and <code>y</code> directions.

</ul>
<p>
The bottom row <code>[0 0 1]</code> is used to keep the homogeneous form.
</p>

<div id="Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Multiply the Transformation Matrix with the Point:"><h4 id="Multiply the Transformation Matrix with the Point:" class="header"><a href="#Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Multiply the Transformation Matrix with the Point:">Multiply the Transformation Matrix with the Point:</a></h4></div>

<p>
The new point, <code>p'_h</code>, is obtained by computing the matrix product:
</p>

<pre plaintext>
p'_h = T_h * p_h
</pre>

<p>
This multiplication proceeds row by row, taking the dot product of each row of <code>T_h</code> with the column vector <code>p_h</code>:
</p>

<ul>
<li>
First row calculation (new x-coordinate):

</ul>
  
<pre plaintext>
new_x = a*x + b*y + tx
</pre>

<ul>
<li>
Second row calculation (new y-coordinate):

</ul>
  
<pre plaintext>
new_y = c*x + d*y + ty
</pre>

<ul>
<li>
Third row calculation:

</ul>
  
<p>
The third row dot product is:
</p>

<pre plaintext>
0*x + 0*y + 1*1 = 1
</pre>

<p>
This ensures the transformed point remains in homogeneous coordinates.
</p>

<div id="Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Result:"><h4 id="Result:" class="header"><a href="#Transforms-Scenario 2-Affine Transformation (Including Translation) for a 2D Point-Result:">Result:</a></h4></div>

<p>
The resulting transformed point in homogeneous coordinates is:
</p>

<pre plaintext>
p'_h = [ new_x ]
       [ new_y ]
       [   1   ]
     = [ a*x + b*y + tx ]
       [ c*x + d*y + ty ]
       [       1        ]
</pre>

<p>
This means the new normal (Cartesian) coordinates for the point are:
</p>

<pre plaintext>
(new_x, new_y) = (a*x + b*y + tx,  c*x + d*y + ty)
</pre>

<div id="Transforms-Quick Recap"><h2 id="Quick Recap" class="header"><a href="#Transforms-Quick Recap">Quick Recap</a></h2></div>

<ul>
<li>
2×2 Transform with a 2×1 Point (Linear Only):

</ul>
  
<pre plaintext>
[ a  b ]   [ x ]   =   [ a*x + b*y ]
[ c  d ] x [ y ]       [ c*x + d*y ]
</pre>

<ul>
<li>
3×3 Transform (Affine) with Homogeneous Coordinates:

</ul>
  
<pre plaintext>
[ a  b  tx ]   [ x ]   =   [ a*x + b*y + tx ]
[ c  d  ty ] x [ y ]       [ c*x + d*y + ty ]
[ 0  0   1 ]   [ 1 ]       [        1         ]
</pre>

<p>
Using these techniques, you can transform a point by applying any combination of linear and translational changes, a core operation in many graphics and geometry applications.
</p>

<div id="Transforms-Transform 3-Point Polygon"><h2 id="Transform 3-Point Polygon" class="header"><a href="#Transforms-Transform 3-Point Polygon">Transform 3-Point Polygon</a></h2></div>

<p>
If you have three points (defining a 2d triangle), you can combine the coordinate matrices and use a Transform Matrix to 'transform' the triangle in one step:
</p>

<ul>
<li>
<a href="https://www.khanacademy.org/math/algebra-home/alg-matrices/alg-matrices-as-transformations/v/matrix-transformation-triangle">YouTube - Transforming Polygons Using Matrices</a>

</ul>
<p>
In this example, the three points (P1, P2, P3) become PT1, PT2, and PT3 after the transform matrix is multiplied against them (in one combined 2x3 matrix):
</p>

<pre plaintext>
                             ▲
  P1=|2|  P2=|-2|  P3=|0|    │
     |1|     | 0|     |2|    │
                             │
                             │      PT3
  T =| 2 1|                  │     º
     |-1 2|         PT2      │
                      º      •P3
                             │
                             │   •P1
                   ────•─────┼─────────º──────────►
                      P2     │        PT1
                             │
        ─► ─► ─►             │
   T • |P1 P2 P3|            │


   | 2 1| • |2 -2 0| =  |5 -4  2|
   |-1 2|   |1  0 2|    |0  2  4|

     T    • P1 P2 P3 = PT1 PT2 PT3
</pre>

<div id="Notes on Matrix Sizes (NxN)"><h1 id="Notes on Matrix Sizes (NxN)" class="header"><a href="#Notes on Matrix Sizes (NxN)">Notes on Matrix Sizes (NxN)</a></h1></div>

<ul>
<li>
Not all transform matrices have 2 rows.

<li>
The number of rows depends on the dimension of the space and the transformation type:

<ul>
<li>
2×2 matrices for simple 2D linear transformations.

<li>
3×3 matrices for 2D affine transformations (with translation).

<li>
3×3 or 4×4 matrices for 3D operations.

</ul>
</ul>
<p>
Transform matrices come in different sizes depending on the context and the type of transformation you're performing. Here’s a breakdown:
</p>
<ul>
<li>
2D Linear Transformations: For pure linear transformations in two dimensions (such as rotations, scalings, shears, etc., without translation), a 2×2 matrix is typically used. Each 2×2 matrix transforms a 2D vector directly:

</ul>
  
<pre plaintext>
[ a  b ]
[ c  d ]
</pre>
<ul>
<li>
2D Affine Transformations: When you want to include translations (shifting the point), you usually switch to homogeneous coordinates. This requires a 3×3 matrix to handle both the linear part and the translation:

</ul>
  
<pre plaintext>
[ a  b  tx ]
[ c  d  ty ]
[ 0  0  1  ]
</pre>
<p>
Here, the transform matrix has 3 rows, even though the result (the transformed (x, y) coordinates) is still a 2D point. The extra row is there to support the translation component.
</p>

<ul>
<li>
3D Transformations: In 3D space, linear transformations are often represented by 3×3 matrices, while affine transformations (including translation) are represented using 4×4 matrices with homogeneous coordinates.

</ul>
<div id="Translating with Matrices"><h1 id="Translating with Matrices" class="header"><a href="#Translating with Matrices">Translating with Matrices</a></h1></div>

<div id="Translating with Matrices-Translation in Transform Matrices"><h2 id="Translation in Transform Matrices" class="header"><a href="#Translating with Matrices-Translation in Transform Matrices">Translation in Transform Matrices</a></h2></div>

<p>
Translation is a key component of transformation matrices, but unlike scaling or rotation, it <span id="Translating with Matrices-Translation in Transform Matrices-cannot"></span><strong id="cannot">cannot</strong> be represented using a standard 2×2 matrix. Instead, translation requires <span id="Translating with Matrices-Translation in Transform Matrices-homogeneous coordinates"></span><strong id="homogeneous coordinates">homogeneous coordinates</strong>, which introduce an extra dimension.
</p>

<p>
For 2D translation, we use a 3×3 matrix:
</p>

<pre plaintext>
T = [ 1  0  tx ]
    [ 0  1  ty ]
    [ 0  0  1  ]
</pre>

<p>
When multiplying this matrix by a homogeneous coordinate [x, y, 1], the result is:
</p>

<pre plaintext>
[x' y' 1] = [ 1  0  tx ]   [ x ]
            [ 0  1  ty ] * [ y ]
            [ 0  0  1  ]   [ 1 ]
</pre>

<p>
Which simplifies to:
</p>

<pre plaintext>
x' = x + tx
y' = y + ty
</pre>

<p>
This means translation simply adds the tx and ty values to the original coordinates.
</p>

<p>
For <span id="Translating with Matrices-Translation in Transform Matrices-3D translation"></span><strong id="3D translation">3D translation</strong>, the matrix expands to <span id="Translating with Matrices-Translation in Transform Matrices-4×4"></span><strong id="4×4">4×4</strong>:
</p>

<pre plaintext>
T = [ 1  0  0  tx ]
    [ 0  1  0  ty ]
    [ 0  0  1  tz ]
    [ 0  0  0  1  ]
</pre>

<p>
This allows translation in x, y, and z directions.
</p>

<p>
You can read more about translation matrices and their role in CG <a href="https://www.mauriciopoppe.com/notes/computer-graphics/transformation-matrices/translation/">here</a>.
</p>



<p>
<a href="math_index.html">Math - Index</a>
</p>

<p>
<a href="index.html">index</a>  
</p>

</body>
</html>
